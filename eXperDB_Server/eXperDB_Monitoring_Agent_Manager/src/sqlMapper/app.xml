<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="app">

<!-- ********************************************************** -->
<!-- RscCollect START -->
<!-- ********************************************************** -->
	<insert id="TB_RSC_COLLECT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_RSC_COLLECT_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			NEXTVAL('RSC_REG_SEQ'),
			#{instance_id},
			#{is_collect_ok},
			#{failed_collect_type},
			NOW()
		)
	</insert>	



	<select id="BT_MEMORY_STAT_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_MEMORY_STAT_001 */
		          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
		          --? AS RSC_REG_SEQ, -- @NEXTVAL('RSC_REG_SEQ'),
		          MEM_TOTAL_KB AS MEM_TOTAL_KB,
		          MEM_USED_KB AS MEM_USED_KB,
		          MEM_FREE_KB AS MEM_FREE_KB,
		          MEM_BUFFER_KB AS MEM_BUFFERED_KB,
		          MEM_CACHED_KB AS MEM_CACHED_KB,
		          SWP_TOTAL_KB AS SWP_TOTAL_KB,
		          SWP_USED_KB AS SWP_USED_KB,
		          SWP_CACHED_KB AS SWP_CACHED_KB,
		          SWP_FREE_KB AS SWP_FREE_KB,
		          SHM_KB AS SHM_KB,
		          0 AS PGSQL_USAGE_KB,
		          NOW() AS COLLECT_DT
		  FROM GET_STAT_MEM()
	</select>	

	<insert id="TB_MEMORY_STAT_I001" parameterType="hashmap" >
		INSERT INTO TB_MEMORY_STAT	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('RSC_REG_SEQ'),
			#{mem_total_kb},
			#{mem_used_kb},
			#{mem_free_kb},
			#{mem_buffered_kb},
			#{mem_cached_kb},
			#{swp_total_kb},
			#{swp_used_kb},
			#{swp_cached_kb},
			#{swp_free_kb},
			#{shm_kb},
			#{pgsql_usage_kb},
			#{collect_dt}
		)
	</insert>



	<select id="BT_CPU_STAT_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		SELECT /* EXPERDBMABT_CPU_STAT_DETAIL_001 */
		          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
		          --? AS RSC_REG_SEQ, -- @NEXTVAL('RSC_REG_SEQ'),
		          SEQ AS CPU_LOGICAL_ID,
		          AGG_USER_UTIL,
		          AGG_NICE_UTIL,
		          AGG_SYS_UTIL,
		          AGG_IDLE_UTIL,
		          AGG_WAIT_UTIL,
		          NOW() AS COLLECT_DT
		  FROM (SELECT SEQ,
		                    CPU_AGG_USER AS AGG_USER_UTIL,
		                    CPU_AGG_NICE AS AGG_NICE_UTIL,
		                    CPU_AGG_SYS AS AGG_SYS_UTIL,
		                    CPU_AGG_IDLE AS AGG_IDLE_UTIL,
		                    CPU_AGG_WAIT AS AGG_WAIT_UTIL
		            FROM GET_STAT_CPU_CORES()) AS A
	</select>

	<insert id="TB_CPU_STAT_MASTER_I001" parameterType="hashmap" >
		INSERT INTO TB_CPU_STAT_MASTER
		VALUES
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('RSC_REG_SEQ'),
			#{agg_user_util},
			#{agg_nice_util},
			#{agg_sys_util},
			#{agg_idle_util},
			#{agg_wait_util},
			#{current_user_util},
			#{current_nice_util},
			#{current_sys_util},
			#{current_idle_util},
			#{current_wait_util},
			#{user_util_rate},
			#{nice_util_rate},
			#{sys_util_rate},
			#{idle_util_rate},
			#{wait_util_rate},
			#{collect_dt}
		)
	</insert>	

	<insert id="TB_CPU_STAT_DETAIL_I001" parameterType="hashmap" >
		INSERT INTO TB_CPU_STAT_DETAIL
		VALUES
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('RSC_REG_SEQ'),
			#{cpu_logical_id},
			#{agg_user_util},
			#{agg_nice_util},
			#{agg_sys_util},
			#{agg_idle_util},
			#{agg_wait_util},
			#{current_user_util},
			#{current_nice_util},
			#{current_sys_util},
			#{current_idle_util},
			#{current_wait_util},
			#{user_util_rate},
			#{nice_util_rate},
			#{sys_util_rate},
			#{idle_util_rate},
			#{wait_util_rate}
		)
	</insert>



	<select id="BT_DISK_IO_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		SELECT /* EXPERDBMABT_DISK_IO_001 */
				  DISK_NAME
		         ,RD_AGG_SECTORS AS AGG_READ_KB
		         ,WR_AGG_SECTORS AS AGG_WRITE_KB
		         ,IO_AGG_MILLISEC AS AGG_IO_MSEC
		         ,SEC_FROM_EPOCH 
		         ,NOW() AS COLLECT_DT
		         --,EXTRACT(EPOCH FROM DATE_TRUNC('MILLISECONDS', NOW())) * 1000 - EXTRACT(EPOCH FROM DATE_TRUNC('MILLISECONDS', ?::TIMESTAMP)) * 1000)::NUMERIC AS MIL_SEC_DIFF
		   FROM GET_STAT_DISK_IO
	</select>


	<insert id="TB_DISK_IO_I001" parameterType="hashmap" >
		INSERT INTO TB_DISK_IO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('RSC_REG_SEQ'),
			#{disk_name},
			#{agg_read_kb},
			#{current_read_kb},
			#{read_busy_rate},
			#{agg_write_kb},
			#{current_write_kb},
			#{write_busy_rate},
			#{agg_io_msec},
			#{current_io_msec},
			#{collect_dt},
			#{delta_time}
		)
	</insert>



	<select id="BT_DISK_USAGE_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_DISK_USAGE_001 */
		          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
		          --? AS RSC_REG_SEQ, -- @NEXTVAL('RSC_REG_SEQ'),
		          DEV_NAME AS DEVICE_NAME,
		          TOT_KB AS TOTAL_KB,
		          USED_KB AS USED_KB,
		          AVAIL_KB AS AVAIL_KB,
		          MT_DIR AS MOUNT_POINT_DIR,
		          NOW() AS COLLECT_DT
		  FROM GET_STAT_DISK_USGE();
	</select>
	
	<insert id="TB_DISK_USAGE_I001" parameterType="hashmap" >
		INSERT INTO TB_DISK_USAGE	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('RSC_REG_SEQ'),
			#{device_name},
			#{total_kb},
			#{used_kb},
			#{avail_kb},
			#{mount_point_dir},
			#{collect_dt}
		)
	</insert>	
<!-- ********************************************************** -->
<!-- RscCollect END -->
<!-- ********************************************************** -->
	


<!-- ********************************************************** -->
<!-- ObjtCollect START -->
<!-- ********************************************************** -->
	<insert id="TB_OBJT_COLLECT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_OBJT_COLLECT_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			NEXTVAL('OBJT_REG_SEQ'),
			#{instance_id},
			#{is_collect_ok},			
			#{failed_collect_type},
			NOW()
		)
	</insert>


	<select id="BT_TABLESPACE_INFO_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_TABLESPACE_INFO_001 */
		          --? AS REG_DATE, --@ TO_CHAR(NOW(), 'YYYYMMDD'),
		          --? AS OBJT_REG_SEQ, --@NEXTVAL('OBJT_REG_SEQ'),
		          SPCNAME AS TABLESPACE_NAME,
		          SPCLOCATION AS LOCATION,
		          PG_TABLESPACE_SIZE(SPCNAME)/1024 AS SIZE_KB,
		          get_tbsdisk_total(spclocation) AS TOTAL_DISK_KB, 
		          get_tbsdisk_avail(spclocation) AS AVAL_DISK_KB, 
		          NULL AS FS_NAME, --예비
		          NULL AS DEVICE_NAME, -- 예비
		          NOW() AS COLLECT_DT
		  FROM PG_TABLESPACE
	</select>
	
	<insert id="TB_TABLESPACE_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_TABLESPACE_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('OBJT_REG_SEQ'),
			#{tablespace_name},
			#{location},
			#{size_kb},
			#{total_disk_kb},
			#{aval_disk_kb},
			#{fs_name},
			#{device_name},
			#{collect_dt}
		)
	</insert>
	
	
	<select id="BT_TABLE_INFO_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<![CDATA[
		SELECT /* EXPERDBMABT_TABLE_INFO_001 */
		          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
		          --? AS OBJT_REG_SEQ, -- @NEXTVAL('OBJT_REG_SEQ'),
		          B.SCHEMANAME AS SCHEMA_NAME,
		          A.RELNAME AS TABLE_NAME,
		          PG_RELATION_SIZE(A.RELID) AS TABLE_SIZE_KB,
		          COALESCE(A.TOT_IDX_SIZE, 0) AS TOT_INDEX_SIZE_KB,
		          A.IDX_CNT AS INDEX_CNT,
		          (SELECT CASE WHEN RELTOASTRELID=0 THEN 'N' ELSE 'Y' END FROM PG_CLASS PGC WHERE PGC.OID = A.RELID) AS TOAST_YN,
		          B.SEQ_SCAN AS AGG_SEQ_SCAN_CNT,
		          B.SEQ_TUP_READ AS AGG_SEQ_TUPLES,
		          COALESCE(B.IDX_SCAN, 0) AS AGG_INDEX_SCAN_CNT,
		          COALESCE(B.IDX_TUP_FETCH, 0) AS AGG_INDEX_TUPLES,
		          --B.SEQ_SCAN - ? AS CURRENT_SEQ_SCAN_CNT, --@이전값
		          --B.SEQ_TUP_READ - ? AS CURRENT_SEQ_TUPLES, --@이전값
		          --B.IDX_SCAN - ? AS CURRENT_INDEX_SCAN_CNT, --@이전값
		          --B.IDX_TUP_FETCH - ? AS CURRENT_INDEX_TUPLES, --@이전값
		          B.N_LIVE_TUP AS LIVE_TUPLE_CNT,
		          CASE WHEN LAST_VACUUM IS NULL AND LAST_AUTOVACUUM IS NULL THEN NULL WHEN LAST_VACUUM IS NULL THEN LAST_AUTOVACUUM WHEN LAST_AUTOVACUUM IS NULL THEN LAST_VACUUM WHEN LAST_VACUUM>LAST_AUTOVACUUM THEN LAST_VACUUM ELSE LAST_AUTOVACUUM END AS LAST_VACUUM,
		          CASE WHEN LAST_ANALYZE IS NULL AND LAST_AUTOANALYZE IS NULL THEN NULL WHEN LAST_ANALYZE IS NULL THEN LAST_AUTOANALYZE WHEN LAST_AUTOANALYZE IS NULL THEN LAST_ANALYZE WHEN LAST_ANALYZE>LAST_AUTOANALYZE THEN LAST_ANALYZE ELSE LAST_AUTOANALYZE END AS LAST_ANALYZE,
		          NOW() AS COLLECT_DT
		  FROM (SELECT UTB.RELNAME,
		                    UTB.SCHEMANAME,
		                    UTB.RELID,
		                    SUM(PG_RELATION_SIZE(UDX.INDEXRELID)) AS TOT_IDX_SIZE,
		                    COUNT(UDX.INDEXRELID) AS IDX_CNT 
		            FROM PG_STAT_USER_TABLES UTB LEFT OUTER JOIN PG_STAT_USER_INDEXES UDX ON UTB.RELNAME=UDX.RELNAME
           		   WHERE UTB.RELID NOT IN (SELECT RELATION FROM PG_LOCKS WHERE MODE='AccessExclusiveLock')
		          GROUP BY UTB.SCHEMANAME, UTB.RELNAME, UTB.RELID) A,
		          PG_STAT_USER_TABLES B
		 WHERE A.SCHEMANAME = B.SCHEMANAME
		    AND A.RELNAME=B.RELNAME
		]]>
	</select>
		
	<insert id="TB_TABLE_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_TABLE_INFO
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('OBJT_REG_SEQ'),
			#{db_name},
			#{schema_name},
			#{table_name},
			#{table_size_kb},
			#{tot_index_size_kb},
			#{index_cnt},
			#{toast_yn},
			#{agg_seq_scan_cnt},
			#{agg_seq_tuples},
			#{agg_index_scan_cnt},
			#{agg_index_tuples},
			#{current_seq_scan_cnt},
			#{current_seq_tuples},
			#{current_index_scan_cnt},
			#{current_index_tuples},			
			#{live_tuple_cnt},
			#{last_vacuum},
			#{last_analyze},
			#{collect_dt}
		)
	</insert>


	<select id="BT_INDEX_INFO_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_INDEX_INFO_001 */
		          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
		          --? AS OBJT_REG_SEQ, -- @NEXTVAL('OBJT_REG_SEQ'),
		          #{db_name} AS DB_NAME, -- @DATNAME
		          SCHEMANAME AS SCHEMA_NAME,
		          INDEXRELNAME AS INDEX_NAME,
		          RELNAME AS TABLE_NAME,
		          PG_RELATION_SIZE(INDEXRELID) AS INDEX_SIZE_KB,
		          (SELECT ARRAY_LENGTH(INDKEY,1) FROM PG_INDEX PDX WHERE PDX.INDEXRELID = A.INDEXRELID) AS COLUMNS_CNT,
		          IDX_SCAN AS AGG_INDEX_SCAN_CNT,
		          IDX_TUP_READ AS AGG_INDEX_SCAN_TUPLES,
		          IDX_TUP_FETCH AS AGG_INDEX_SCAN_FETCH_TUPLES,
		          NOW() AS COLLECT_DT
		 FROM  PG_STAT_USER_INDEXES A
	</select>
	
	<insert id="TB_INDEX_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_INDEX_INFO
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('OBJT_REG_SEQ'),
			#{db_name},
			#{schema_name},
			#{index_name},
			#{table_name},
			#{index_size_kb},
			#{columns_cnt},
			#{agg_index_scan_cnt},
			#{agg_index_scan_tuples},
			#{agg_index_scan_fetch_tuples},
			#{collect_dt}
		)
	</insert>	
<!-- ********************************************************** -->
<!-- ObjtCollect END -->
<!-- ********************************************************** -->



<!-- ********************************************************** -->
<!-- ActvCollect START -->
<!-- ********************************************************** -->
	<insert id="TB_ACTV_COLLECT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_ACTV_COLLECT_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			NEXTVAL('ACTV_REG_SEQ'),
			#{instance_id},
			#{is_collect_ok},
			#{failed_collect_type},
			NOW()
		)
	</insert>
	
	
	
	<select id="BT_GET_CPU_CLOCKS_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_GET_CPU_CLOCKS_001 */
			   GET_CPU_CLOCKS()	
	</select>	

	
	
	<select id="BT_CURR_LOCK_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_CURR_LOCK_001 */
		          --? AS REG_DATE, --@ TO_CHAR(NOW(), 'YYYYMMDD')
		          --? AS ACTV_REG_SEQ, --@ NEXTVAL('ACTV_REG_SEQ')
		          A.DATNAME AS DB_NAME,
		          BL.PID AS BLOCKED_PID,
		          A.USENAME AS BLOCKED_USER,
		          A.CURRENT_QUERY AS BLOCKED_STATEMENT,
		          KL.PID AS BLOCKING_PID,
		          KA.USENAME AS BLOCKING_USER,
		          KA.CURRENT_QUERY AS BLOCKING_STATEMENT,
		          NOW() - KA.QUERY_START AS BLOCKING_DURATION,
		          NOW() AS COLLECT_DT
		 FROM  PG_CATALOG.PG_LOCKS BL
		   JOIN PG_CATALOG.PG_STAT_ACTIVITY A  ON A.PROCPID = BL.PID
		   JOIN PG_CATALOG.PG_LOCKS         KL ON KL.TRANSACTIONID = BL.TRANSACTIONID AND KL.PID != BL.PID
		   JOIN PG_CATALOG.PG_STAT_ACTIVITY KA ON KA.PROCPID = KL.PID
		  WHERE NOT BL.GRANTED
	</select>
	
	<insert id="TB_CURRENT_LOCK_I001" parameterType="hashmap" >
		INSERT INTO TB_CURRENT_LOCK	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('ACTV_REG_SEQ'),
			#{db_name},
			#{blocked_pid},
			#{blocked_user},
			#{blocked_statement},
			#{blocked_duration},
			#{blocking_pid},
			#{blocking_user},
			#{blocking_statement},
			#{blocking_duration},
			#{collect_dt}
		)
	</insert>
	
	

	<select id="BT_BACKEND_RSC_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<![CDATA[	
		SELECT /* EXPERDBMABT_BACKEND_RSC_001 */
		          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
		          --? AS ACTV_REG_SEQ, -- @NEXTVAL('ACTV_REG_SEQ'),
		          A.PROC_ID AS PROCESS_ID,
		          B.DATNAME AS DB_NAME,
          		  HOST(B.CLIENT_ADDR) AS CLIENT_ADDR, -- 2014-04-28 추가
          		  B.USENAME AS USER_NAME,-- 2014-04-28 추가
          		  B.APPLICATION_NAME AS APPLICATION_NAME,-- 2014-04-28 추가		          
		          A.CPU_UTIME AS AGG_PROC_UTIME,
		          A.CPU_STIME AS AGG_PROC_STIME,
		          --CPU_UTIME - ? AS CURRENT_PROC_UTIME, --@이전값
		          --CPU_STIME - ? AS CURRENT_PROC_STIME, --@이전값
		          --ROUND( ((CPU_UTIME-?)+(CPU_STIME-?)) / CPU_CLOCKS*(MSEC_FROM_EPOCH-?)/1000 * 100, 2) AS PROC_CPU_UTIL, --@이전값 , --@이전값, --@이전값
		          ---- (CPU_UTIME-?)+(CPU_STIME-?) > CPU_CLOCKS*(MSEC_FROM_EPOCH-?)/1000 이면 CPU_CLOCK 연산
		          A.DISK_READ AS AGG_PROC_READ_KB,
		          A.DISK_WRITE AS AGG_PROC_WRITE_KB,
		          --DISK_READ - ? AS CURRENT_PROC_READ_KB,--@이전값
		          --DISK_WRITE - ? AS CURRENT_PROC_WRITE_KB,--@이전값
		          CASE WHEN B.CURRENT_QUERY='<IDLE>' THEN B.BACKEND_START WHEN B.CURRENT_QUERY='<IDLE> in transaction' THEN b.XACT_START ELSE B.QUERY_START END AS QUERY_START,
		          --CASE WHEN NOW()-B.QUERY_START< INTERVAL '0' THEN -(NOW()-B.QUERY_START) ELSE NOW()-B.QUERY_START END AS ELAPSED_TIME,
		        CASE WHEN B.CURRENT_QUERY LIKE '%IDLE%' THEN EXTRACT(EPOCH FROM NOW()-NOW())::NUMERIC ELSE ROUND(EXTRACT(EPOCH FROM NOW()-QUERY_START)::NUMERIC, 2) END AS ELAPSED_TIME,
		          B.CURRENT_QUERY AS SQL,
		          --CASE WHEN B.CURRENT_QUERY IS NULL THEN 'BACKGROUND PROC' ELSE B.CURRENT_QUERY END AS SQL,
		          A.SEC_FROM_EPOCH AS SEC_FROM_EPOCH,
		          NOW() AS COLLECT_DT
		  --FROM GET_BACKEND_RSC A LEFT OUTER JOIN PG_STAT_ACTIVITY B ON A.PROC_ID=B.PROCPID
  		  FROM GET_BACKEND_RSC A JOIN PG_STAT_ACTIVITY B ON A.PROC_ID=B.PROCPID;
		]]>    		
	</select>
	
	<insert id="TB_BACKEND_RSC_I001" parameterType="hashmap" >
		INSERT INTO TB_BACKEND_RSC	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('ACTV_REG_SEQ'),
			#{process_id},
			#{db_name},
			#{client_addr},
			#{user_name},
			#{application_name},
			#{agg_proc_utime},
			#{agg_proc_stime},
			#{current_proc_utime},
			#{current_proc_stime},
			#{proc_cpu_util},
			#{agg_proc_read_kb},
			#{agg_proc_write_kb},
			#{current_proc_read_kb},
			#{current_proc_write_kb},
			#{query_start},
			#{elapsed_time},
			#{sql},
			#{collect_dt}
		)
	</insert>
	
	
	
	<select id="PG_STAT_DATABASE_INFO_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_PG_STAT_DATABASE_INFO_001 */
			   DATID, DATNAME AS DB_NAME 
		  FROM PG_STAT_DATABASE WHERE DATNAME NOT IN ('template0','template1','postgres')
	</select>
	
	
	<select id="BT_ACCESS_INFO_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<![CDATA[
		 SELECT /* EXPERDBMABT_ACCESS_INFO_001 */                                                                                                                                                                              
		        --? AS REG_DATE, --@ TO_CHAR(NOW(), 'YYYYMMDD')                                                                                                                                                           
		        --? AS OBJT_REG_SEQ, --@NEXTVAL('OBJT_REG_SEQ')                                                                                                                                                           
		        #{db_name} AS DB_NAME, -- @DATNAME                                                                                                                                                                        
		        PG_DATABASE_SIZE(#{datid})/1024 AS DB_SIZE_KB, -- @DATID                                                                                                                                                  
		        COUNT(A.RELID) AS TABLE_CNT,                                                                                                                                                                              
		        (SELECT COUNT(INDEXRELID) FROM PG_STAT_USER_INDEXES) AS INDEX_CNT,                                                                                                                                         
		        COALESCE(SUM(A.HEAP_BLKS_READ), 0) AS AGG_HEAP_BLKS_READ_KB,                                                                                                                                                           
		        COALESCE(SUM(A.HEAP_BLKS_HIT), 0) AS AGG_HEAP_BLKS_HIT_KB,                                                                                                                                                             
		        COALESCE(SUM(B.SEQ_TUP_READ), 0) AS AGG_SEQ_READ_TUPLES,                                                                                                                                                               
		        COALESCE(SUM(B.IDX_TUP_FETCH), 0) AS AGG_IDX_FETCH_TUPLES,
	          	COALESCE(SUM(B.n_tup_ins), 0) AS AGG_INSERT_TUPLES,-- insert
	          	COALESCE(SUM(B.n_tup_upd), 0) AS AGG_UPDATE_TUPLES,-- update
	          	COALESCE(SUM(B.n_tup_del), 0) AS AGG_DELETE_TUPLES,-- delete
		        COALESCE(SUM(B.SEQ_SCAN), 0) AS AGG_SEQ_SCAN_CNT,
		        COALESCE(SUM(B.IDX_SCAN), 0) AS AGG_IDX_SCAN_CNT,	          	
	          	(SELECT XACT_COMMIT FROM PG_STAT_DATABASE WHERE DATNAME=CURRENT_DATABASE()) AS AGG_COMMIT,
	          	(SELECT XACT_ROLLBACK FROM PG_STAT_DATABASE WHERE DATNAME=CURRENT_DATABASE()) AS AGG_ROLLBACK,		        
		        COALESCE(SUM(HEAP_BLKS_READ), 0) - #{agg_heap_blks_read_kb} AS CURRENT_HEAP_BLKS_READ_KB, -- @이전값                                                                                                               
		        COALESCE(SUM(HEAP_BLKS_HIT), 0) - #{agg_heap_blks_hit_kb} AS CURRENT_HEAP_BLKS_HIT_KB, -- @이전값                                                                                                                  
		        COALESCE(SUM(B.SEQ_TUP_READ), 0) - #{agg_seq_read_tuples} AS CURRENT_SEQ_READ_TUPLES, -- @이전값 (AGG_SEQ_READ_TUPLES 의 current value)                                                                            
		        COALESCE(SUM(B.IDX_TUP_FETCH), 0) - #{agg_idx_fetch_tuples} AS CURRENT_IDX_FETCH_TUPLES, -- @이전값 (AGG_IDX_FETCH_TUPLES의 current value)
   	            COALESCE(SUM(B.n_tup_ins), 0) - #{agg_insert_tuples} AS CURRENT_INSERT_TUPLES,-- insert
	            COALESCE(SUM(B.n_tup_upd), 0) - #{agg_update_tuples} AS CURRENT_UPDATE_TUPLES,-- update
	            COALESCE(SUM(B.n_tup_del), 0) - #{agg_delete_tuples} AS CURRENT_DELETE_TUPLES,-- delete
        		COALESCE(SUM(B.SEQ_SCAN), 0) - #{agg_seq_scan_cnt} AS CURRENT_SEQ_SCAN_CNT,
          		COALESCE(SUM(B.IDX_SCAN), 0) - #{agg_idx_scan_cnt} AS CURRENT_IDX_SCAN_CNT,
	            (SELECT XACT_COMMIT FROM PG_STAT_DATABASE WHERE DATNAME=CURRENT_DATABASE()) - #{agg_commit} as CURRENT_COMMIT,
	            (SELECT XACT_ROLLBACK FROM PG_STAT_DATABASE WHERE DATNAME=CURRENT_DATABASE()) - #{agg_rollback} as CURRENT_ROLLBACK,		        
		        CASE WHEN SUM(A.HEAP_BLKS_HIT)<>0 AND SUM(A.HEAP_BLKS_HIT) > SUM(A.HEAP_BLKS_READ) THEN ROUND((SUM(A.HEAP_BLKS_HIT) - SUM(A.HEAP_BLKS_READ)) / SUM(A.HEAP_BLKS_HIT)*100,2) ELSE 0 END AS BUFFER_HIT_RATIO,
		        --(SELECT ROUND(TOTAL_TIME::NUMERIC/CALLS,5) FROM PG_STAT_STATEMENTS ORDER BY TOTAL_TIME/CALLS DESC LIMIT 1) AS MAX_SQL_ELAPSED_SEC, --NOTICE!! V9.2 : MILLI SEC                                          
		        --(SELECT ROUND(SUM(TOTAL_TIME::NUMERIC)/SUM(CALLS),5) FROM PG_STAT_STATEMENTS) AS AVG_SQL_ELAPSED_SEC, --NOTICE!! V9.2 : MILLI SEC                                                                       
		        NOW() AS COLLECT_DT,
		        EXTRACT(EPOCH FROM NOW()-#{collect_dt})::NUMERIC(10,3) AS DELTA_TIME
		FROM PG_STATIO_USER_TABLES A, PG_STAT_USER_TABLES B WHERE A.RELNAME=B.RELNAME
		]]>
	</select>
	
	<insert id="TB_ACCESS_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_ACCESS_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('ACTV_REG_SEQ'),
			#{db_name},
			#{db_size_kb},
			#{table_cnt},
			#{index_cnt},
			#{agg_heap_blks_read_kb},
			#{agg_heap_blks_hit_kb},
			#{agg_seq_read_tuples},
			#{agg_idx_fetch_tuples},
			#{agg_insert_tuples},
			#{agg_update_tuples},
			#{agg_delete_tuples},
			#{agg_seq_scan_cnt},
			#{agg_idx_scan_cnt},
			#{agg_commit},
			#{agg_rollback},
			#{current_heap_blks_read_kb},
			#{current_heap_blks_hit_kb},
			#{current_seq_read_tuples},
			#{current_idx_fetch_tuples},
			#{current_insert_tuples},
			#{current_update_tuples},
			#{current_delete_tuples},
			#{current_seq_scan_cnt},
			#{current_idx_scan_cnt},			
			#{current_commit},
			#{current_rollback},
			#{buffer_hit_ratio},
			#{collect_dt},
			#{delta_time}
		)
	</insert>
<!-- ********************************************************** -->
<!-- ActvCollect END -->
<!-- ********************************************************** -->



<!-- ********************************************************** -->
<!-- HchkCollect START -->
<!-- ********************************************************** -->
	<select id="HCHK_REG_SEQ_001" parameterType="hashmap" resultType="hashmap">
		SELECT NEXTVAL('HCHK_REG_SEQ');
	</select>
	
	<insert id="TB_HCHK_COLLECT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_HCHK_COLLECT_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('HCHK_REG_SEQ'),
			#{instance_id},
			#{hchk_name},
			#{value},
			#{collect_group},
			#{collect_reg_date},
			#{collect_reg_seq},
			#{reg_time}
		)
	</insert>


	<select id="eXperDBMA_BT_HCHK_BUFFERHITRATIO_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[		
SELECT /* eXperDBMA_BT_HCHK_BUFFERHITRATIO_001 */
         OCM.INSTANCE_ID,
         ROUND(AVG(BUFFER_HIT_RATIO),2) AS BUFFERHITRATIO,
         CASE WHEN SUM(ACS.CURRENT_COMMIT)=0 THEN 0 ELSE ROUND(SUM(ACS.CURRENT_COMMIT) / (SUM(ACS.CURRENT_COMMIT) + SUM(ACS.CURRENT_ROLLBACK)) * 100, 2) END AS COMMITRATIO,
         '1' AS COLLECT_GROUP,
         ACS.REG_DATE AS COLLECT_REG_DATE,
         ACS.ACTV_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         MAX(OCM.REG_TIME) AS REG_TIME
         --'BUFFERHITRATIO,COMMITRATIO' AS ITEM
  FROM TB_ACTV_COLLECT_INFO AS OCM,
          TB_INSTANCE_INFO IST,
          TB_ACCESS_INFO ACS
WHERE ACS.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND ACS.REG_DATE = OCM.REG_DATE
   AND ACS.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND ACS.ACTV_REG_SEQ = OCM.ACTV_REG_SEQ  
   AND IST.INSTANCE_ID = OCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N' 
GROUP BY ACS.REG_DATE,ACS.ACTV_REG_SEQ,OCM.INSTANCE_ID;  
		]]>
	</select>
	
	<select id="eXperDBMA_BT_HCHK_LOCKCNT_001" parameterType="hashmap" resultType="hashmap">
 SELECT /* eXperDBMA_BT_HCHK_LOCKCNT_001 */
         ACM.INSTANCE_ID,
         SUM(1) AS LOCKCNT,
         '2' AS COLLECT_GROUP,
         LCK.REG_DATE AS COLLECT_REG_DATE,
         LCK.ACTV_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         MAX(ACM.REG_TIME) AS REG_TIME 
  FROM TB_ACTV_COLLECT_INFO AS ACM,
          TB_CURRENT_LOCK AS LCK,
          TB_INSTANCE_INFO AS IST
WHERE LCK.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND LCK.REG_DATE = ACM.REG_DATE
   AND LCK.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND LCK.ACTV_REG_SEQ = ACM.ACTV_REG_SEQ  
   AND IST.INSTANCE_ID = ACM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N' 
GROUP BY LCK.REG_DATE,LCK.ACTV_REG_SEQ,ACM.INSTANCE_ID;
	</select>
	
	<select id="eXperDBMA_BT_HCHK_CONNECTION_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
SELECT /* eXperDBMA_BT_HCHK_CONNECTION_001 */
         ACM.INSTANCE_ID,
         ROUND(SUM(CASE WHEN BAK.SQL <> '<IDLE>' THEN 0 ELSE 1 END)::NUMERIC/MAX(IST.MAX_CONN_CNT) * 100, 2) AS ACTIVECONNECTION, 
         SUM(CASE WHEN SQL = '<IDLE> in transaction' THEN 1 ELSE 0 END)  AS TRAXIDLECNT,
         MAX(ELAPSED_TIME) AS LONGRUNSQL,
         '2' AS COLLECT_GROUP,
         BAK.REG_DATE AS COLLECT_REG_DATE,
         BAK.ACTV_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
 FROM TB_ACTV_COLLECT_INFO AS ACM, 
         TB_INSTANCE_INFO AS IST,
         TB_BACKEND_RSC AS BAK
WHERE BAK.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND BAK.REG_DATE = ACM.REG_DATE
   AND BAK.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND BAK.ACTV_REG_SEQ = ACM.ACTV_REG_SEQ  
   AND IST.INSTANCE_ID = ACM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N' 
GROUP BY BAK.REG_DATE,BAK.ACTV_REG_SEQ,ACM.INSTANCE_ID;
		]]>
	</select>
	
	<select id="eXperDBMA_BT_HCHK_CONNECTIONFAIL_001" parameterType="hashmap" resultType="hashmap">
SELECT  /* eXperDBMA_BT_HCHK_CONNECTIONFAIL_001 */
         INSTANCE_ID,
         SUM(CASE WHEN IS_COLLECT_OK='N' THEN 1 ELSE 0 END) AS CONNECTIONFAIL,
         MAX('0') COLLECT_GROUP,
         REG_DATE AS COLLECT_REG_DATE,
         STRING_AGG(REG_SEQ::VARCHAR, ',') AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
 FROM (
         SELECT A.REG_DATE,A.OBJT_REG_SEQ AS REG_SEQ, A.INSTANCE_ID, A.IS_COLLECT_OK
                    FROM TB_OBJT_COLLECT_INFO A,
                            TB_INSTANCE_INFO B
                   WHERE REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') 
                    	AND OBJT_REG_SEQ=(SELECT MAX(X.OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=B.INSTANCE_ID )
                    	AND B.COLLECT_YN='Y'
                    	AND B.DELETE_YN='N'
         UNION ALL
         SELECT A.REG_DATE,A.ACTV_REG_SEQ AS REG_SEQ, A.INSTANCE_ID, A.IS_COLLECT_OK
                    FROM TB_ACTV_COLLECT_INFO A,
                            TB_INSTANCE_INFO B
                   WHERE REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') 
                    	AND ACTV_REG_SEQ=(SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=B.INSTANCE_ID )
                    	AND B.COLLECT_YN='Y'
                    	AND B.DELETE_YN='N'
         UNION ALL
         SELECT A.REG_DATE,A.RSC_REG_SEQ AS REG_SEQ, A.INSTANCE_ID, A.IS_COLLECT_OK
                    FROM TB_RSC_COLLECT_INFO A,
                            TB_INSTANCE_INFO B
                   WHERE REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') 
                    	AND RSC_REG_SEQ=(SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=B.INSTANCE_ID )
                    	AND B.COLLECT_YN='Y'
                    	AND B.DELETE_YN='N') AS T
GROUP BY INSTANCE_ID,REG_DATE,CURRENT_TIME;
	</select>
	
	<select id="eXperDBMA_BT_HCHK_UNUSEDINDEX_001" parameterType="hashmap" resultType="hashmap">
SELECT /* eXperDBMA_BT_HCHK_UNUSEDINDEX_001 */
         OCM.INSTANCE_ID,
         SUM(CASE WHEN AGG_INDEX_SCAN_CNT = 0 THEN 1 ELSE 0 END)  AS UNUSEDINDEX,
         --IDX.AGG_INDEX_SCAN_CNT AS VALUE,
         '1' AS COLLECT_GROUP,
         IDX.REG_DATE AS COLLECT_REG_DATE,
         IDX.OBJT_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
  FROM TB_OBJT_COLLECT_INFO AS OCM,
          TB_INSTANCE_INFO AS IST,
          TB_INDEX_INFO IDX
WHERE IDX.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND IDX.REG_DATE = OCM.REG_DATE
   AND IDX.OBJT_REG_SEQ = (SELECT MAX(X.OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND IDX.OBJT_REG_SEQ = OCM.OBJT_REG_SEQ  
   AND IST.INSTANCE_ID = OCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N' 
GROUP BY IDX.REG_DATE,IDX.OBJT_REG_SEQ,OCM.INSTANCE_ID;
	</select>
	
	<select id="eXperDBMA_BT_HCHK_LASTANALYZE_001" parameterType="hashmap" resultType="hashmap">
SELECT /* eXperDBMA_BT_HCHK_LASTANALYZE_001 */
         OCM.INSTANCE_ID,
         CASE WHEN MIN(LAST_ANALYZE) IS NULL THEN 99999 ELSE DATE_PART('DAY', NOW()-MIN(LAST_ANALYZE)) END AS LASTANALYZE,
         	CASE WHEN MIN(LAST_VACUUM) IS NULL THEN 99999 ELSE DATE_PART('DAY', NOW()-MIN(LAST_VACUUM)) END AS LASTVACUUM,
         '1' AS COLLECT_GROUP,
         TBS.REG_DATE AS COLLECT_REG_DATE,
         TBS.OBJT_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
  FROM TB_OBJT_COLLECT_INFO AS OCM,
         TB_INSTANCE_INFO AS IST,
          TB_TABLE_INFO TBS
WHERE TBS.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND TBS.REG_DATE = OCM.REG_DATE
   AND TBS.OBJT_REG_SEQ = (SELECT MAX(X.OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND TBS.OBJT_REG_SEQ = OCM.OBJT_REG_SEQ  
   AND IST.INSTANCE_ID = OCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N' 
GROUP BY TBS.REG_DATE,TBS.OBJT_REG_SEQ,OCM.INSTANCE_ID;
	</select>
	
	<select id="eXperDBMA_BT_HCHK_DISKUSAGE_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
SELECT /* eXperDBMA_BT_HCHK_DISKUSAGE_001 */
         RCM.INSTANCE_ID,
         MAX(ROUND(100 - (avail_KB / TOTAL_KB * 100), 2)) AS DISKUSAGE,
         '3' AS COLLECT_GROUP,
         DUS.REG_DATE AS COLLECT_REG_DATE,
         DUS.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
  FROM TB_RSC_COLLECT_INFO AS RCM,
          TB_INSTANCE_INFO AS IST,
          TB_DISK_USAGE DUS
WHERE DUS.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND DUS.REG_DATE = RCM.REG_DATE
   AND DUS.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND DUS.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N' 
GROUP BY DUS.REG_DATE,DUS.RSC_REG_SEQ,RCM.INSTANCE_ID;
		]]>
	</select>
	
	<select id="eXperDBMA_BT_HCHK_CPUWAIT_001" parameterType="hashmap" resultType="hashmap">
SELECT /* eXperDBMA_BT_HCHK_CPUWAIT_001 */
         RCM.INSTANCE_ID,
         WAIT_UTIL_RATE AS CPUWAIT,
         '3' AS COLLECT_GROUP,
         CPU.REG_DATE AS COLLECT_REG_DATE,
         CPU.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
  FROM TB_RSC_COLLECT_INFO AS RCM,
          TB_INSTANCE_INFO  AS IST,
          TB_CPU_STAT_MASTER CPU
WHERE CPU.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND CPU.REG_DATE = RCM.REG_DATE
   AND CPU.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND CPU.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N';
	</select>
	
	<select id="eXperDBMA_BT_HCHK_SWAPUSAGE_001" parameterType="hashmap" resultType="hashmap">
   SELECT /* eXperDBMA_BT_HCHK_SWAPUSAGE_001 */
         RCM.INSTANCE_ID,
         ROUND((MEM.SWP_USED_KB - MEM.SWP_CACHED_KB) / SWP_TOTAL_KB * 100, 2) AS SWAPUSAGE,
         '3' AS COLLECT_GROUP,
         MEM.REG_DATE AS COLLECT_REG_DATE,
         MEM.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
  FROM TB_RSC_COLLECT_INFO AS RCM,
          TB_INSTANCE_INFO  AS IST,
          TB_MEMORY_STAT MEM
WHERE MEM.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND MEM.REG_DATE = RCM.REG_DATE
   AND MEM.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND MEM.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N';
	</select>
<!-- ********************************************************** -->
<!-- HchkCollect END -->
<!-- ********************************************************** -->



<!-- ********************************************************** -->
<!-- StartCollect START -->
<!-- ********************************************************** -->
	<select id="eXperDBMA_BT_UPTIME_MAXCONN_001" parameterType="hashmap" resultType="hashmap">
		 SELECT /* eXperDBMA_BT_UPTIME_MAXCONN_001 */
		        PG_POSTMASTER_START_TIME() AS INSTANCE_UPTIME, 
		        SETTING AS MAX_CONN_CNT, 
		        GET_CPU_CLOCKS() AS CPU_CLOCKS, 
		        GET_HOSTNAME() AS HOST_NAME 
		  FROM PG_SETTINGS 
		  WHERE NAME='max_connections'
	</select>

	<update id="TB_INSTANCE_INFO_U001" parameterType="hashmap" >
		UPDATE TB_INSTANCE_INFO 
		   SET INSTANCE_UPTIME = #{instance_uptime}, 
			   MAX_CONN_CNT = #{max_conn_cnt},
			   CPU_CLOCKS = #{cpu_clocks},
			   HOST_NAME = #{host_name}  
		 WHERE INSTANCE_ID=#{instance_id}
	</update>
<!-- ********************************************************** -->
<!-- StartCollect END -->
<!-- ********************************************************** -->



<!-- ********************************************************** -->
<!-- DailyBatchTask START -->
<!-- ********************************************************** -->
	<insert id="TB_SYS_LOG_I001" parameterType="hashmap">
		INSERT INTO TB_SYS_LOG (REG_DATE, TASK_CD, START_DT, STATUS)
		VALUES 
		(
			#{reg_date},
			'2',
			NOW(),
			'1'
		);
	</insert>

	<update id="TB_SYS_LOG_U001" parameterType="hashmap">
		UPDATE TB_SYS_LOG 
		   SET STATUS = #{status}, 
			   END_DT = NOW(),
			   COMMENTS = #{comments}
		 WHERE REG_DATE=#{reg_date}
		   AND TASK_CD='2';
	</update>



	<delete id="PGMONBT_BATCH_ACTV_COLLECT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_ACTV_COLLECT_INFO_001 */ FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_CURRENT_LOCK_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_CURRENT_LOCK_001 */ FROM TB_CURRENT_LOCK      WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_BACKEND_RSC_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_BACKEND_RSC_001 */ FROM TB_BACKEND_RSC       WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	
	<delete id="PGMONBT_BATCH_OBJT_COLLECT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_OBJT_COLLECT_INFO_001 */ FROM TB_OBJT_COLLECT_INFO WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_ACCESS_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_ACCESS_INFO_001 */ FROM TB_ACCESS_INFO       WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_TABLESPACE_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_TABLESPACE_INFO_001 */ FROM TB_TABLESPACE_INFO   WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_TABLE_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_TABLE_INFO_001 */ FROM TB_TABLE_INFO        WHERE REG_DATE <= TO_CHAR( NOW()::DATE - 1, 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_TABLE_INFO_001_ORG" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_TABLE_INFO_001 */ FROM TB_TABLE_INFO        WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_INDEX_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_INDEX_INFO_001 */ FROM TB_INDEX_INFO        WHERE REG_DATE <= TO_CHAR( NOW()::DATE - 1, 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_INDEX_INFO_001_ORG" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_INDEX_INFO_001 */ FROM TB_INDEX_INFO        WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	
	<delete id="PGMONBT_BATCH_RSC_COLLECT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_RSC_COLLECT_INFO_001 */ FROM TB_RSC_COLLECT_INFO  WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_MEMORY_STAT_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_MEMORY_STAT_001 */ FROM TB_MEMORY_STAT       WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_CPU_STAT_MASTER_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_CPU_STAT_MASTER_001 */ FROM TB_CPU_STAT_MASTER   WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_CPU_STAT_DETAIL_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_CPU_STAT_DETAIL_001 */ FROM TB_CPU_STAT_DETAIL   WHERE REG_DATE <= TO_CHAR( NOW()::DATE - 1, 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_CPU_STAT_DETAIL_001_ORG" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_CPU_STAT_DETAIL_001 */ FROM TB_CPU_STAT_DETAIL   WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_DISK_IO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_DISK_IO_001 */ FROM TB_DISK_IO           WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_DISK_USAGE_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_DISK_USAGE_001 */ FROM TB_DISK_USAGE        WHERE REG_DATE <= TO_CHAR( NOW()::DATE - 1, 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_DISK_USAGE_001_ORG" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_DISK_USAGE_001 */ FROM TB_DISK_USAGE        WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	
	<delete id="PGMONBT_BATCH_HCHK_COLLECT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_HCHK_COLLECT_INFO_001 */ FROM TB_HCHK_COLLECT_INFO WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_SYS_LOG_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_SYS_LOG_001 */ FROM TB_SYS_LOG WHERE REG_DATE <= TO_CHAR( NOW()::DATE - (SELECT LOG_KEEP_DAYS FROM TB_INSTANCE_INFO LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>



	<update id="VACUUM_ANALYZE_U001" parameterType="hashmap" >
		vacuum analyze TB_INSTANCE_INFO    ;
	</update>
	<update id="VACUUM_ANALYZE_U002" parameterType="hashmap" >	
		vacuum analyze TB_ACTV_COLLECT_INFO;
	</update>
	<update id="VACUUM_ANALYZE_U003" parameterType="hashmap" >		
		vacuum analyze TB_CURRENT_LOCK     ;
	</update>
	<update id="VACUUM_ANALYZE_U006" parameterType="hashmap" >		
		vacuum analyze TB_BACKEND_RSC      ;
	</update>
	<update id="VACUUM_ANALYZE_U007" parameterType="hashmap" >		
		vacuum analyze TB_OBJT_COLLECT_INFO;
	</update>
	<update id="VACUUM_ANALYZE_U008" parameterType="hashmap" >		
		vacuum analyze TB_ACCESS_INFO      ;
	</update>
	<update id="VACUUM_ANALYZE_U009" parameterType="hashmap" >		
		vacuum analyze TB_TABLESPACE_INFO  ;
	</update>
	<update id="VACUUM_ANALYZE_U010" parameterType="hashmap" >		
		vacuum analyze TB_TABLE_INFO       ;
	</update>
	<update id="VACUUM_ANALYZE_U011" parameterType="hashmap" >		
		vacuum analyze TB_INDEX_INFO       ;
	</update>
	<update id="VACUUM_ANALYZE_U012" parameterType="hashmap" >		
		vacuum analyze TB_RSC_COLLECT_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_U013" parameterType="hashmap" >		
		vacuum analyze TB_MEMORY_STAT      ;
	</update>
	<update id="VACUUM_ANALYZE_U014" parameterType="hashmap" >		
		vacuum analyze TB_CPU_STAT_MASTER  ;
	</update>
	<update id="VACUUM_ANALYZE_U015" parameterType="hashmap" >		
		vacuum analyze TB_CPU_STAT_DETAIL  ;
	</update>
	<update id="VACUUM_ANALYZE_U016" parameterType="hashmap" >		
		vacuum analyze TB_DISK_IO          ;
	</update>
	<update id="VACUUM_ANALYZE_U017" parameterType="hashmap" >		
		vacuum analyze TB_DISK_USAGE       ;
	</update>
	<update id="VACUUM_ANALYZE_U018" parameterType="hashmap" >		
		vacuum analyze TB_HCHK_COLLECT_INFO;
	</update>
	<update id="VACUUM_ANALYZE_U019" parameterType="hashmap" >		
		vacuum analyze TB_HCHK_THRD_LIST   ;
	</update>
	<update id="VACUUM_ANALYZE_U020" parameterType="hashmap" >		
		vacuum analyze TB_CONFIG           ;
	</update>
	<update id="VACUUM_ANALYZE_U021" parameterType="hashmap" >		
		vacuum analyze TB_SYS_LOG          ;
	</update>
	
	
	<select id="SEQ_SETVAL_001" parameterType="hashmap" resultType="hashmap">
		select setval('objt_reg_seq',1);
	</select>
	<select id="SEQ_SETVAL_002" parameterType="hashmap" resultType="hashmap">
		select setval('actv_reg_seq',1);
	</select>
	<select id="SEQ_SETVAL_003" parameterType="hashmap" resultType="hashmap">
		select setval('rsc_reg_seq',1);
	</select>
	<select id="SEQ_SETVAL_004" parameterType="hashmap" resultType="hashmap">
		select setval('hchk_reg_seq',1);
	</select>	
<!-- ********************************************************** -->
<!-- DailyBatchTask END -->
<!-- ********************************************************** -->



<!-- ********************************************************** -->
<!-- SocketTask START -->
<!-- ********************************************************** -->
	<select id="DX004_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		SELECT DATID, DATNAME FROM PG_STAT_DATABASE WHERE DATNAME NOT IN ('template0','template1','postgres');
	</select>
	
	<select id="DX004_002" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<![CDATA[
		select nspname from pg_namespace where nspname not like 'pg_%' and nspname<>'information_schema';
		]]>
	</select>
	
	<select id="DX001_001" parameterType="hashmap" resultType="hashmap">
		select INSTANCE_ID, 
		       SERVER_IP, 
		       SERVICE_PORT, 
		       CONN_USER_ID, 
		       convert_from(decode(CONN_USER_PWD,'base64'),'UTF8') as CONN_USER_PWD, 
		       COLLECT_PERIOD_SEC, 
		       CONN_DB_NAME, 
		       LAST_MOD_DT
		  from TB_INSTANCE_INFO
		 where INSTANCE_ID IN 
				<foreach item="item" index="index" collection="list" open="(" separator="," close=")">
					#{item}
				</foreach>
	</select>
	
	<select id="DX005_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<![CDATA[
		${query}
		]]>
	</select>
	
	
<!-- ********************************************************** -->
<!-- SocketTask END -->
<!-- ********************************************************** -->

<!-- ********************************************************** -->
<!-- Maintain partition tables -->
<!-- ********************************************************** -->
	<update id="PG_MAINTAIN_PARTITIONS_001" parameterType="hashmap">
		<![CDATA[
			DO $$
			DECLARE       
			    var_tablename varchar;
			    ddate varchar;
			    cdate varchar;
				dtablename varchar;
 				vrow record;
				vtablename varchar;
			BEGIN    
				var_tablename = '${tablename}';
				ddate = to_char((now()::date - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1))::date, 'YYYYMMDD') ;
			    cdate = to_char((now() + INTERVAL '1 day')::date, 'YYYYMMDD');
			    EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS ' || var_tablename || '_' || cdate || '  PARTITION OF ' || var_tablename || ' FOR VALUES IN (' || cdate || ')');     
			    dtablename = (var_tablename || '_' || ddate);
				FOR vrow IN (SELECT * FROM information_schema.tables WHERE table_schema = current_schema() AND table_name like  var_tablename || '%' AND table_name <> var_tablename and table_name < dtablename) LOOP
					vtablename = vrow.table_name;
				    EXECUTE FORMAT('ALTER TABLE ' || var_tablename || ' DETACH PARTITION ' || vtablename) ;     
				    EXECUTE FORMAT('DROP TABLE IF EXISTS ' || vtablename || ' CASCADE'); 
				END LOOP;
			END $$
		]]>	
	</update>
		<update id="PG_ATTACH_PARTITIONS_002" parameterType="hashmap">
		<![CDATA[
			DO $$
			DECLARE       
			    var_tablename varchar;
			    ndate varchar;
				nhour varchar;
			BEGIN    
				var_tablename = '${tablename}';
			    ndate = to_char(now(), 'YYYYMMDD');
			    FOR i IN 0..23 LOOP
					--RAISE NOTICE '%', concat(ndate, to_char(i, 'fm00'));
					nhour = to_char(i, 'fm00');
			    	EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS ' || var_tablename || '_' || ndate || nhour || '  PARTITION OF ' || var_tablename || ' FOR VALUES IN (' || ndate || nhour || ')');     
			    END LOOP;
			    ndate = to_char(now() + interval '1 day', 'YYYYMMDD');
			    FOR i IN 0..23 LOOP
					--RAISE NOTICE '%', concat(ndate, to_char(i, 'fm00'));
					nhour = to_char(i, 'fm00');
			    	EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS ' || var_tablename || '_' || ndate || nhour || '  PARTITION OF ' || var_tablename || ' FOR VALUES IN (' || ndate || nhour || ')');     
			    END LOOP;
			END $$
		]]>	
	</update>
	
	<update id="PG_DETACH_PARTITIONS_002" parameterType="hashmap">
		<![CDATA[
 			DO $$
			DECLARE       
			    var_tablename varchar;
				var_partition_tablename varchar;
			    ddate varchar;
				_tablename varchar;
			BEGIN    
				var_tablename = '${tablename}';
				var_partition_tablename = NULL;
				ddate = to_char (now(), 'YYYYMMDD');
				--RAISE NOTICE 'tablename: %', var_partition_tablename;
			    FOR var_partition_tablename IN
			       SELECT table_name FROM information_schema.tables WHERE table_schema = current_schema()
									   AND table_name LIKE var_tablename || '_' || '%'
									   AND table_name < var_tablename || '_' || ddate ORDER BY table_name
			    LOOP
					RAISE NOTICE 'tablename: %', var_partition_tablename;
			        EXECUTE FORMAT('ALTER TABLE ' || var_tablename || ' DETACH PARTITION ' || var_partition_tablename) ;     
				    EXECUTE FORMAT('DROP TABLE IF EXISTS ' || var_partition_tablename || ' CASCADE');
			    END LOOP;
 			END $$
		]]>	
	</update>
	<update id="PG_CONSTRAINT_TB_ACTV_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_actv_collect_info${regdate}'
		              )
		    THEN
		        ALTER TABLE ONLY tb_actv_collect_info${regdate} ADD CONSTRAINT pk_tb_actv_collect_info${regdate} PRIMARY KEY (reg_date,actv_reg_seq);
		    END IF;
		EXCEPTION   
		WHEN others THEN    
			BEGIN
	 			delete from tb_actv_collect_info${regdate};
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_actv_collect_info${regdate} ADD CONSTRAINT pk_tb_actv_collect_info${regdate} PRIMARY KEY (reg_date,actv_reg_seq);
			EXCEPTION   
			WHEN others THEN    
			END;    
		END$$; 
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_ACCESS_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_access_info${regdate}'
		              )
		    THEN
		        ALTER TABLE ONLY tb_access_info${regdate} ADD CONSTRAINT pk_tb_access_info${regdate} PRIMARY KEY (reg_date,actv_reg_seq,db_name);		
		    END IF;
		EXCEPTION   
		WHEN others THEN    
			BEGIN
	 			delete from tb_access_info${regdate};
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
		        ALTER TABLE ONLY tb_access_info${regdate} ADD CONSTRAINT pk_tb_access_info${regdate} PRIMARY KEY (reg_date,actv_reg_seq,db_name);		
			EXCEPTION   
			WHEN others THEN    
			END; 
		END$$; 
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_BACKEND_RSC_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_backend_rsc${regdate}'
		              )
		    THEN
		        ALTER TABLE ONLY tb_backend_rsc${regdate} ADD CONSTRAINT pk_tb_backend_rsc${regdate} PRIMARY KEY (reg_date,actv_reg_seq,process_id);		
		    END IF;
		EXCEPTION   
		WHEN others THEN    
			BEGIN
	 			delete from tb_backend_rsc${regdate};
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
		        ALTER TABLE ONLY tb_backend_rsc${regdate} ADD CONSTRAINT pk_tb_backend_rsc${regdate} PRIMARY KEY (reg_date,actv_reg_seq,process_id);		
			EXCEPTION   
			WHEN others THEN    
			END; 
		END$$; 
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_CPU_STAT_DETAIL_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_cpu_stat_detail${regdate}'
		              )
		    THEN
		        ALTER TABLE ONLY tb_cpu_stat_detail${regdate} ADD CONSTRAINT pk_tb_cpu_stat_detail${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,cpu_logical_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN    
			BEGIN
	 			delete from tb_cpu_stat_detail${regdate};
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
		        ALTER TABLE ONLY tb_cpu_stat_detail${regdate} ADD CONSTRAINT pk_tb_cpu_stat_detail${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,cpu_logical_id);
			EXCEPTION   
			WHEN others THEN    
			END;     
		END$$; 
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_CPU_STAT_MASTER_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_cpu_stat_master${regdate}'
		              )
		    THEN
		        ALTER TABLE ONLY tb_cpu_stat_master${regdate} ADD CONSTRAINT pk_tb_cpu_stat_master${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);		
		    END IF;
		EXCEPTION   
		WHEN others THEN    
			BEGIN
	 			delete from tb_cpu_stat_master${regdate};
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
		        ALTER TABLE ONLY tb_cpu_stat_master${regdate} ADD CONSTRAINT pk_tb_cpu_stat_master${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);		
			EXCEPTION   
			WHEN others THEN    
			END;     
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_DISK_IO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_disk_io${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_disk_io${regdate} ADD CONSTRAINT pk_tb_disk_io${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,disk_name);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_disk_io${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_disk_io${regdate} ADD CONSTRAINT pk_tb_disk_io${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,disk_name);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_DISK_USAGE_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_disk_usage${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_disk_usage${regdate}	ADD CONSTRAINT pk_tb_disk_usage${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,mount_point_dir);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_disk_usage${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_disk_usage${regdate}	ADD CONSTRAINT pk_tb_disk_usage${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,mount_point_dir);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_HCHK_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_hchk_collect_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_hchk_collect_info${regdate} ADD CONSTRAINT pk_tb_hchk_collect_info${regdate} PRIMARY KEY (reg_date,hchk_reg_seq,instance_id,hchk_name);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_hchk_collect_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_hchk_collect_info${regdate} ADD CONSTRAINT pk_tb_hchk_collect_info${regdate} PRIMARY KEY (reg_date,hchk_reg_seq,instance_id,hchk_name);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_REPLICATION_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_replication_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_replication_info${regdate} ADD CONSTRAINT pk_tb_replication_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_replication_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_replication_info${regdate} ADD CONSTRAINT pk_tb_replication_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_REPLICATION_LAG_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_replication_lag_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_replication_lag_info${regdate} ADD CONSTRAINT pk_tb_replication_lag_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id, repl_instance_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_replication_lag_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_replication_lag_info${regdate} ADD CONSTRAINT pk_tb_replication_lag_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id, repl_instance_id);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_CHECKPOINT_INFO_001" parameterType="hashmap">
		<![CDATA[		
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_checkpoint_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_checkpoint_info${regdate} ADD CONSTRAINT pk_tb_checkpoint_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_checkpoint_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_checkpoint_info${regdate} ADD CONSTRAINT pk_tb_checkpoint_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;	
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_MEMORY_STAT_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_memory_stat${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_memory_stat${regdate} ADD CONSTRAINT pk_tb_memory_stat${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_memory_stat${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_memory_stat${regdate} ADD CONSTRAINT pk_tb_memory_stat${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_OBJT_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_objt_collect_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_objt_collect_info${regdate} ADD CONSTRAINT pk_tb_objt_collect_info${regdate} PRIMARY KEY (reg_date,objt_reg_seq);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_objt_collect_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_objt_collect_info${regdate} ADD CONSTRAINT pk_tb_objt_collect_info${regdate} PRIMARY KEY (reg_date,objt_reg_seq);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_RSC_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_rsc_collect_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_rsc_collect_info${regdate}  ADD CONSTRAINT pk_tb_rsc_collect_info${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_rsc_collect_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_rsc_collect_info${regdate}  ADD CONSTRAINT pk_tb_rsc_collect_info${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_TABLE_EXT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_table_ext_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_table_ext_info${regdate} ADD CONSTRAINT pk_tb_table_ext_info${regdate} PRIMARY KEY (reg_date,objt_reg_seq,instance_id,relid);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_table_ext_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_table_ext_info${regdate} ADD CONSTRAINT pk_tb_table_ext_info${regdate} PRIMARY KEY (reg_date,objt_reg_seq,instance_id,relid);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_HCHK_ALERT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_hchk_alert_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_hchk_alert_info${regdate} ADD CONSTRAINT pk_tb_hchk_alert_info${regdate} PRIMARY KEY (reg_date,hchk_reg_seq, instance_id, hchk_name);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_hchk_alert_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_hchk_alert_info${regdate} ADD CONSTRAINT pk_tb_hchk_alert_info${regdate} PRIMARY KEY (reg_date,hchk_reg_seq, instance_id, hchk_name);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_PG_STAT_STATEMENTS_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_pg_stat_statements${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_pg_stat_statements${regdate} ADD CONSTRAINT pk_tb_pg_stat_statements${regdate} PRIMARY KEY (reg_date, collect_dt, instance_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_pg_stat_statements${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_pg_stat_statements${regdate} ADD CONSTRAINT pk_tb_pg_stat_statements${regdate} PRIMARY KEY (reg_date, collect_dt, instance_id);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>

<update id="PG_CONSTRAINT_TB_WAL_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_wal_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_wal_info${regdate} ADD CONSTRAINT pk_tb_wal_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_wal_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_wal_info${regdate} ADD CONSTRAINT pk_tb_wal_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>

<update id="PG_CONSTRAINT_TB_QUARY_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_query_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_query_info${regdate} ADD CONSTRAINT pk_tb_query_info${regdate} PRIMARY KEY (reg_date,instance_id, dbid, userid, queryid);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_query_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_query_info${regdate} ADD CONSTRAINT pk_tb_query_info${regdate} PRIMARY KEY (reg_date,instance_id, dbid, userid, queryid);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;	
		]]>			
</update>
<update id="PG_CREATE_FUNCTION_FOR_INDEX_001" parameterType="hashmap">
		<![CDATA[
		CREATE OR REPLACE FUNCTION to_date_imm(text, text) 
		RETURNS date
		AS 'to_date'
		LANGUAGE internal immutable STRICT
		COST 1;
		]]>	
</update>

<update id="PG_INDEX_TB_ACTV_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_tb_actv_collect_info${regdate} ON tb_actv_collect_info${regdate} USING btree((TO_DATE_IMM(reg_date, 'yyyymmdd') + reg_time), instance_id);
		]]>			
</update>

<update id="PG_INDEX_TB_RSC_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_tb_rsc_collect_info${regdate} ON tb_rsc_collect_info${regdate} USING btree((TO_DATE_IMM(reg_date, 'yyyymmdd') + reg_time), instance_id);
		]]>			
</update>

<update id="PG_INDEX_TB_CURRENT_LOCK_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_current_lock${regdate} ON tb_current_lock${regdate} USING btree (reg_date,actv_reg_seq);
		]]>			
</update>
<update id="PG_INDEX_TB_CURRENT_LOCK_002" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx02_current_lock${regdate} ON tb_current_lock${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_BACKEND_RSC_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_backend_rsc${regdate} ON tb_backend_rsc${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_ACCESS_INFO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_access_info${regdate} ON tb_access_info${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_MEMORY_STAT_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_memory_stat${regdate} ON tb_memory_stat${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_CPU_STAT_MASTER_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_cpu_stat_master${regdate} ON tb_cpu_stat_master${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_DISK_IO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_disk_io${regdate} ON tb_disk_io${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_DISK_USAGE_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_disk_usage${regdate} ON tb_disk_usage${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_TABLE_EXT_INFO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_table_ext_info${regdate} ON tb_table_ext_info${regdate} USING btree (collect_dt DESC);
		]]>			
</update>

<update id="PG_INDEX_TB_REPLICATION_INFO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_replication_info${regdate} ON tb_replication_info${regdate} USING btree (collect_dt DESC);
		]]>			
</update>

<update id="PG_INDEX_TB_REALTIME_STATEMENTS_PARTITIONS_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		DECLARE       
			var_tablename varchar;
			ndate varchar;
			nhour varchar;
		BEGIN    
			var_tablename = 'tb_realtime_statements';
			ndate = to_char(now(), 'YYYYMMDD');
			FOR i IN 0..23 LOOP
				--RAISE NOTICE '%', concat(ndate, to_char(i, 'fm00'));
				nhour = to_char(i, 'fm00');
				EXECUTE FORMAT('CREATE INDEX IF NOT EXISTS idx01_realtime_statements_' || ndate || nhour || ' ON tb_realtime_statements_' || ndate || nhour || ' USING btree (collect_dt DESC)');
		    END LOOP;
			ndate = to_char(now() + interval '1 day', 'YYYYMMDD');
			FOR i IN 0..23 LOOP
				--RAISE NOTICE '%', concat(ndate, to_char(i, 'fm00'));
				nhour = to_char(i, 'fm00');
				EXECUTE FORMAT('CREATE INDEX IF NOT EXISTS idx01_realtime_statements_' || ndate || nhour || ' ON tb_realtime_statements_' || ndate || nhour || ' USING btree (collect_dt DESC)');
		    END LOOP;
		END $$
		]]>			
</update>

<select id="TB_TERMINATE_OTHER_SESSIONS_001" parameterType="hashmap" resultType="hashmap">
	<![CDATA[
		SELECT pg_terminate_backend(pid)
		  FROM pg_stat_activity
		 WHERE pid <> pg_backend_pid()
		   AND datname = current_database()
	]]>			
</select>

<!-- ********************************************************** -->
<!-- Maintain partition tables -->
<!-- ********************************************************** -->

<!-- ********************************************************** -->
<!-- Report												 -->
<!-- ********************************************************** -->
<select id="TB_COLLECT_REPORT_DATA_I001" parameterType="hashmap">
	<![CDATA[
		INSERT INTO TB_RPT_TREND
	    SELECT  TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE,
	    		A.INSTANCE_ID INSTANCE_ID
	          , 301 TREND_TYPE
	          , ''
	          , CASE WHEN MAX(C.USER_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE + C.NICE_UTIL_RATE) > 100 THEN 100.00 ELSE ROUND((MAX(C.USER_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE + C.NICE_UTIL_RATE)),2) END AS MAX
	          , CASE WHEN AVG(C.USER_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE + C.NICE_UTIL_RATE) > 100 THEN 100.00 ELSE ROUND((AVG(C.USER_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE + C.NICE_UTIL_RATE)),2) END AS AVG
          	  , 0
          	  , CURRENT_TIMESTAMP
	        FROM (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N') A
	          , TB_RSC_COLLECT_INFO B
	          , TB_CPU_STAT_MASTER C
	        WHERE B.REG_DATE = C.REG_DATE
	          AND B.REG_DATE in (TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD'), TO_CHAR(CURRENT_TIMESTAMP - INTERVAL '23 hour', 'YYYYMMDD')) -- In case the date changes in the period.
		      AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > (CURRENT_TIMESTAMP- (#{timeperiod} || #{timeunit})::INTERVAL)
	          AND A.INSTANCE_ID = B.INSTANCE_ID
	          AND C.RSC_REG_SEQ = B.RSC_REG_SEQ
	          GROUP BY A.INSTANCE_ID          
		UNION ALL	
	    SELECT  TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE,
	    		A.INSTANCE_ID INSTANCE_ID
	          , 302 TREND_TYPE
	          , ''
	          , ROUND((MAX(C.WAIT_UTIL_RATE)),2) AS MAX
	          , ROUND((AVG(C.WAIT_UTIL_RATE)),2) AS AVG
          	  , 0
          	  , CURRENT_TIMESTAMP
	        FROM (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N') A
	          , TB_RSC_COLLECT_INFO B
	          , TB_CPU_STAT_MASTER C
	        WHERE B.REG_DATE = C.REG_DATE
	          AND B.REG_DATE in (TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD'), TO_CHAR(CURRENT_TIMESTAMP - INTERVAL '23 hour', 'YYYYMMDD')) -- In case the date changes in the period.
		      AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > (CURRENT_TIMESTAMP- (#{timeperiod} || #{timeunit})::INTERVAL)
	          AND A.INSTANCE_ID = B.INSTANCE_ID
	          AND C.RSC_REG_SEQ = B.RSC_REG_SEQ
	          GROUP BY A.INSTANCE_ID
	    UNION ALL
	    SELECT  TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE,
	    		A.INSTANCE_ID INSTANCE_ID
	          , 303 TREND_TYPE
	          , ''
	          , (MAX((C.MEM_TOTAL_KB - (C.MEM_FREE_KB + C.MEM_BUFFERED_KB + C.MEM_CACHED_KB)) / C.MEM_TOTAL_KB ) * 100)::NUMERIC(20,2) AS MEM_USED_RATE
	          , (AVG((C.MEM_TOTAL_KB - (C.MEM_FREE_KB + C.MEM_BUFFERED_KB + C.MEM_CACHED_KB)) / C.MEM_TOTAL_KB ) * 100)::NUMERIC(20,2) AS MEM_USED_RATE
          	  , 0
          	  , CURRENT_TIMESTAMP
	        FROM (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N') A
	          , TB_RSC_COLLECT_INFO B
	          , TB_MEMORY_STAT C
	        WHERE B.REG_DATE = C.REG_DATE
	          AND B.REG_DATE in (TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD'), TO_CHAR(CURRENT_TIMESTAMP - INTERVAL '23 hour', 'YYYYMMDD')) -- In case the date changes in the period.
		      AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > (CURRENT_TIMESTAMP- (#{timeperiod} || #{timeunit})::INTERVAL)
	          AND A.INSTANCE_ID = B.INSTANCE_ID
	          AND C.RSC_REG_SEQ = B.RSC_REG_SEQ
	          GROUP BY A.INSTANCE_ID
	    UNION ALL    -- SWAP
	    SELECT  TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE,
	    		A.INSTANCE_ID INSTANCE_ID
	          , 304 TREND_TYPE
	          , ''
	          , (MAX((C.SWP_TOTAL_KB - (C.SWP_FREE_KB + C.SWP_CACHED_KB)) / (C.SWP_TOTAL_KB+1)) * 100)::NUMERIC(20,2)  AS SWP_USED_RATE
	          , (AVG((C.SWP_TOTAL_KB - (C.SWP_FREE_KB + C.SWP_CACHED_KB)) / (C.SWP_TOTAL_KB+1)) * 100)::NUMERIC(20,2)  AS SWP_USED_RATE
          	  , 0
          	  , CURRENT_TIMESTAMP
	        FROM (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N') A
	          , TB_RSC_COLLECT_INFO B
	          , TB_MEMORY_STAT C
	        WHERE B.REG_DATE = C.REG_DATE
	          AND B.REG_DATE in (TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD'), TO_CHAR(CURRENT_TIMESTAMP - INTERVAL '23 hour', 'YYYYMMDD')) -- In case the date changes in the period.
		      AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > (CURRENT_TIMESTAMP- (#{timeperiod} || #{timeunit})::INTERVAL)
	          AND A.INSTANCE_ID = B.INSTANCE_ID
	          AND C.RSC_REG_SEQ = B.RSC_REG_SEQ
	          GROUP BY A.INSTANCE_ID
	    UNION ALL   -- session
	    SELECT  TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE,
    			S.INSTANCE_ID INSTANCE_ID
          	  , 305 TREND_TYPE
	          , ''
          	  , MAX(S.ACTIVE_SESSIONS)::NUMERIC(20,2) AS MAX
          	  , AVG(S.ACTIVE_SESSIONS)::NUMERIC(20,2) AS AVG
          	  , 0
          	  , CURRENT_TIMESTAMP
          FROM (
	        	  SELECT  TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE, COLLECT_DT,
			    		A.INSTANCE_ID INSTANCE_ID
			          , '305' TREND_TYPE
			          , SUM(CASE WHEN (C.STATE = 'active') THEN 1 ELSE 0 END)::NUMERIC(20,0)  AS ACTIVE_SESSIONS
			        FROM (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N') A
			          , TB_ACTV_COLLECT_INFO B
			          , TB_BACKEND_RSC C
			        WHERE B.REG_DATE = C.REG_DATE
			          AND B.REG_DATE in (TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD'), TO_CHAR(CURRENT_TIMESTAMP - INTERVAL '23 hour', 'YYYYMMDD')) -- In case the date changes in the period.
				      AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > (CURRENT_TIMESTAMP-(#{timeperiod} || #{timeunit})::INTERVAL)
			          AND A.INSTANCE_ID = B.INSTANCE_ID
			          AND C.ACTV_REG_SEQ = B.ACTV_REG_SEQ
			          GROUP BY A.INSTANCE_ID, COLLECT_DT
        	) AS S
          GROUP BY S.INSTANCE_ID 
        UNION ALL -- Logical read, write, physical read, sequence scan, index scan, bufferhitratio, tps
              SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE, INSTANCE_ID
      	  , CASE WHEN TREND_MAX = 'A_R_MAX' THEN 306 
      	  		 WHEN TREND_MAX = 'B_W_MAX' THEN 307
      	  		 WHEN TREND_MAX = 'C_P_MAX' THEN 308
      	  		 WHEN TREND_MAX = 'D_S_MAX' THEN 309
      	  		 WHEN TREND_MAX = 'E_I_MAX' THEN 310
      	  		 WHEN TREND_MAX = 'F_H_MIN' THEN 311
      	  		 WHEN TREND_MAX = 'G_T_MIN' THEN 312
      	  		 WHEN TREND_MAX = 'H_C_MIN' THEN 313
      	  	END AS TREND_TYPE
      	  , ''
      	  , MAX
      	  , AVG
      	  , 0
      	  , CURRENT_TIMESTAMP
      	  --, TREND_MAX
      	  --, TREND_AVG
      	  FROM
      	  (
		      SELECT INSTANCE_ID, 
					UNNEST(ARRAY[A_R_MAX,B_W_MAX,C_P_MAX,D_S_MAX,E_I_MAX,F_H_MIN,G_T_MIN,H_C_MIN]) AS MAX,
					UNNEST(ARRAY[A_R_AVG,B_W_AVG,C_P_AVG,D_S_AVG,E_I_AVG,F_H_AVG,G_T_AVG,H_C_AVG]) AS AVG,
					unnest(array['A_R_MAX','B_W_MAX','C_P_MAX','D_S_MAX','E_I_MAX','F_H_MIN','G_T_MIN','H_C_MIN']) TREND_MAX,
					unnest(array['A_R_AVG','B_W_AVG','C_P_AVG','D_S_AVG','E_I_AVG','F_H_AVG','G_T_AVG','H_C_AVG']) TREND_AVG
		      FROM
		      (
				     SELECT S.INSTANCE_ID INSTANCE_ID
			          	  , MAX(S.READ_TUPLES_PER_SEC)::NUMERIC(20,2) AS A_R_MAX
			          	  , AVG(S.READ_TUPLES_PER_SEC)::NUMERIC(20,2) AS A_R_AVG
			          	  , MAX(S.WRITE_TUPLES_PER_SEC)::NUMERIC(20,2) AS B_W_MAX
			          	  , AVG(S.WRITE_TUPLES_PER_SEC)::NUMERIC(20,2) AS B_W_AVG
			          	  , MAX(S.PHY_READ_PER_SEC)::NUMERIC(20,2) AS C_P_MAX
			          	  , AVG(S.PHY_READ_PER_SEC)::NUMERIC(20,2) AS C_P_AVG
			          	  , MAX(S.SEQ_SCAN_TUPLES_PER_SEC)::NUMERIC(20,2) AS D_S_MAX
			          	  , AVG(S.SEQ_SCAN_TUPLES_PER_SEC)::NUMERIC(20,2) AS D_S_AVG
			          	  , MAX(S.INDEX_SCAN_TUPLES_PER_SEC)::NUMERIC(20,2) AS E_I_MAX
			          	  , AVG(S.INDEX_SCAN_TUPLES_PER_SEC)::NUMERIC(20,2) AS E_I_AVG
			          	  , MIN(S.TPS)::NUMERIC(20,2) AS F_H_MIN
			          	  , AVG(S.TPS)::NUMERIC(20,2) AS F_H_AVG
			          	  , MIN(S.BUFFER_HIT_RATIO)::NUMERIC(20,2) AS G_T_MIN
			          	  , AVG(S.BUFFER_HIT_RATIO)::NUMERIC(20,2) AS G_T_AVG
			          	  , MIN(S.COMMIT_RATIO)::NUMERIC(20,2) AS H_C_MIN
			          	  , AVG(S.COMMIT_RATIO)::NUMERIC(20,2) AS H_C_AVG
			          FROM (			          
				        	  SELECT A.INSTANCE_ID INSTANCE_ID
			            		   , ROUND((SUM(C.CURRENT_SEQ_READ_TUPLES) + SUM(C.CURRENT_IDX_FETCH_TUPLES) - SUM(C.CURRENT_UPDATE_TUPLES) - SUM(C.CURRENT_DELETE_TUPLES)) / (AVG(DELTA_TIME)), 2)::Integer AS READ_TUPLES_PER_SEC
			    	               , ROUND(SUM(C.CURRENT_INSERT_TUPLES+C.CURRENT_UPDATE_TUPLES+C.CURRENT_DELETE_TUPLES)/(AVG(DELTA_TIME)), 2)::Integer AS WRITE_TUPLES_PER_SEC
			    	               , ROUND(SUM(C.CURRENT_PHY_READ)/(AVG(DELTA_TIME)), 2)::Integer AS PHY_READ_PER_SEC
			    	               , ROUND(SUM(C.CURRENT_SEQ_READ_TUPLES)/(AVG(DELTA_TIME)), 2)::Integer AS SEQ_SCAN_TUPLES_PER_SEC
            					   , ROUND(SUM(C.CURRENT_IDX_FETCH_TUPLES)/(AVG(DELTA_TIME)), 2)::Integer AS INDEX_SCAN_TUPLES_PER_SEC
            					   , MIN(C.BUFFER_HIT_RATIO) AS BUFFER_HIT_RATIO
            					   , ROUND(SUM(C.CURRENT_COMMIT)/AVG(DELTA_TIME),2)::NUMERIC AS TPS
            					   --, SUM(CURRENT_COMMIT/(CURRENT_COMMIT+CURRENT_ROLLBACK+1)*100) AS COMMIT_RATIO
            					   , SUM(CASE WHEN (CURRENT_COMMIT+CURRENT_ROLLBACK)=0 THEN 100 ELSE CURRENT_COMMIT/(CURRENT_COMMIT+CURRENT_ROLLBACK)*100 END) AS COMMIT_RATIO
						        FROM (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N') A
						          , TB_ACTV_COLLECT_INFO B
						          , TB_ACCESS_INFO C
						        WHERE B.REG_DATE = C.REG_DATE
						          AND B.REG_DATE in (TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD'), TO_CHAR(CURRENT_TIMESTAMP - INTERVAL '23 hour', 'YYYYMMDD')) -- In case the date changes in the period.
							      AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > (CURRENT_TIMESTAMP-(#{timeperiod} || #{timeunit})::INTERVAL)
						          AND A.INSTANCE_ID = B.INSTANCE_ID
						          AND C.ACTV_REG_SEQ = B.ACTV_REG_SEQ
						          GROUP BY A.INSTANCE_ID, COLLECT_DT						          
			        	) AS S
			        	GROUP BY INSTANCE_ID
		      ) AS T
		      ORDER BY TREND_MAX, INSTANCE_ID
	      ) AS LOGICAL
	      UNION ALL -- maxage
   	    SELECT  TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE,
    		INSTANCE_ID INSTANCE_ID
          , 314 TREND_TYPE
          , db_name
          , MAXAGE
          , 0
      	  , 0
      	  , CURRENT_TIMESTAMP
      	  FROM 
      	  (
	       SELECT A.INSTANCE_ID INSTANCE_ID
		          , db_name
		          , MAX(MAXAGE) MAXAGE
	          	  , row_number() over (PARTITION BY A.INSTANCE_ID ORDER BY MAX(MAXAGE) DESC) AS rank_MAXAGE
	        FROM (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N') A
	          , TB_TABLE_EXT_INFO C
	          ,(	
		          	SELECT instance_id, db_name, max(relid) relid
				        FROM TB_OBJT_COLLECT_INFO O JOIN TB_TABLE_INFO T ON T.reg_date = O.reg_date AND T.objt_reg_seq = O.objt_reg_seq
				       WHERE T.OBJT_REG_SEQ in (SELECT max(OBJT_REG_SEQ) OBJT_REG_SEQ FROM TB_OBJT_COLLECT_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') GROUP BY INSTANCE_ID)
				         AND O.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
				       GROUP BY instance_id, db_name
				       ORDER BY instance_id, db_name
			  ) TTI
	        WHERE C.REG_DATE in (TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD'), TO_CHAR(CURRENT_TIMESTAMP - INTERVAL '23 hour', 'YYYYMMDD')) -- In case the date changes in the period.
		      AND collect_dt > (CURRENT_TIMESTAMP-('10' || #{timeunit})::INTERVAL)
	          AND A.INSTANCE_ID = C.INSTANCE_ID
         	  AND C.RELID = TTI.RELID
	          GROUP BY A.INSTANCE_ID, db_name
	       ) AS MA
	       WHERE RANK_MAXAGE < 2
	      UNION ALL -- lock sessions
	      	    SELECT  TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE,
    			S.INSTANCE_ID INSTANCE_ID
          	  , 315 TREND_TYPE
	          , ''
          	  , MAX(S.LOCK_TOTAL)::NUMERIC(20,0) AS MAX
          	  , AVG(S.LOCK_TOTAL)::NUMERIC(20,0) AS AVG
          	  , 0
          	  , CURRENT_TIMESTAMP
          FROM (
			      SELECT /* SELECTLOCKCURRENT */ 
			         B.INSTANCE_ID,
			         SUM(CASE WHEN C.ACTV_REG_SEQ IS NOT NULL then 1 ELSE 0 END) AS LOCK_TOTAL
			      FROM (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N') A
			           , TB_ACTV_COLLECT_INFO B
			           , TB_CURRENT_LOCK C
			      WHERE B.REG_DATE = C.REG_DATE
					AND B.REG_DATE in (TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD'), TO_CHAR(CURRENT_TIMESTAMP - INTERVAL '23 hour', 'YYYYMMDD')) -- In case the date changes in the period.
			        AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > (CURRENT_TIMESTAMP-(#{timeperiod} || #{timeunit})::INTERVAL)
			        AND A.INSTANCE_ID = B.INSTANCE_ID
			        AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
			      GROUP BY B.INSTANCE_ID, C.COLLECT_DT
        	) AS S
          GROUP BY S.INSTANCE_ID 
	    ORDER BY INSTANCE_ID, TREND_TYPE
          	]]>			
</select>

<select id="TB_COLLECT_REPORT_DATA_I002" parameterType="hashmap">
	<![CDATA[
		INSERT INTO TB_RPT_LIST
		SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE, INSTANCE_ID, 321 AS TREND_TYPE, PGSS AS LIST_DATA, CURRENT_TIMESTAMP AS COLLECT_DT  
		  FROM TB_PG_STAT_STATEMENTS 
		 WHERE COLLECT_DT IN (SELECT MAX(COLLECT_DT) COLLECT_DT FROM TB_PG_STAT_STATEMENTS GROUP BY INSTANCE_ID)
		 ORDER BY INSTANCE_ID
          	]]>			
</select>

<select id="TB_COLLECT_REPORT_DATA_I003" parameterType="hashmap">
	<![CDATA[
	  INSERT INTO TB_RPT_LIST
	  SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE,  INSTANCE_ID, 320 AS trend_type 
      		,json_agg(
	      		json_build_object(
					'DB_NAME'         ,DB_NAME          
					,'BLOCKING_USER'   ,BLOCKING_USER    
					,'BLOCKING_PID'    ,BLOCKING_PID 
					,'BLOCKING'		   ,BLOCKING
					,'BLOCKED_USER'    ,BLOCKED_USER     
					,'BLOCKED_PID'     ,BLOCKED_PID      
					,'LOCK_MODE'       ,LOCK_MODE        
					,'QUERYID'  	   ,QUERYID   
					,'DURATION'		   ,DURATION 
					,'XACT_START'      ,XACT_START       
					,'ORDER_NO'        ,ORDER_NO   
				)
			),
			CURRENT_TIMESTAMP COLLECT_DT
		FROM                    
        (        
	        SELECT A.INSTANCE_ID
				   ,DB_NAME          
				   ,BLOCKING_USER    
				   ,BLOCKING_PID
				   ,CASE WHEN blocked_query IS NULL THEN TRUE ELSE FALSE END BLOCKING
				   ,BLOCKED_USER     
				   ,BLOCKED_PID      
				   ,RTRIM(LOCK_MODE, 'Lock') LOCK_MODE      
				   ,CASE WHEN blocked_query IS NULL THEN LEFT(BLOCKING_QUERY, 10) ELSE LEFT(BLOCKED_QUERY,10) END QUERYID
				   ,ROUND(extract ('epoch' from BLOCKED_DURATION)::NUMERIC,1) duration
				   ,XACT_START     
				   ,ORDER_NO
	        FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B, TB_CURRENT_LOCK C
	        WHERE B.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
	          --AND B.ACTV_REG_SEQ = (SELECT MAX(ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND INSTANCE_ID = A.INSTANCE_ID  )
	          AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > (CURRENT_TIMESTAMP-(#{timeperiod} || #{timeunit})::INTERVAL)
	          AND A.INSTANCE_ID = B.INSTANCE_ID
	          AND B.REG_DATE = C.REG_DATE
	          AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
	          AND A.COLLECT_YN = 'Y'
	          AND A.DELETE_YN = 'N'
	       ORDER BY ORDER_NO	       
       ) AS LOCKLIST
       GROUP BY INSTANCE_ID
       ORDER BY INSTANCE_ID
          	]]>			
</select>

<delete id="PG_MAINTAIN_TRENDLOG_D001" parameterType="hashmap">
		<![CDATA[
		DELETE /* PG_MAINTAIN_TRENDLOG_001 */  
		  FROM TB_RPT_TREND
		 WHERE REG_DATE < (SELECT TO_CHAR((SELECT MAX(REG_DATE)::DATE FROM TB_RPT_TREND)-(TREPORT_KEEP_DAYS), 'YYYYMMDD') KEEP_DAYS FROM TB_CONFIG)
		]]>			
</delete>

<delete id="PG_MAINTAIN_TRENDLOG_D002" parameterType="hashmap">
		<![CDATA[
		DELETE /* PG_MAINTAIN_TRENDLOG_002 */  
		  FROM TB_RPT_LIST
		 WHERE REG_DATE < (SELECT TO_CHAR((SELECT MAX(REG_DATE)::DATE FROM TB_RPT_LIST)-(TREPORT_KEEP_DAYS), 'YYYYMMDD') KEEP_DAYS FROM TB_CONFIG)
		]]>			
</delete>

<update id="VACUUM_ANALYZE_TRENDLOG_U001" parameterType="hashmap" >
	vacuum analyze TB_INSTANCE_INFO    ;
</update>

<update id="VACUUM_ANALYZE_TRENDLOG_U002" parameterType="hashmap" >
	vacuum analyze TB_INSTANCE_INFO    ;
</update>

<!-- ********************************************************** -->
<!-- Report												 -->
<!-- ********************************************************** -->




</mapper>