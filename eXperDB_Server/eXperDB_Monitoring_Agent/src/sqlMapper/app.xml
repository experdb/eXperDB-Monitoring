<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="app">

<!-- ********************************************************** -->
<!-- RscCollect START -->
<!-- ********************************************************** -->
	<select id="TB_RSC_COLLECT_INFO_S001" parameterType="hashmap" resultType="hashmap">
		select max(reg_date) as max_reg_date, TO_CHAR(NOW(), 'YYYYMMDD') as reg_date from tb_rsc_collect_info;
	</select>

	<select id="SEQ_SETVAL_RSC" parameterType="hashmap" resultType="hashmap">
		select setval('rsc_reg_seq',1);
	</select>

	<insert id="TB_RSC_COLLECT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_RSC_COLLECT_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			NEXTVAL('RSC_REG_SEQ'),
			#{instance_id},
			#{is_collect_ok},
			#{failed_collect_type},
			NOW()
		)
	</insert>	



	<select id="BT_MEMORY_STAT_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_MEMORY_STAT_001 24e9ab7301ff1966da4fb30dc1538882 */
		          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
		          --? AS RSC_REG_SEQ, -- @NEXTVAL('RSC_REG_SEQ'),
		          MEM_TOTAL_KB AS MEM_TOTAL_KB,
		          MEM_USED_KB AS MEM_USED_KB,
		          MEM_FREE_KB AS MEM_FREE_KB,
		          MEM_BUFFER_KB AS MEM_BUFFERED_KB,
		          MEM_CACHED_KB AS MEM_CACHED_KB,
		          SWP_TOTAL_KB AS SWP_TOTAL_KB,
		          SWP_USED_KB AS SWP_USED_KB,
		          SWP_CACHED_KB AS SWP_CACHED_KB,
		          SWP_FREE_KB AS SWP_FREE_KB,
		          SHM_KB AS SHM_KB,
		          0 AS PGSQL_USAGE_KB,
		          NOW() AS COLLECT_DT
		  FROM GET_STAT_MEM()
	</select>	

	<insert id="TB_MEMORY_STAT_I001" parameterType="hashmap" >
		INSERT INTO TB_MEMORY_STAT	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('RSC_REG_SEQ'),
			#{mem_total_kb},
			#{mem_used_kb},
			#{mem_free_kb},
			#{mem_buffered_kb},
			#{mem_cached_kb},
			#{swp_total_kb},
			#{swp_used_kb},
			#{swp_cached_kb},
			#{swp_free_kb},
			#{shm_kb},
			#{pgsql_usage_kb},
			#{collect_dt}
		)
	</insert>



	<select id="BT_CPU_STAT_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		SELECT /* EXPERDBMABT_CPU_STAT_DETAIL_001 24e9ab7301ff1966da4fb30dc1538882 */
		          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
		          --? AS RSC_REG_SEQ, -- @NEXTVAL('RSC_REG_SEQ'),
		          SEQ AS CPU_LOGICAL_ID,
		          AGG_USER_UTIL,
		          AGG_NICE_UTIL,
		          AGG_SYS_UTIL,
		          AGG_IDLE_UTIL,
		          AGG_WAIT_UTIL,
		          NOW() AS COLLECT_DT
		  FROM (SELECT SEQ,
		                    CPU_AGG_USER AS AGG_USER_UTIL,
		                    CPU_AGG_NICE AS AGG_NICE_UTIL,
		                    CPU_AGG_SYS AS AGG_SYS_UTIL,
		                    CPU_AGG_IDLE AS AGG_IDLE_UTIL,
		                    CPU_AGG_WAIT AS AGG_WAIT_UTIL
		            FROM GET_STAT_CPU_CORES()) AS A
	</select>

	<insert id="TB_CPU_STAT_MASTER_I001" parameterType="hashmap" >
		INSERT INTO TB_CPU_STAT_MASTER
		VALUES
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('RSC_REG_SEQ'),
			#{agg_user_util},
			#{agg_nice_util},
			#{agg_sys_util},
			#{agg_idle_util},
			#{agg_wait_util},
			#{current_user_util},
			#{current_nice_util},
			#{current_sys_util},
			#{current_idle_util},
			#{current_wait_util},
			#{user_util_rate},
			#{nice_util_rate},
			#{sys_util_rate},
			#{idle_util_rate},
			#{wait_util_rate},
			#{dt_now}
		)
	</insert>	

	<insert id="TB_CPU_STAT_DETAIL_I001" parameterType="hashmap" >
		INSERT INTO TB_CPU_STAT_DETAIL
		VALUES
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('RSC_REG_SEQ'),
			#{cpu_logical_id},
			#{agg_user_util},
			#{agg_nice_util},
			#{agg_sys_util},
			#{agg_idle_util},
			#{agg_wait_util},
			#{current_user_util},
			#{current_nice_util},
			#{current_sys_util},
			#{current_idle_util},
			#{current_wait_util},
			#{user_util_rate},
			#{nice_util_rate},
			#{sys_util_rate},
			#{idle_util_rate},
			#{wait_util_rate}
		)
	</insert>



	<select id="BT_DISK_IO_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		SELECT /* EXPERDBMABT_DISK_IO_001 24e9ab7301ff1966da4fb30dc1538882 */
				  DISK_NAME
		         ,RD_AGG_SECTORS AS AGG_READ_KB
		         ,WR_AGG_SECTORS AS AGG_WRITE_KB
		         ,IO_AGG_MILLISEC AS AGG_IO_MSEC
		         ,SEC_FROM_EPOCH 
		         ,NOW() AS COLLECT_DT
		         --,MOUNTPOINT
		         ,'' MOUNTPOINT
		         --,EXTRACT(EPOCH FROM DATE_TRUNC('MILLISECONDS', NOW())) * 1000 - EXTRACT(EPOCH FROM DATE_TRUNC('MILLISECONDS', ?::TIMESTAMP)) * 1000)::NUMERIC AS MIL_SEC_DIFF
		   FROM GET_STAT_DISK_IO
	</select>


	<insert id="TB_DISK_IO_I001" parameterType="hashmap" >
		INSERT INTO TB_DISK_IO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('RSC_REG_SEQ'),
			#{disk_name},
			#{agg_read_kb},
			#{current_read_kb},
			#{read_busy_rate},
			#{agg_write_kb},
			#{current_write_kb},
			#{write_busy_rate},
			#{agg_io_msec},
			#{current_io_msec},
			#{collect_dt},
			#{delta_time},
			#{mountpoint}
		)
	</insert>


<!--
	<select id="BT_DISK_USAGE_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_DISK_USAGE_001 24e9ab7301ff1966da4fb30dc1538882 */
		          DEV_NAME AS DEVICE_NAME,
		          TOT_KB AS TOTAL_KB,
		          USED_KB AS USED_KB,
		          AVAIL_KB AS AVAIL_KB,
		          MT_DIR AS MOUNT_POINT_DIR,
		          NOW() AS COLLECT_DT
		  FROM GET_STAT_DISK_USGE();
	</select>
	-->
		<select id="BT_DISK_USAGE_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_DISK_USAGE_001 24e9ab7301ff1966da4fb30dc1538882 */
		          max(DEV_NAME) AS DEVICE_NAME,
		          max(TOT_KB) AS TOTAL_KB,
		          max(USED_KB) AS USED_KB,
		          max(AVAIL_KB) AS AVAIL_KB,
		          MT_DIR AS MOUNT_POINT_DIR,
		          NOW() AS COLLECT_DT
		  FROM GET_STAT_DISK_USGE()
		  WHERE DEV_NAME NOT LIKE '%loop%'
		  AND DEV_NAME NOT LIKE '%rootfs%'
		  AND DEV_NAME NOT LIKE '%/dev/sr%'
		  AND DEV_NAME NOT LIKE '%/dev/scd%'
		  AND DEV_NAME NOT LIKE '%swap%'
		  GROUP BY MT_DIR;
	</select>
	<insert id="TB_DISK_USAGE_I001" parameterType="hashmap" >
		INSERT INTO TB_DISK_USAGE	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('RSC_REG_SEQ'),
			#{device_name},
			#{total_kb},
			#{used_kb},
			#{avail_kb},
			#{mount_point_dir},
			#{collect_dt}
		)
	</insert>	
<!-- ********************************************************** -->
<!-- RscCollect END -->
<!-- ********************************************************** -->
	


<!-- ********************************************************** -->
<!-- ObjtCollect START -->
<!-- ********************************************************** -->
	<select id="TB_OBJT_COLLECT_INFO_S001" parameterType="hashmap" resultType="hashmap">
		select max(reg_date) as max_reg_date, TO_CHAR(NOW(), 'YYYYMMDD') as reg_date from TB_OBJT_COLLECT_INFO;
	</select>

	<select id="SEQ_SETVAL_OBJT" parameterType="hashmap" resultType="hashmap">
		select setval('objt_reg_seq',1);
	</select>
	
	<insert id="TB_OBJT_COLLECT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_OBJT_COLLECT_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			NEXTVAL('OBJT_REG_SEQ'),
			#{instance_id},
			#{is_collect_ok},			
			#{failed_collect_type},
			NOW()
		)
	</insert>


	<select id="BT_TABLESPACE_INFO_001" parameterType="hashmap" resultType="hashmap">
		<choose>
			<when test="instance_db_version.equals('9.0')">
				SELECT /* EXPERDBMABT_TABLESPACE_INFO_001 (9.0) 24e9ab7301ff1966da4fb30dc1538882 */
				          --? AS REG_DATE, --@ TO_CHAR(NOW(), 'YYYYMMDD'),
				          --? AS OBJT_REG_SEQ, --@NEXTVAL('OBJT_REG_SEQ'),
				          SPCNAME AS TABLESPACE_NAME,
				          SPCLOCATION AS LOCATION,
				          PG_TABLESPACE_SIZE(SPCNAME)/1024 AS SIZE_KB,
				          GET_TBSDISK_TOTAL(CASE WHEN SPCNAME='pg_default' THEN CURRENT_SETTING('DATA_DIRECTORY') 
				          			 WHEN SPCNAME='pg_global' THEN CURRENT_SETTING('DATA_DIRECTORY') 
							         ELSE SPCLOCATION END) AS TOTAL_DISK_KB,
				          GET_TBSDISK_AVAIL(CASE WHEN SPCNAME='pg_default' THEN CURRENT_SETTING('DATA_DIRECTORY') 
				          			 WHEN SPCNAME='pg_global' THEN CURRENT_SETTING('DATA_DIRECTORY') 
				          			 ELSE SPCLOCATION END) AS AVAIL_DISK_KB,
				          NULL AS FS_NAME, --예비
				          NULL AS DEVICE_NAME, -- 예비
				          NOW() AS COLLECT_DT
				  FROM PG_TABLESPACE			
			</when>		
			<when test="instance_db_version.equals('9.1')">
				SELECT /* EXPERDBMABT_TABLESPACE_INFO_001 (9.1) 24e9ab7301ff1966da4fb30dc1538882 */
				          --? AS REG_DATE, --@ TO_CHAR(NOW(), 'YYYYMMDD'),
				          --? AS OBJT_REG_SEQ, --@NEXTVAL('OBJT_REG_SEQ'),
				          SPCNAME AS TABLESPACE_NAME,
				          SPCLOCATION AS LOCATION,
				          PG_TABLESPACE_SIZE(SPCNAME)/1024 AS SIZE_KB,
				          GET_TBSDISK_TOTAL(CASE WHEN SPCNAME='pg_default' THEN CURRENT_SETTING('DATA_DIRECTORY') 
				          			 WHEN SPCNAME='pg_global' THEN CURRENT_SETTING('DATA_DIRECTORY') 
							         ELSE SPCLOCATION END) AS TOTAL_DISK_KB,
				          GET_TBSDISK_AVAIL(CASE WHEN SPCNAME='pg_default' THEN CURRENT_SETTING('DATA_DIRECTORY') 
				          			 WHEN SPCNAME='pg_global' THEN CURRENT_SETTING('DATA_DIRECTORY') 
				          			 ELSE SPCLOCATION END) AS AVAIL_DISK_KB,
				          NULL AS FS_NAME, --예비
				          NULL AS DEVICE_NAME, -- 예비
				          NOW() AS COLLECT_DT
				  FROM PG_TABLESPACE			
			</when>
			<when test="instance_db_version >= 9.2">
				SELECT /* EXPERDBMABT_TABLESPACE_INFO_001 (9.2) 24e9ab7301ff1966da4fb30dc1538882 */
				         -- ? AS REG_DATE, --@ TO_CHAR(NOW(), 'YYYYMMDD'),
				         -- ? AS OBJT_REG_SEQ, --@NEXTVAL('OBJT_REG_SEQ'),
				          SPCNAME AS TABLESPACE_NAME,
				          --PG_TABLESPACE_LOCATION(OID) AS LOCATION,
				          CASE WHEN SPCNAME='pg_default' THEN CURRENT_SETTING('DATA_DIRECTORY') 
			       			WHEN SPCNAME='pg_global' THEN CURRENT_SETTING('DATA_DIRECTORY') 
			       			ELSE PG_TABLESPACE_LOCATION(OID) END AS LOCATION,
				          PG_TABLESPACE_SIZE(SPCNAME)/1024 AS SIZE_KB,
				          GET_TBSDISK_TOTAL(CASE WHEN SPCNAME='pg_default' THEN CURRENT_SETTING('DATA_DIRECTORY') 
				          			 WHEN SPCNAME='pg_global' THEN CURRENT_SETTING('DATA_DIRECTORY') 
							         ELSE PG_TABLESPACE_LOCATION(OID) END) AS TOTAL_DISK_KB,
				          GET_TBSDISK_AVAIL(CASE WHEN SPCNAME='pg_default' THEN CURRENT_SETTING('DATA_DIRECTORY') 
				          			 WHEN SPCNAME='pg_global' THEN CURRENT_SETTING('DATA_DIRECTORY') 
				          			 ELSE PG_TABLESPACE_LOCATION(OID) END) AS AVAIL_DISK_KB,
				          NULL AS FS_NAME, --예비
				          NULL AS DEVICE_NAME, -- 예비
				          NOW() AS COLLECT_DT
				  FROM PG_TABLESPACE;
			</when>
			<otherwise>
				SELECT ERROR
			</otherwise>
		</choose>	
	</select>
	
	<insert id="TB_TABLESPACE_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_TABLESPACE_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('OBJT_REG_SEQ'),
			#{tablespace_name},
			#{location},
			#{size_kb},
			#{total_disk_kb},
			#{avail_disk_kb},
			#{fs_name},
			#{device_name},
			#{collect_dt}
		)
	</insert>
	
	<delete id="TB_TABLESPACE_INFO_D001" parameterType="hashmap" >
		<![CDATA[
		/* TB_TABLESPACE_INFO_D001 */
		DELETE  
		FROM 
			TB_TABLESPACE_INFO        
		WHERE 
			REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
			AND OBJT_REG_SEQ < (SELECT MAX(OBJT_REG_SEQ) - (SELECT COUNT(1) FROM TB_INSTANCE_INFO A WHERE A.COLLECT_YN = 'Y' AND DELETE_YN='N') FROM TB_TABLESPACE_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD'))
		]]>	
	</delete>	
	
	<select id="BT_TABLE_INFO_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<![CDATA[
WITH GAVS AS(
	SELECT name, setting::numeric(3,2) FROM pg_settings WHERE name = 'autovacuum_vacuum_scale_factor'
),
GAVT AS(
	SELECT name, setting::numeric(20) FROM pg_settings WHERE name = 'autovacuum_vacuum_threshold'	
),
 GAAS AS(
	SELECT name, setting::numeric(3,2) FROM pg_settings WHERE name = 'autovacuum_analyze_scale_factor'
)
, GAAT AS(
	SELECT name, setting::numeric(20) FROM pg_settings WHERE name = 'autovacuum_analyze_threshold'
)
SELECT /* EXPERDBMABT_TABLE_INFO_001 24e9ab7301ff1966da4fb30dc1538882 */
				schema_name, table_name, bs*tblpages AS table_size_kb,
		 			 tot_index_size_kb, index_cnt,
					 CASE WHEN reltoastrelid=0 THEN 'N' ELSE 'Y' END AS TOAST_YN,
					 agg_seq_scan_cnt,agg_seq_tuples,agg_index_scan_cnt,agg_index_tuples,live_tuple_cnt,dead_tuple_cnt,last_vacuum,last_analyze,
					 now() AS collect_dt,  
					 (tblpages-est_tblpages)*bs AS extra_size,
					 CASE WHEN tblpages =  0 THEN 0
					      WHEN tblpages - est_tblpages > 0
					   		THEN 100 * (tblpages - est_tblpages)/tblpages::float
					   		ELSE 0
					 END AS extra_ratio, 
					 fillfactor, 
					 CASE WHEN (tblpages-est_tblpages_ff) < 0 THEN 0 ELSE (tblpages-est_tblpages_ff)*bs END AS bloat_size_kb,
					 CASE WHEN tblpages =  0 THEN 0
					      WHEN tblpages - est_tblpages_ff > 0
						    THEN 100 * (tblpages - est_tblpages_ff)/tblpages::float
						    ELSE 0
					 END AS bloat_ratio, is_na, relid, autovacuum_count, autoanalyze_count, (SELECT age(datfrozenxid) FROM pg_database WHERE datname = CURRENT_DATABASE()) maxage,
					 CASE WHEN autovacuum = 'on' AND dead_tuple_cnt > ((reltuples) * COALESCE(AVS,(SELECT setting FROM GAVS)) + COALESCE(AVT,(SELECT setting FROM GAVT)))
					 	  THEN TRUE 
					 	  WHEN autovacuum = 'off' AND dead_tuple_cnt > 0
					 	  THEN TRUE
					 	  ELSE FALSE
					 	  END AS need_vacuum,
					 CASE WHEN autovacuum = 'on' AND n_mod_since_analyze > ((reltuples) * COALESCE(AAS,(SELECT setting FROM GAAS)) + COALESCE(AAT,(SELECT setting FROM GAAT)))
					 	  THEN TRUE 
					 	  WHEN autovacuum = 'off' AND dead_tuple_cnt > 0
					 	  THEN TRUE
					 	  ELSE FALSE
					 	  END AS need_analyze,
					 age(relfrozenxid) relage
		 FROM (
				   SELECT ceil( reltuples / ( (bs-page_hdr)/tpl_size ) ) + ceil( toasttuples / 4 ) AS est_tblpages,reltuples,
							    ceil( reltuples / ( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,
							    tblpages, fillfactor, bs, tblid, schema_name, table_name, heappages, toastpages, is_na,
							    reltoastrelid, AGG_SEQ_SCAN_CNT, AGG_SEQ_TUPLES, AGG_INDEX_SCAN_CNT, AGG_INDEX_TUPLES, LIVE_TUPLE_CNT,
							    DEAD_TUPLE_CNT, LAST_VACUUM,LAST_ANALYZE,tot_index_size_kb,index_cnt,relid,autovacuum_count,autoanalyze_count,n_mod_since_analyze,
				 				(SELECT OPT_VAL::NUMERIC(20,2) FROM
				  				      (SELECT  split_part(unnest(reloptions),'=',1) OPT_NM, split_part(unnest(reloptions),'=',2) OPT_VAL) AS RELOPT2
				 				  WHERE OPT_NM = 'autovacuum_vacuum_scale_factor') AVS, 
				 				(SELECT OPT_VAL::NUMERIC(20,2) FROM
				  				      (SELECT  split_part(unnest(reloptions),'=',1) OPT_NM, split_part(unnest(reloptions),'=',2) OPT_VAL) AS RELOPT2
				 				  WHERE OPT_NM = 'autovacuum_vacuum_threshold') AVT, 
				 				(SELECT OPT_VAL::NUMERIC(20,2) FROM
				  				      (SELECT  split_part(unnest(reloptions),'=',1) OPT_NM, split_part(unnest(reloptions),'=',2) OPT_VAL) AS RELOPT2
				 				  WHERE OPT_NM = 'autovacuum_analyze_scale_factor') AAS, 
				 				(SELECT OPT_VAL::NUMERIC(20,2) FROM
				  				      (SELECT  split_part(unnest(reloptions),'=',1) OPT_NM, split_part(unnest(reloptions),'=',2) OPT_VAL) AS RELOPT2
				 				  WHERE OPT_NM = 'autovacuum_analyze_threshold') AAT,
								 (SELECT setting FROM pg_settings WHERE name = 'autovacuum') autovacuum,
								 relfrozenxid
				     FROM (
						       SELECT ( 4 + tpl_hdr_size + tpl_data_size + (2*ma)
									           - CASE WHEN tpl_hdr_size%ma = 0 THEN ma ELSE tpl_hdr_size%ma END
									           - CASE WHEN ceil(tpl_data_size)::int%ma = 0 THEN ma ELSE ceil(tpl_data_size)::int%ma END
									         ) AS tpl_size, bs - page_hdr AS size_per_block, (heappages + toastpages) AS tblpages, heappages,
									         toastpages, reltuples, toasttuples, bs, page_hdr, tblid, s.schemaname as schema_name, tblname as table_name, fillfactor, is_na,
									 	       reltoastrelid 
									            ,utb.seq_scan AS agg_seq_scan_cnt
									            ,utb.seq_tup_read AS agg_seq_tuples
									            ,coalesce(utb.idx_scan, 0) AS agg_index_scan_cnt
									            ,coalesce(utb.idx_tup_fetch, 0) AS agg_index_tuples
									            ,utb.n_live_tup AS live_tuple_cnt
									            ,utb.n_dead_tup AS dead_tuple_cnt
									 	       ,CASE WHEN last_vacuum is null AND last_autovacuum is null then '1000-01-01 00:00:00'::timestamp 
									 	             WHEN last_vacuum is null THEN last_autovacuum 
									 	             WHEN last_autovacuum is null THEN last_vacuum 
									 	             WHEN last_vacuum>last_autovacuum THEN last_vacuum 
									 	             ELSE last_autovacuum END AS last_vacuum
									 	       ,CASE WHEN last_analyze is null AND last_autoanalyze is null THEN '1000-01-01 00:00:00'::timestamp 
									 	             WHEN last_analyze is null THEN last_autoanalyze 
									 	             WHEN last_autoanalyze is null THEN last_analyze 
									 	             WHEN last_analyze>last_autoanalyze THEN last_analyze 
									 	             ELSE last_autoanalyze END AS last_analyze
									 	       ,coalesce(UDX.TOT_IDX_SIZE, 0) tot_index_size_kb 
									 	       ,coalesce(UDX.IDX_CNT, 0) index_cnt
									 	       ,utb.relid
									 	       ,utb.autovacuum_count autovacuum_count
									 	       ,utb.autoanalyze_count autoanalyze_count
									 	       ,utb.n_mod_since_analyze n_mod_since_analyze
									 	       ,reloptions
									 	       ,relfrozenxid
							       FROM (
										         SELECT  tbl.oid AS tblid, ns.nspname AS schemaname, tbl.relname AS tblname, tbl.reltuples,
													           tbl.relpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,
													           coalesce(toast.reltuples, 0) AS toasttuples,
													           coalesce(substring(
													             array_to_string(tbl.reloptions, ' ')
													             FROM 'fillfactor=([0-9]+)')::smallint, 100) AS fillfactor,
													           current_setting('block_size')::numeric AS bs,
													           CASE WHEN version()~'mingw32' OR version()~'64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END AS ma,
													           24 AS page_hdr,
													           --23 + CASE WHEN MAX(coalesce(null_frac,0)) > 0 THEN ( 7 + count(*) ) / 8 ELSE 0::int END
													           --  + CASE WHEN tbl.relhasoids THEN 4 ELSE 0 END AS tpl_hdr_size, -- support PGver12
													           23 + CASE WHEN MAX(coalesce(s.null_frac,0)) > 0 THEN ( 7 + count(s.attname) ) / 8 ELSE 0::int END
           														+ CASE WHEN bool_or(att.attname = 'oid' and att.attnum < 0) THEN 4 ELSE 0 END AS tpl_hdr_size,
													           sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024) ) AS tpl_data_size,
													           bool_or(att.atttypid = 'pg_catalog.name'::regtype)
													                OR count(att.attname) <> count(s.attname) AS is_na,
													           tbl.reltoastrelid AS reltoastrelid,
													           tbl.reloptions,
													           tbl.relfrozenxid
										           FROM pg_attribute AS att
												            JOIN pg_class AS tbl ON att.attrelid = tbl.oid
												            JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace
												            LEFT JOIN pg_stats AS s ON s.schemaname=ns.nspname
												                                    AND s.tablename = tbl.relname 
												                                    AND s.inherited=false 
												                                    AND s.attname=att.attname
												            LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid
										          WHERE att.attnum > 0 AND NOT att.attisdropped
										            AND tbl.relkind = 'r'
										          GROUP BY 1,2,3,4,5,6,7,8,9,10,15,16,17
										          ORDER BY 2,3
				       ) AS s 
				       JOIN PG_STAT_USER_TABLES UTB ON UTB.relname=s.tblname AND UTB.schemaname = s.schemaname
				 	     LEFT OUTER JOIN (
	                     /* modified to get indexes size by rel*/
	                              SELECT   RELNAME,   SCHEMANAME,   COUNT(INDEXRELID) AS IDX_CNT,   SUM(RELATION_SIZE) AS TOT_IDX_SIZE
	                              FROM (
	                                 SELECT X.FILE_SIZE AS RELATION_SIZE, B.SCHEMANAME, B.RELID, INDEXRELID, B.RELNAME
	                                 FROM PG_CLASS C
	                                 JOIN (
	                                    SELECT REGEXP_REPLACE( FILE_NAME, '[^0-9].*', '') AS FILENODE, SUM( ( PG_STAT_FILE( PATH || '/' || FILE_NAME ) ).SIZE ) AS FILE_SIZE
	                                    FROM (
	                                       SELECT PATH || '/' || FILE_NAME AS PATH, PG_LS_DIR( PATH || '/' || FILE_NAME) AS FILE_NAME
	                                       FROM (
	                                          SELECT LOCATION AS PATH, PG_LS_DIR(LOCATION) AS FILE_NAME
	                                          FROM (
												SELECT
												        'pg_tblspc/' || t || '/' ||
												        (SELECT Q FROM PG_LS_DIR('pg_tblspc/' || T) AS Q
												        WHERE 1=1 
												          and (select isdir from PG_STAT_FILE( 'pg_tblspc/' || T || '/' || Q)) = true
												          AND Q LIKE 'PG_' || REGEXP_REPLACE(split_part(CURRENT_SETTING('server_version'), '.', 1), E'^([0-9]+\\.[0-9]+).*$', E'\\1') || '%' 
												        )
												        AS LOCATION
												FROM PG_LS_DIR('pg_tblspc') AS T
	                                             WHERE (PG_STAT_FILE('pg_tblspc/' || T)).ISDIR = 'true'
	                                          UNION SELECT 'base' ) AS DIRS ) AS DB_DIRS
	                                       WHERE FILE_NAME = (SELECT OID::TEXT FROM PG_DATABASE WHERE DATNAME = CURRENT_DATABASE() ) ) AS FILE_LIST
	                                    GROUP BY FILENODE ) AS X ON C.RELFILENODE::TEXT = X.FILENODE
	                                 JOIN PG_STAT_USER_INDEXES B ON C.RELNAME::TEXT = B.INDEXRELNAME ) CC
	                              GROUP BY SCHEMANAME, RELNAME, RELID
	                 /* modified to get indexes size by rel*/
				 		  				 ) AS UDX
				 		  			ON UTB.RELNAME=UDX.RELNAME AND UTB.SCHEMANAME = UDX.SCHEMANAME 
				   ) AS s2
		 ) AS s3
		]]>
	</select>
	<select id="BT_TABLE_INFO_001_OLD" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<![CDATA[
WITH GAVS AS(
	SELECT name, setting::numeric(3,2) FROM pg_settings WHERE name = 'autovacuum_vacuum_scale_factor'
),
GAVT AS(
	SELECT name, setting::numeric(20) FROM pg_settings WHERE name = 'autovacuum_vacuum_threshold'	
),
 GAAS AS(
	SELECT name, setting::numeric(3,2) FROM pg_settings WHERE name = 'autovacuum_analyze_scale_factor'
)
, GAAT AS(
	SELECT name, setting::numeric(20) FROM pg_settings WHERE name = 'autovacuum_analyze_threshold'
)
SELECT /* EXPERDBMABT_TABLE_INFO_001 24e9ab7301ff1966da4fb30dc1538882 */
				schema_name, table_name, bs*tblpages AS table_size_kb,
		 			 tot_index_size_kb, index_cnt,
					 CASE WHEN reltoastrelid=0 THEN 'N' ELSE 'Y' END AS TOAST_YN,
					 agg_seq_scan_cnt,agg_seq_tuples,agg_index_scan_cnt,agg_index_tuples,live_tuple_cnt,dead_tuple_cnt,last_vacuum,last_analyze,
					 now() AS collect_dt,  
					 (tblpages-est_tblpages)*bs AS extra_size,
					 CASE WHEN tblpages - est_tblpages > 0
					   		THEN 100 * (tblpages - est_tblpages)/tblpages::float
					   		ELSE 0
					 END AS extra_ratio, 
					 fillfactor, 
					 CASE WHEN (tblpages-est_tblpages_ff) < 0 THEN 0 ELSE (tblpages-est_tblpages_ff)*bs END AS bloat_size_kb,
					 CASE WHEN tblpages - est_tblpages_ff > 0
						    THEN 100 * (tblpages - est_tblpages_ff)/tblpages::float
						    ELSE 0
					 END AS bloat_ratio, is_na, relid, autovacuum_count, autoanalyze_count, (SELECT age(datfrozenxid) FROM pg_database WHERE datname = CURRENT_DATABASE()) maxage,
					 CASE WHEN autovacuum = 'on' AND dead_tuple_cnt > ((reltuples) * COALESCE(AVS,(SELECT setting FROM GAVS)) + COALESCE(AVT,(SELECT setting FROM GAVT)))
					 	  THEN TRUE 
					 	  WHEN autovacuum = 'off' AND dead_tuple_cnt > 0
					 	  THEN TRUE
					 	  ELSE FALSE
					 	  END AS need_vacuum,
					 CASE WHEN autovacuum = 'on' AND n_mod_since_analyze > ((reltuples) * COALESCE(AAS,(SELECT setting FROM GAAS)) + COALESCE(AAT,(SELECT setting FROM GAAT)))
					 	  THEN TRUE 
					 	  WHEN autovacuum = 'off' AND dead_tuple_cnt > 0
					 	  THEN TRUE
					 	  ELSE FALSE
					 	  END AS need_analyze,
					 age(relfrozenxid) relage
		 FROM (
				   SELECT ceil( reltuples / ( (bs-page_hdr)/tpl_size ) ) + ceil( toasttuples / 4 ) AS est_tblpages,reltuples,
							    ceil( reltuples / ( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,
							    tblpages, fillfactor, bs, tblid, schema_name, table_name, heappages, toastpages, is_na,
							    reltoastrelid, AGG_SEQ_SCAN_CNT, AGG_SEQ_TUPLES, AGG_INDEX_SCAN_CNT, AGG_INDEX_TUPLES, LIVE_TUPLE_CNT,
							    DEAD_TUPLE_CNT, LAST_VACUUM,LAST_ANALYZE,tot_index_size_kb,index_cnt,relid,autovacuum_count,autoanalyze_count,n_mod_since_analyze,
				 				(SELECT OPT_VAL::NUMERIC(20,2) FROM
				  				      (SELECT  split_part(unnest(reloptions),'=',1) OPT_NM, split_part(unnest(reloptions),'=',2) OPT_VAL) AS RELOPT2
				 				  WHERE OPT_NM = 'autovacuum_vacuum_scale_factor') AVS, 
				 				(SELECT OPT_VAL::NUMERIC(20,2) FROM
				  				      (SELECT  split_part(unnest(reloptions),'=',1) OPT_NM, split_part(unnest(reloptions),'=',2) OPT_VAL) AS RELOPT2
				 				  WHERE OPT_NM = 'autovacuum_vacuum_threshold') AVT, 
				 				(SELECT OPT_VAL::NUMERIC(20,2) FROM
				  				      (SELECT  split_part(unnest(reloptions),'=',1) OPT_NM, split_part(unnest(reloptions),'=',2) OPT_VAL) AS RELOPT2
				 				  WHERE OPT_NM = 'autovacuum_analyze_scale_factor') AAS, 
				 				(SELECT OPT_VAL::NUMERIC(20,2) FROM
				  				      (SELECT  split_part(unnest(reloptions),'=',1) OPT_NM, split_part(unnest(reloptions),'=',2) OPT_VAL) AS RELOPT2
				 				  WHERE OPT_NM = 'autovacuum_analyze_threshold') AAT,
								 (SELECT setting FROM pg_settings WHERE name = 'autovacuum') autovacuum,
								 relfrozenxid
				     FROM (
						       SELECT ( 4 + tpl_hdr_size + tpl_data_size + (2*ma)
									           - CASE WHEN tpl_hdr_size%ma = 0 THEN ma ELSE tpl_hdr_size%ma END
									           - CASE WHEN ceil(tpl_data_size)::int%ma = 0 THEN ma ELSE ceil(tpl_data_size)::int%ma END
									         ) AS tpl_size, bs - page_hdr AS size_per_block, (heappages + toastpages) AS tblpages, heappages,
									         toastpages, reltuples, toasttuples, bs, page_hdr, tblid, s.schemaname as schema_name, tblname as table_name, fillfactor, is_na,
									 	       reltoastrelid 
									            ,utb.seq_scan AS agg_seq_scan_cnt
									            ,utb.seq_tup_read AS agg_seq_tuples
									            ,coalesce(utb.idx_scan, 0) AS agg_index_scan_cnt
									            ,coalesce(utb.idx_tup_fetch, 0) AS agg_index_tuples
									            ,utb.n_live_tup AS live_tuple_cnt
									            ,utb.n_dead_tup AS dead_tuple_cnt
									 	       ,CASE WHEN last_vacuum is null AND last_autovacuum is null then '1000-01-01 00:00:00'::timestamp 
									 	             WHEN last_vacuum is null THEN last_autovacuum 
									 	             WHEN last_autovacuum is null THEN last_vacuum 
									 	             WHEN last_vacuum>last_autovacuum THEN last_vacuum 
									 	             ELSE last_autovacuum END AS last_vacuum
									 	       ,CASE WHEN last_analyze is null AND last_autoanalyze is null THEN '1000-01-01 00:00:00'::timestamp 
									 	             WHEN last_analyze is null THEN last_autoanalyze 
									 	             WHEN last_autoanalyze is null THEN last_analyze 
									 	             WHEN last_analyze>last_autoanalyze THEN last_analyze 
									 	             ELSE last_autoanalyze END AS last_analyze
									 	       ,coalesce(UDX.TOT_IDX_SIZE, 0) tot_index_size_kb 
									 	       ,coalesce(UDX.IDX_CNT, 0) index_cnt
									 	       ,utb.relid
									 	       ,utb.autovacuum_count autovacuum_count
									 	       ,utb.autoanalyze_count autoanalyze_count
									 	       ,utb.n_mod_since_analyze n_mod_since_analyze
									 	       ,reloptions
									 	       ,relfrozenxid
							       FROM (
										         SELECT  tbl.oid AS tblid, ns.nspname AS schemaname, tbl.relname AS tblname, tbl.reltuples,
													           tbl.relpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,
													           coalesce(toast.reltuples, 0) AS toasttuples,
													           coalesce(substring(
													             array_to_string(tbl.reloptions, ' ')
													             FROM 'fillfactor=([0-9]+)')::smallint, 100) AS fillfactor,
													           current_setting('block_size')::numeric AS bs,
													           CASE WHEN version()~'mingw32' OR version()~'64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END AS ma,
													           24 AS page_hdr,
													           --23 + CASE WHEN MAX(coalesce(null_frac,0)) > 0 THEN ( 7 + count(*) ) / 8 ELSE 0::int END
													           --  + CASE WHEN tbl.relhasoids THEN 4 ELSE 0 END AS tpl_hdr_size, -- support PGver12
													           23 + CASE WHEN MAX(coalesce(s.null_frac,0)) > 0 THEN ( 7 + count(s.attname) ) / 8 ELSE 0::int END
           														+ CASE WHEN bool_or(att.attname = 'oid' and att.attnum < 0) THEN 4 ELSE 0 END AS tpl_hdr_size,
													           sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024) ) AS tpl_data_size,
													           bool_or(att.atttypid = 'pg_catalog.name'::regtype)
													                OR count(att.attname) <> count(s.attname) AS is_na,
													           tbl.reltoastrelid AS reltoastrelid,
													           tbl.reloptions,
													           tbl.relfrozenxid
										           FROM pg_attribute AS att
												            JOIN pg_class AS tbl ON att.attrelid = tbl.oid
												            JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace
												            LEFT JOIN pg_stats AS s ON s.schemaname=ns.nspname
												                                    AND s.tablename = tbl.relname 
												                                    AND s.inherited=false 
												                                    AND s.attname=att.attname
												            LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid
										          WHERE att.attnum > 0 AND NOT att.attisdropped
										            AND tbl.relkind = 'r'
										          GROUP BY 1,2,3,4,5,6,7,8,9,10,15,16,17
										          ORDER BY 2,3
				       ) AS s 
				       JOIN PG_STAT_USER_TABLES UTB ON UTB.relname=s.tblname AND UTB.schemaname = s.schemaname
				 	     LEFT OUTER JOIN (
										   SELECT relname, SCHEMANAME, sum(pg_relation_size(indexrelid)) AS tot_idx_size, count(indexrelid) AS idx_cnt
										     FROM pg_stat_user_indexes
										    GROUP BY schemaname, relname, relid
				 		  				 ) AS UDX
				 		  			ON utb.relnamE=udx.relname AND utb.schemaname = udx.schemaname 
				   ) AS s2
		 ) AS s3
		]]>
	</select>		
	<insert id="TB_TABLE_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_TABLE_INFO
		(
		    reg_date,
		    objt_reg_seq,
		    db_name,
		    schema_name,
		    table_name,
		    table_size_kb,
			bloat_size_kb,
		    tot_index_size_kb,
		    index_cnt,
		    toast_yn,
		    agg_seq_scan_cnt,
		    agg_seq_tuples,
		    agg_index_scan_cnt,
		    agg_index_tuples,
		    current_seq_scan_cnt,
		    current_seq_tuples,
		    current_index_scan_cnt,
		    current_index_tuples,
		    live_tuple_cnt,
		    dead_tuple_cnt,
		    last_vacuum,
		    last_analyze,
		    need_vacuum,
		    need_analyze,
		    collect_dt,
		    relid,
		    relage
	    )
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('OBJT_REG_SEQ'),
			#{db_name},
			#{schema_name},
			#{table_name},
			#{table_size_kb},
			#{bloat_size_kb},
			#{tot_index_size_kb},
			#{index_cnt},
			#{toast_yn},
			#{agg_seq_scan_cnt},
			#{agg_seq_tuples},
			#{agg_index_scan_cnt},
			#{agg_index_tuples},
			#{current_seq_scan_cnt},
			#{current_seq_tuples},
			#{current_index_scan_cnt},
			#{current_index_tuples},			
			#{live_tuple_cnt},
			#{dead_tuple_cnt},
			#{last_vacuum},
			#{last_analyze},
			#{need_vacuum},
		    #{need_analyze},
			#{collect_dt},		
		    #{relid},
		    #{relage}
		)
	</insert>
	
	<delete id="TB_TABLE_INFO_D001" parameterType="hashmap" >
		<![CDATA[
		/* TB_TABLE_INFO_D001 */
		DELETE  
		FROM 
			TB_TABLE_INFO        
		WHERE 
			REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
			--AND OBJT_REG_SEQ < CURRVAL('OBJT_REG_SEQ') - 1
			AND OBJT_REG_SEQ < (SELECT MAX(OBJT_REG_SEQ) - (SELECT COUNT(1) FROM TB_INSTANCE_INFO A WHERE A.COLLECT_YN = 'Y' AND DELETE_YN='N') FROM TB_TABLE_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD'))
		]]>	
	</delete>

	<insert id="TB_TABLE_EXT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_TABLE_EXT_INFO
		(
		    reg_date,
		    collect_dt,
		    objt_reg_seq,
		    instance_id,
		    relid,
		    autovacuum_count,
		    autoanalyze_count,
		    maxage
	    )
	    SELECT 
			TO_CHAR(NOW(), 'YYYYMMDD'),
			#{collect_dt},		
			CURRVAL('OBJT_REG_SEQ'),
		    #{instance_id},
		    #{relid},
			#{autovacuum_count},
			#{autoanalyze_count},
			#{maxage}
	</insert>
	
	<insert id="TB_TABLE_EXT_INFO_I001_20221214" parameterType="hashmap" >
		INSERT INTO TB_TABLE_EXT_INFO
		(
		    reg_date,
		    collect_dt,
		    objt_reg_seq,
		    instance_id,
		    relid,
		    autovacuum_count,
		    autoanalyze_count,
		    maxage
	    )
	    SELECT 
			TO_CHAR(NOW(), 'YYYYMMDD'),
			#{collect_dt},		
			CURRVAL('OBJT_REG_SEQ'),
		    #{instance_id},
		    #{relid},
			#{autovacuum_count},
			#{autoanalyze_count},
			#{maxage}
		WHERE NOT EXISTS (SELECT 1 
		                    FROM TB_TABLE_EXT_INFO 
		                   WHERE reg_date = TO_CHAR(NOW(), 'YYYYMMDD') 
		                     AND objt_reg_seq = CURRVAL('OBJT_REG_SEQ') 
		                     AND instance_id = #{instance_id} 
		                     AND relid = #{relid})
	</insert>
	<select id="BT_INDEX_INFO_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT /* EXPERDBMABT_INDEX_INFO_001 24e9ab7301ff1966da4fb30dc1538882 */
		      #{db_name} AS DB_NAME, -- @DATNAME
			  SCHEMANAME AS SCHEMA_NAME,
			  INDEXRELNAME AS INDEX_NAME,
			  B.RELNAME AS TABLE_NAME,
			  x.file_size AS INDEX_SIZE_KB,
			  INDISVALID AS INDEX_IS_VALID,
			  (SELECT ARRAY_LENGTH(INDKEY,1) FROM PG_INDEX PDX WHERE PDX.INDEXRELID = B.INDEXRELID) AS COLUMNS_CNT,
			  IDX_SCAN AS AGG_INDEX_SCAN_CNT,
			  IDX_TUP_READ AS AGG_INDEX_SCAN_TUPLES,
			  IDX_TUP_FETCH AS AGG_INDEX_SCAN_FETCH_TUPLES,
			  NOW() AS COLLECT_DT
			FROM PG_CLASS C
			JOIN (
			        SELECT REGEXP_REPLACE( FILE_NAME, '[^0-9].*', '') AS FILENODE, SUM( ( PG_STAT_FILE( PATH || '/' || FILE_NAME ) ).SIZE ) AS FILE_SIZE
			        from (
			                SELECT PATH || '/' || FILE_NAME AS PATH, PG_LS_DIR( PATH || '/' || FILE_NAME) AS FILE_NAME
			                FROM (
			                        SELECT LOCATION AS PATH, PG_LS_DIR(LOCATION) AS FILE_NAME
			                        FROM (
											SELECT
											        'pg_tblspc/' || t || '/' ||
											        (SELECT Q FROM PG_LS_DIR('pg_tblspc/' || T) AS Q
											        WHERE 1=1 
											          and (select isdir from PG_STAT_FILE( 'pg_tblspc/' || T || '/' || Q)) = true
											          AND Q LIKE 'PG_' || REGEXP_REPLACE(split_part(CURRENT_SETTING('server_version'), '.', 1), E'^([0-9]+\\.[0-9]+).*$', E'\\1') || '%' 
											        )
											        AS LOCATION
											FROM PG_LS_DIR('pg_tblspc') AS T
			                                WHERE (PG_STAT_FILE('pg_tblspc/' || T)).ISDIR = 'true'
			                        uNION SELECT 'base' ) AS DIRS ) AS DB_DIRS
			                        WHERE FILE_NAME = (SELECT OID::TEXT FROM PG_DATABASE WHERE DATNAME = CURRENT_DATABASE() ) ) AS FILE_LIST
			                GROUP BY FILENODE ) AS X ON C.RELFILENODE::TEXT = X.FILENODE
			        JOIN PG_STAT_USER_INDEXES B ON C.RELNAME::TEXT = B.INDEXRELNAME
			        JOIN PG_INDEX D ON B.INDEXRELID = D.INDEXRELID
			   WHERE INDEXRELNAME <> 'voting_term_restrict'
			  ORDER BY INDEX_NAME
		]]>	
	</select>
	<select id="BT_INDEX_INFO_001_OLD" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		SELECT /* EXPERDBMABT_INDEX_INFO_001 24e9ab7301ff1966da4fb30dc1538882 */
		          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
		          --? AS OBJT_REG_SEQ, -- @NEXTVAL('OBJT_REG_SEQ'),
		          #{db_name} AS DB_NAME, -- @DATNAME
		          SCHEMANAME AS SCHEMA_NAME,
		          INDEXRELNAME AS INDEX_NAME,
		          RELNAME AS TABLE_NAME,
		          PG_RELATION_SIZE(INDEXRELID) AS INDEX_SIZE_KB,
		          (SELECT ARRAY_LENGTH(INDKEY,1) FROM PG_INDEX PDX WHERE PDX.INDEXRELID = A.INDEXRELID) AS COLUMNS_CNT,
		          IDX_SCAN AS AGG_INDEX_SCAN_CNT,
		          IDX_TUP_READ AS AGG_INDEX_SCAN_TUPLES,
		          IDX_TUP_FETCH AS AGG_INDEX_SCAN_FETCH_TUPLES,
		          NOW() AS COLLECT_DT
		 FROM  PG_STAT_USER_INDEXES A 
		 WHERE INDEXRELNAME <> 'voting_term_restrict'
		]]>	
	</select>
	
	
	<delete id="TB_INDEX_INFO_D001" parameterType="hashmap" >
		<![CDATA[
		/* TB_INDEX_INFO_D001 */
		DELETE  
		FROM 
			TB_INDEX_INFO        
		WHERE 
			REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
			--AND OBJT_REG_SEQ < CURRVAL('OBJT_REG_SEQ') - 1
			AND OBJT_REG_SEQ < (SELECT MAX(OBJT_REG_SEQ) - (SELECT COUNT(1) FROM TB_INSTANCE_INFO A WHERE A.COLLECT_YN = 'Y' AND DELETE_YN='N') FROM TB_INDEX_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD'))
		]]>	
	</delete>
	<insert id="TB_INDEX_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_INDEX_INFO
		(
			reg_date,
			objt_reg_seq,
			db_name,
			schema_name,
			index_name,
			table_name,
			index_size_kb,
			index_is_valid,
			columns_cnt,
			agg_index_scan_cnt,
			agg_index_scan_tuples,
			agg_index_scan_fetch_tuples,
			collect_dt
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('OBJT_REG_SEQ'),
			#{db_name},
			#{schema_name},
			#{index_name},
			#{table_name},
			#{index_size_kb},
			#{index_is_valid},
			#{columns_cnt},
			#{agg_index_scan_cnt},
			#{agg_index_scan_tuples},
			#{agg_index_scan_fetch_tuples},
			#{collect_dt}
		) ON CONFLICT DO NOTHING;
	</insert>	
	<insert id="TB_INDEX_INFO_I001_OLD" parameterType="hashmap" >
		INSERT INTO TB_INDEX_INFO
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('OBJT_REG_SEQ'),
			#{db_name},
			#{schema_name},
			#{index_name},
			#{table_name},
			#{index_size_kb},
			#{columns_cnt},
			#{agg_index_scan_cnt},
			#{agg_index_scan_tuples},
			#{agg_index_scan_fetch_tuples},
			#{collect_dt}
		)
	</insert>	
<!-- ********************************************************** -->
<!-- ObjtCollect END -->
<!-- ********************************************************** -->



<!-- ********************************************************** -->
<!-- ActvCollect START -->
<!-- ********************************************************** -->
	<select id="TB_ACTV_COLLECT_INFO_S001" parameterType="hashmap" resultType="hashmap">
		select max(reg_date) as max_reg_date, TO_CHAR(NOW(), 'YYYYMMDD') as reg_date from TB_ACTV_COLLECT_INFO;
	</select>

	<select id="SEQ_SETVAL_ACTV" parameterType="hashmap" resultType="hashmap">
		select setval('actv_reg_seq',1);
	</select>

	<insert id="TB_ACTV_COLLECT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_ACTV_COLLECT_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			NEXTVAL('ACTV_REG_SEQ'),
			#{instance_id},
			#{is_collect_ok},
			#{failed_collect_type},
			NOW()
		)
	</insert>
	
	
	
	<select id="BT_GET_CPU_CLOCKS_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_GET_CPU_CLOCKS_001 24e9ab7301ff1966da4fb30dc1538882 */
			   GET_CPU_CLOCKS()	
	</select>	

	
	
	<select id="BT_CURR_LOCK_001" parameterType="hashmap" resultType="hashmap">
		<choose>
			<when test="instance_db_version.equals('9.0')">
			<![CDATA[
			WITH TEMP AS ( /* EXPERDBMABT_CURRENT_LOCK_001 (9.0) 24e9ab7301ff1966da4fb30dc1538882 */
			          SELECT DB,
			                   MAX(LOCKING_USER) AS LOCKING_USER,
			                   LOCKING_PID,
			                   LOCKING_QUERY,
			                   MAX(BLOCKED_USER) AS BLOCKED_USER,
			                   BLOCKED_PID,
			                   BLOCKED_QUERY,
			                   MAX(BLOCKED_DURATION) AS BLOCKED_DURATION,
			                   MAX(BLOCKED_MODE) AS BLOCKED_MODE,
			                   MAX(BLOCKING_MODE) AS BLOCKING_MODE,
			                   MAX(BLOCKED_QUERY_START) AS BLOCKED_QUERY_START,
			                   MAX(BLOCKED_XACT_START) AS BLOCKED_XACT_START,
			                   MAX(BLOCKING_QUERY_START) AS BLOCKING_QUERY_START,
			                   MAX(BLOCKING_XACT_START) AS BLOCKING_XACT_START
			           FROM (
			                   SELECT OTHER.PID                  AS LOCKING_PID,
			                          OTHER_STM.CURRENT_QUERY    AS LOCKING_QUERY,
			                          OTHER_STM.DATNAME          AS DB,
			                          OTHER_STM.USENAME          AS LOCKING_USER,
			                          WAITING.LOCKTYPE           AS WAITING_LOCKTYPE,
			                          WAITING.RELATION::REGCLASS AS WAITING_TABLE,
			                          WAITING_STM.CURRENT_QUERY  AS BLOCKED_QUERY,
			                          WAITING.MODE               AS BLOCKED_MODE,
			                          WAITING.PID                AS BLOCKED_PID,
			                          WAITING_STM.USENAME        AS BLOCKED_USER,
			                          WAITING_STM.QUERY_START    AS BLOCKED_QUERY_START,
			                          WAITING_STM.XACT_START     AS BLOCKED_XACT_START, 
			                          OTHER.LOCKTYPE             AS OTHER_LOCKTYPE,
			                          OTHER.RELATION::REGCLASS   AS OTHER_TABLE,
			                          OTHER.MODE                 AS BLOCKING_MODE,
			                          OTHER.GRANTED              AS OTHER_GRANTED,
			                          OTHER_STM.QUERY_START      AS BLOCKING_QUERY_START,
			                          OTHER_STM.XACT_START       AS BLOCKING_XACT_START,
			                          NOW()-WAITING_STM.QUERY_START  AS BLOCKED_DURATION
			                  FROM PG_CATALOG.PG_LOCKS AS WAITING JOIN PG_CATALOG.PG_STAT_ACTIVITY AS WAITING_STM ON ( WAITING_STM.PROCPID = WAITING.PID  )
			                                                                        JOIN PG_CATALOG.PG_LOCKS AS OTHER ON ( ( WAITING.DATABASE = OTHER.DATABASE AND WAITING.RELATION  = OTHER.RELATION  ) OR WAITING.TRANSACTIONID = OTHER.TRANSACTIONID  )
			                                                                        JOIN PG_CATALOG.PG_STAT_ACTIVITY AS OTHER_STM ON ( OTHER_STM.PROCPID = OTHER.PID )
			                WHERE NOT WAITING.GRANTED
			                   AND WAITING.PID <> OTHER.PID ) AS A
			             GROUP BY DB,LOCKING_PID, LOCKING_QUERY, BLOCKED_PID, BLOCKED_QUERY
			             ORDER BY DB,LOCKING_PID , BLOCKED_PID
			)
			SELECT DB AS DB_NAME,
			         LOCKING_USER AS BLOCKING_USER,
			         LOCKING_PID AS LOCKING_PID, 
			         LOCKING_QUERY AS LOCKING_QUERY,
			         BLOCKED_USER AS BLOCKED_USER,
			         BLOCKED_PID AS BLOCKED_PID, 
			         BLOCKED_QUERY AS BLOCKED_QUERY,
			         BLOCKED_DURATION AS BLOCKED_DURATION,
			         LOCK_MODE AS LOCK_MODE,
			         QUERY_START AS QUERY_START,
			         XACT_START AS XACT_START,
			         ROW_NUMBER() OVER (ORDER BY LOCKING_PID, BLOCKED_DURATION DESC NULLS FIRST) AS ORDER_NO,
			         NOW() AS COLLECT_DT
			 FROM (
			         SELECT DB,
			                  LOCKING_USER,
			                  LOCKING_PID, 
			                  LOCKING_QUERY,
			                  BLOCKED_USER,
			                  BLOCKED_PID, 
			                  BLOCKED_QUERY,
			                  BLOCKED_DURATION,
			                  BLOCKED_MODE AS LOCK_MODE,
			                  BLOCKED_QUERY_START AS QUERY_START,
			                  BLOCKED_XACT_START AS XACT_START
			          FROM TEMP 
			         WHERE LOCKING_PID NOT IN (SELECT BLOCKED_PID FROM TEMP)
			         UNION ALL
			         SELECT DB,
			                  LOCKING_USER,
			                  LOCKING_PID, 
			                  LOCKING_QUERY, 
			                  NULL,
			                  NULL, 
			                  NULL, 
			                  NULL,
			                  MAX(BLOCKING_MODE) AS LOCK_MODE,
			                  MAX(BLOCKING_QUERY_START) AS QUERY_START,
			                  MAX(BLOCKING_XACT_START) AS XACT_START
			          FROM TEMP 
			         WHERE LOCKING_PID NOT IN (SELECT BLOCKED_PID FROM TEMP) 
			         GROUP BY DB,LOCKING_USER,LOCKING_PID, LOCKING_QUERY
			) AS A limit 1000;
			]]>
			</when>		
			<when test="instance_db_version.equals('9.1')">
			<![CDATA[
			WITH TEMP AS ( /* EXPERDBMABT_CURRENT_LOCK_001 (9.1) 24e9ab7301ff1966da4fb30dc1538882 */
			          SELECT DB,
			                   MAX(LOCKING_USER) AS LOCKING_USER,
			                   LOCKING_PID,
			                   LOCKING_QUERY,
			                   MAX(BLOCKED_USER) AS BLOCKED_USER,
			                   BLOCKED_PID,
			                   BLOCKED_QUERY,
			                   MAX(BLOCKED_DURATION) AS BLOCKED_DURATION,
			                   MAX(BLOCKED_MODE) AS BLOCKED_MODE,
			                   MAX(BLOCKING_MODE) AS BLOCKING_MODE,
			                   MAX(BLOCKED_QUERY_START) AS BLOCKED_QUERY_START,
			                   MAX(BLOCKED_XACT_START) AS BLOCKED_XACT_START,
			                   MAX(BLOCKING_QUERY_START) AS BLOCKING_QUERY_START,
			                   MAX(BLOCKING_XACT_START) AS BLOCKING_XACT_START
			           FROM (
			                   SELECT OTHER.PID                  AS LOCKING_PID,
			                          OTHER_STM.CURRENT_QUERY    AS LOCKING_QUERY,
			                          OTHER_STM.DATNAME          AS DB,
			                          OTHER_STM.USENAME          AS LOCKING_USER,
			                          WAITING.LOCKTYPE           AS WAITING_LOCKTYPE,
			                          WAITING.RELATION::REGCLASS AS WAITING_TABLE,
			                          WAITING_STM.CURRENT_QUERY  AS BLOCKED_QUERY,
			                          WAITING.MODE               AS BLOCKED_MODE,
			                          WAITING.PID                AS BLOCKED_PID,
			                          WAITING_STM.USENAME        AS BLOCKED_USER,
			                          WAITING_STM.QUERY_START    AS BLOCKED_QUERY_START,
			                          WAITING_STM.XACT_START     AS BLOCKED_XACT_START, 
			                          OTHER.LOCKTYPE             AS OTHER_LOCKTYPE,
			                          OTHER.RELATION::REGCLASS   AS OTHER_TABLE,
			                          OTHER.MODE                 AS BLOCKING_MODE,
			                          OTHER.GRANTED              AS OTHER_GRANTED,
			                          OTHER_STM.QUERY_START      AS BLOCKING_QUERY_START,
			                          OTHER_STM.XACT_START       AS BLOCKING_XACT_START,
			                          NOW()-WAITING_STM.QUERY_START  AS BLOCKED_DURATION
			                  FROM PG_CATALOG.PG_LOCKS AS WAITING JOIN PG_CATALOG.PG_STAT_ACTIVITY AS WAITING_STM ON ( WAITING_STM.PROCPID = WAITING.PID  )
			                                                                        JOIN PG_CATALOG.PG_LOCKS AS OTHER ON ( ( WAITING.DATABASE = OTHER.DATABASE AND WAITING.RELATION  = OTHER.RELATION  ) OR WAITING.TRANSACTIONID = OTHER.TRANSACTIONID  )
			                                                                        JOIN PG_CATALOG.PG_STAT_ACTIVITY AS OTHER_STM ON ( OTHER_STM.PROCPID = OTHER.PID )
			                WHERE NOT WAITING.GRANTED
			                   AND WAITING.PID <> OTHER.PID ) AS A
			             GROUP BY DB,LOCKING_PID, LOCKING_QUERY, BLOCKED_PID, BLOCKED_QUERY
			             ORDER BY DB,LOCKING_PID , BLOCKED_PID
			)
			SELECT DB AS DB_NAME,
			         LOCKING_USER AS BLOCKING_USER,
			         LOCKING_PID AS LOCKING_PID, 
			         LOCKING_QUERY AS LOCKING_QUERY,
			         BLOCKED_USER AS BLOCKED_USER,
			         BLOCKED_PID AS BLOCKED_PID, 
			         BLOCKED_QUERY AS BLOCKED_QUERY,
			         BLOCKED_DURATION AS BLOCKED_DURATION,
			         LOCK_MODE AS LOCK_MODE,
			         QUERY_START AS QUERY_START,
			         XACT_START AS XACT_START,
			         ROW_NUMBER() OVER (ORDER BY LOCKING_PID, BLOCKED_DURATION DESC NULLS FIRST) AS ORDER_NO,
			         NOW() AS COLLECT_DT
			 FROM (
			         SELECT DB,
			                  LOCKING_USER,
			                  LOCKING_PID, 
			                  LOCKING_QUERY,
			                  BLOCKED_USER,
			                  BLOCKED_PID, 
			                  BLOCKED_QUERY,
			                  BLOCKED_DURATION,
			                  BLOCKED_MODE AS LOCK_MODE,
			                  BLOCKED_QUERY_START AS QUERY_START,
			                  BLOCKED_XACT_START AS XACT_START
			          FROM TEMP 
			         WHERE LOCKING_PID NOT IN (SELECT BLOCKED_PID FROM TEMP)
			         UNION ALL
			         SELECT DB,
			                  LOCKING_USER,
			                  LOCKING_PID, 
			                  LOCKING_QUERY, 
			                  NULL,
			                  NULL, 
			                  NULL, 
			                  NULL,
			                  MAX(BLOCKING_MODE) AS LOCK_MODE,
			                  MAX(BLOCKING_QUERY_START) AS QUERY_START,
			                  MAX(BLOCKING_XACT_START) AS XACT_START
			          FROM TEMP 
			         WHERE LOCKING_PID NOT IN (SELECT BLOCKED_PID FROM TEMP) 
			         GROUP BY DB,LOCKING_USER,LOCKING_PID, LOCKING_QUERY
			) AS A limit 1000;
			]]>
			</when>
			<!-- when test="instance_db_version >= 9.2">			
			<![CDATA[
			WITH TEMP AS (   /* EXPERDBMABT_CURRENT_LOCK_001 24e9ab7301ff1966da4fb30dc1538882 */
			             SELECT DB,
			                      MAX(LOCKING_USER) AS LOCKING_USER,
			                      LOCKING_PID, 
			                      LOCKING_QUERY,
			                      MAX(BLOCKED_USER) AS BLOCKED_USER,
			                      BLOCKED_PID, 
			                      BLOCKED_QUERY, 
			                      MAX(BLOCKED_DURATION) AS BLOCKED_DURATION, 
			                      MAX(BLOCKED_MODE) AS BLOCKED_MODE, 
			                      MAX(BLOCKING_MODE) AS BLOCKING_MODE,
			                      MAX(BLOCKED_QUERY_START) AS BLOCKED_QUERY_START,
			                      MAX(BLOCKED_XACT_START) AS BLOCKED_XACT_START,
			                      MAX(BLOCKING_QUERY_START) AS BLOCKING_QUERY_START,
			                      MAX(BLOCKING_XACT_START) AS BLOCKING_XACT_START
			              FROM (
			                     SELECT OTHER.PID                    AS LOCKING_PID,
			                              OTHER_STM.QUERY            AS LOCKING_QUERY,
			                              OTHER_STM.DATNAME          AS DB,
			                              OTHER_STM.USENAME          AS LOCKING_USER,
			                              WAITING.LOCKTYPE           AS WAITING_LOCKTYPE,
			                              WAITING.RELATION::REGCLASS AS WAITING_TABLE,
			                              WAITING_STM.QUERY          AS BLOCKED_QUERY,
			                              WAITING.MODE               AS BLOCKED_MODE,
			                              WAITING.PID                AS BLOCKED_PID,
			                              WAITING_STM.USENAME        AS BLOCKED_USER,
			                              WAITING_STM.QUERY_START    AS BLOCKED_QUERY_START,
			                              WAITING_STM.XACT_START     AS BLOCKED_XACT_START, 
			                              OTHER.LOCKTYPE             AS OTHER_LOCKTYPE,
			                              OTHER.RELATION::REGCLASS   AS OTHER_TABLE,
			                              OTHER.MODE                 AS BLOCKING_MODE,
			                              OTHER.GRANTED              AS OTHER_GRANTED,
			                              OTHER_STM.QUERY_START      AS BLOCKING_QUERY_START,
			                              OTHER_STM.XACT_START       AS BLOCKING_XACT_START,
			                              NOW()-WAITING_STM.QUERY_START  AS BLOCKED_DURATION
			                      FROM PG_CATALOG.PG_LOCKS AS WAITING JOIN PG_CATALOG.PG_STAT_ACTIVITY AS WAITING_STM ON (WAITING_STM.PID = WAITING.PID)
			                                                                            JOIN PG_CATALOG.PG_LOCKS AS OTHER ON (  (WAITING.DATABASE = OTHER.DATABASE AND WAITING.RELATION  = OTHER.RELATION  /*AND WAITING.LOCKTYPE  = OTHER.LOCKTYPE*/) OR WAITING.TRANSACTIONID = OTHER.TRANSACTIONID  )
			                                                                            JOIN PG_CATALOG.PG_STAT_ACTIVITY AS OTHER_STM ON (  OTHER_STM.PID = OTHER.PID )
			                    WHERE NOT WAITING.GRANTED
			                       AND WAITING.PID <> OTHER.PID) AS A
			             GROUP BY DB,LOCKING_PID, LOCKING_QUERY, BLOCKED_PID, BLOCKED_QUERY
			             ORDER BY DB,LOCKING_PID , BLOCKED_PID
			)
			SELECT DB AS DB_NAME,
			          LOCKING_USER AS BLOCKING_USER,
			          LOCKING_PID AS BLOCKING_PID, 
			          LOCKING_QUERY AS BLOCKING_QUERY,
			          BLOCKED_USER AS BLOCKED_USER,
			          BLOCKED_PID AS BLOCKED_PID, 
			          BLOCKED_QUERY AS BLOCKED_QUERY,
			          BLOCKED_DURATION AS BLOCKED_DURATION,
			          LOCK_MODE AS LOCK_MODE, 
			          QUERY_START AS QUERY_START,
			          XACT_START AS XACT_START,
			          ROW_NUMBER() OVER (ORDER BY LOCKING_PID, BLOCKED_DURATION DESC NULLS FIRST) AS ORDER_NO,
			          NOW() AS COLLECT_DT
			  FROM (
			          SELECT DB,
			                   LOCKING_USER,
			                   LOCKING_PID, 
			                   LOCKING_QUERY,
			                   BLOCKED_USER,
			                   BLOCKED_PID, 
			                   BLOCKED_QUERY,
			                   BLOCKED_DURATION,
			                   BLOCKED_MODE AS LOCK_MODE,
			                   BLOCKED_QUERY_START AS QUERY_START,
			                   BLOCKED_XACT_START AS XACT_START
			           FROM TEMP 
			          WHERE LOCKING_PID NOT IN (SELECT BLOCKED_PID FROM TEMP)
			          UNION ALL
			          SELECT DB,
			                   LOCKING_USER,
			                   LOCKING_PID, 
			                   LOCKING_QUERY, 
			                   NULL,
			                   NULL, 
			                   NULL, 
			                   NULL,
			                   MAX(BLOCKING_MODE) AS LOCK_MODE,
			                   MAX(BLOCKING_QUERY_START) AS QUERY_START,
			                   MAX(BLOCKING_XACT_START) AS XACT_START
			           FROM TEMP WHERE LOCKING_PID NOT IN (SELECT BLOCKED_PID FROM TEMP) 
			          GROUP BY DB,LOCKING_USER,LOCKING_PID, LOCKING_QUERY
			) AS A ORDER BY blocked_pid ASC NULLS FIRST limit 1000;
			]]>
			</when-->			
			<when test="instance_db_version >= 9.2">
			<!-- when test="instance_db_version.equals('19.2')"-->
			<![CDATA[
			WITH TEMP AS (   /* EXPERDBMABT_CURRENT_LOCK_001 24e9ab7301ff1966da4fb30dc1538882 */
			                     SELECT   OTHER_STM.DATNAME          AS BLOCKING_DB,
			                     		  OTHER_STM.DATID            AS BLOCKING_DATID,
			                     		  OTHER.PID                  AS BLOCKING_PID,
			                              CASE WHEN PG_ENCODING_TO_CHAR(ENCODING) = 'EUC_KR' 
								               THEN CONVERT_FROM(CONVERT(DECODE(OTHER_STM.QUERY, 'escape'), 'EUC-KR', 'UTF8'), 'UTF8')
								               ELSE OTHER_STM.QUERY
								          END AS BLOCKING_QUERY,
			                              OTHER_STM.USENAME          AS BLOCKING_USER,			                              
			                              OTHER_STM.USESYSID         AS BLOCKING_USESYSID,			                              
			                              OTHER.LOCKTYPE             AS BLOCKING_LOCKTYPE,
			                              OTHER.RELATION::REGCLASS   AS BLOCKING_TABLE,
			                              OTHER.MODE                 AS BLOCKING_MODE,
			                              OTHER.GRANTED              AS BLOCKING_GRANTED,
			                              OTHER_STM.QUERY_START      AS BLOCKING_QUERY_START,
			                              OTHER_STM.XACT_START       AS BLOCKING_XACT_START,
			                              WAITING.PID                AS BLOCKED_PID,
			                              WAITING_STM.DATID          AS BLOCKED_DBID,
			                              CASE WHEN PG_ENCODING_TO_CHAR(ENCODING) = 'EUC_KR' 
								               THEN CONVERT_FROM(CONVERT(DECODE(WAITING_STM.QUERY, 'escape'), 'EUC-KR', 'UTF8'), 'UTF8')
								               ELSE WAITING_STM.QUERY
								          END AS BLOCKED_QUERY,
			                              WAITING_STM.USENAME        AS BLOCKED_USER,
			                              WAITING_STM.USESYSID       AS BLOCKED_USESYSID,
			                              WAITING.LOCKTYPE           AS BLOCKED_LOCKTYPE,
			                              WAITING.RELATION::REGCLASS AS BLOCKED_TABLE,
			                              WAITING.MODE               AS BLOCKED_MODE,
			                              WAITING_STM.QUERY_START    AS BLOCKED_QUERY_START,
			                              WAITING_STM.XACT_START     AS BLOCKED_XACT_START, 
			                              NOW()-WAITING_STM.QUERY_START  AS BLOCKED_DURATION
			                      FROM PG_CATALOG.PG_LOCKS AS WAITING JOIN PG_CATALOG.PG_STAT_ACTIVITY AS WAITING_STM ON (WAITING_STM.PID = WAITING.PID)
			                                                                            JOIN PG_CATALOG.PG_LOCKS AS OTHER ON (  (WAITING.DATABASE = OTHER.DATABASE AND WAITING.RELATION  = OTHER.RELATION AND WAITING.LOCKTYPE  = OTHER.LOCKTYPE) OR WAITING.TRANSACTIONID = OTHER.TRANSACTIONID  )
			                                                                            JOIN PG_CATALOG.PG_STAT_ACTIVITY AS OTHER_STM ON (  OTHER_STM.PID = OTHER.PID )
			                                                                            JOIN pg_database D on D.oid = WAITING_STM.DATID
			                    WHERE NOT WAITING.GRANTED
			                       AND WAITING.PID <> OTHER.PID
			)
			SELECT BLOCKING_DB AS DB_NAME,
			          BLOCKING_USER AS BLOCKING_USER,
			          BLOCKING_DATID AS BLOCKING_DATID,
			          BLOCKING_USESYSID AS BLOCKING_USESYSID,
			          BLOCKING_PID AS BLOCKING_PID, 
			          BLOCKING_QUERY AS BLOCKING_QUERY,
			          MD5(BLOCKING_QUERY) AS BLOCKING_QUERYID,
			          BLOCKED_USER AS BLOCKED_USER,
			          BLOCKED_PID AS BLOCKED_PID, 
			          BLOCKED_QUERY AS BLOCKED_QUERY,
			          MD5(BLOCKED_QUERY) AS BLOCKED_QUERYID,
			          BLOCKED_DURATION AS BLOCKED_DURATION,
			          LOCK_MODE AS LOCK_MODE, 
			          QUERY_START AS QUERY_START,
			          XACT_START AS XACT_START,
			          ROW_NUMBER() OVER (ORDER BY BLOCKING_PID, BLOCKED_DURATION DESC NULLS FIRST) AS ORDER_NO,
			          NOW() AS COLLECT_DT
			  FROM (
			          SELECT BLOCKING_DB,
			                   BLOCKING_DATID,
			                   BLOCKING_USER,
			                   BLOCKING_USESYSID,
			                   BLOCKING_PID, 
			                   BLOCKING_QUERY,
			                   BLOCKED_USER,
			                   BLOCKED_PID, 
			                   BLOCKED_QUERY,
			                   BLOCKED_DURATION,
			                   BLOCKED_MODE AS LOCK_MODE,
			                   BLOCKED_QUERY_START AS QUERY_START,
			                   BLOCKED_XACT_START AS XACT_START
			           FROM TEMP 
			         -- WHERE BLOCKING_PID NOT IN (SELECT BLOCKED_PID FROM TEMP)
			          UNION ALL
			          SELECT BLOCKING_DB,
			                   BLOCKING_DATID,
			                   BLOCKING_USER,
			                   BLOCKING_USESYSID,
			                   BLOCKING_PID, 
			                   BLOCKING_QUERY, 
			                   NULL AS BLOCKED_USER,
			                   NULL AS BLOCKED_PID, 
			                   NULL AS BLOCKED_QUERY, 
			                   NULL AS BLOCKED_DURATION,
			                   --MAX(BLOCKING_MODE) AS LOCK_MODE,
			                   --MAX(BLOCKING_QUERY_START) AS QUERY_START,
			                   --MAX(BLOCKING_XACT_START) AS XACT_START
			                   BLOCKING_MODE AS LOCK_MODE,
			                   BLOCKING_QUERY_START AS QUERY_START,
			                   BLOCKING_XACT_START AS XACT_START
			           FROM TEMP WHERE BLOCKING_PID NOT IN (SELECT BLOCKED_PID FROM TEMP) 
			          --GROUP BY BLOCKING_DB,BLOCKING_USER,BLOCKING_PID, BLOCKING_QUERY
			) AS A ORDER BY blocked_pid ASC NULLS FIRST limit 1000;
			]]>
			</when>
			<otherwise>
				SELECT ERROR
			</otherwise>
		</choose>
	</select>
	
	<insert id="TB_CURRENT_LOCK_I001" parameterType="hashmap" >
		INSERT INTO TB_CURRENT_LOCK	
		(    
			reg_date,
		    actv_reg_seq,
		    db_name,
		    blocking_user,
		    blocking_pid,
		    blocking_query,
		    blocked_user,
		    blocked_pid,
		    blocked_query,
		    blocked_duration,
		    lock_mode,
		    query_start,
		    xact_start,
		    order_no,
		    collect_dt
    	)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('ACTV_REG_SEQ'),
			#{db_name},
			#{blocking_user},
			#{blocking_pid},
			#{blocking_query},
			#{blocked_user},
			#{blocked_pid},
			#{blocked_query},
			#{blocked_duration},
			#{lock_mode},
			#{query_start},
			#{xact_start},
			#{order_no},
			#{collect_dt}
		)
	</insert>
	
	<insert id="TB_CURRENT_LOCK_I002" parameterType="hashmap" >
		INSERT INTO TB_CURRENT_LOCK	
		VALUES 
		<foreach collection="list" item="map" open="" separator="," close="">
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('ACTV_REG_SEQ'),
			#{map.db_name},
			#{map.blocking_user},
			#{map.blocking_pid},
			#{map.blocking_query},
			#{map.blocked_user},
		<choose>
			<when test="map.blocked_pid==0">NULL</when>
			<when test="map.blocked_pid>0">#{map.blocked_pid}</when>
		</choose>,
			#{map.blocked_query},
			#{map.blocked_duration}::interval, 
			#{map.lock_mode},
			#{map.query_start},
			#{map.xact_start},
			#{map.order_no},
			#{map.collect_dt}
		)
		</foreach>;
	</insert>

	<select id="BT_BACKEND_RSC_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<choose>
			<when test="instance_db_version.equals('9.0')">
				<![CDATA[	
				SELECT /* EXPERDBMABT_BACKEND_RSC_001 (9.0) 24e9ab7301ff1966da4fb30dc1538882 */
				          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
				          --? AS ACTV_REG_SEQ, -- @NEXTVAL('ACTV_REG_SEQ'),
				          A.PROC_ID AS PROCESS_ID,
				          B.DATNAME AS DB_NAME,
		          		  HOST(B.CLIENT_ADDR) AS CLIENT_ADDR, -- 2014-04-28 추가
		          		  B.USENAME AS USER_NAME,-- 2014-04-28 추가
		          		  B.APPLICATION_NAME AS APPLICATION_NAME,-- 2014-04-28 추가		          
				          A.CPU_UTIME AS AGG_PROC_UTIME,
				          A.CPU_STIME AS AGG_PROC_STIME,
				          --CPU_UTIME - ? AS CURRENT_PROC_UTIME, --@이전값
				          --CPU_STIME - ? AS CURRENT_PROC_STIME, --@이전값
				          --ROUND( ((CPU_UTIME-?)+(CPU_STIME-?)) / CPU_CLOCKS*(MSEC_FROM_EPOCH-?)/1000 * 100, 2) AS PROC_CPU_UTIL, --@이전값 , --@이전값, --@이전값
				          ---- (CPU_UTIME-?)+(CPU_STIME-?) > CPU_CLOCKS*(MSEC_FROM_EPOCH-?)/1000 이면 CPU_CLOCK 연산
				          A.DISK_READ AS AGG_PROC_READ_KB,
				          A.DISK_WRITE AS AGG_PROC_WRITE_KB,
				          --DISK_READ - ? AS CURRENT_PROC_READ_KB,--@이전값
				          --DISK_WRITE - ? AS CURRENT_PROC_WRITE_KB,--@이전값
				          CASE WHEN B.CURRENT_QUERY='<IDLE>' THEN B.BACKEND_START WHEN B.CURRENT_QUERY='<IDLE> in transaction' THEN b.XACT_START ELSE B.QUERY_START END AS QUERY_START,
				          --CASE WHEN NOW()-B.QUERY_START< INTERVAL '0' THEN -(NOW()-B.QUERY_START) ELSE NOW()-B.QUERY_START END AS ELAPSED_TIME,
				        CASE WHEN B.CURRENT_QUERY LIKE '%IDLE%' THEN EXTRACT(EPOCH FROM NOW()-NOW())::NUMERIC ELSE ROUND(EXTRACT(EPOCH FROM NOW()-QUERY_START)::NUMERIC, 2) END AS ELAPSED_TIME,
				          B.CURRENT_QUERY AS SQL,
				          --CASE WHEN B.CURRENT_QUERY IS NULL THEN 'BACKGROUND PROC' ELSE B.CURRENT_QUERY END AS SQL,
				          CASE WHEN B.CURRENT_QUERY='<IDLE>' THEN 'idle' 
					       WHEN B.CURRENT_QUERY='<IDLE> in transaction' THEN 'idle in transaction' 
					       WHEN B.CURRENT_QUERY='<IDLE> in transaction (aborted)' THEN 'idle in transaction (aborted)' 
					       ELSE 'active' END AS STATE, --add state
				          A.SEC_FROM_EPOCH AS SEC_FROM_EPOCH,
				          NOW() AS COLLECT_DT
				  --FROM GET_BACKEND_RSC A LEFT OUTER JOIN PG_STAT_ACTIVITY B ON A.PROC_ID=B.PROCPID
		  		  FROM GET_BACKEND_RSC A JOIN PG_STAT_ACTIVITY B ON A.PROC_ID=B.PROCPID AND B.CURRENT_QUERY NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
		  		 --WHERE state IN ('active','fastpath function call') AND B.QUERY NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
				]]>
			</when>		
			<when test="instance_db_version.equals('9.1')">
				<![CDATA[	
				SELECT /* EXPERDBMABT_BACKEND_RSC_001 (9.1) 24e9ab7301ff1966da4fb30dc1538882 */
				          --? AS REG_DATE, -- @ TO_CHAR(NOW(), 'YYYYMMDD'),
				          --? AS ACTV_REG_SEQ, -- @NEXTVAL('ACTV_REG_SEQ'),
				          A.PROC_ID AS PROCESS_ID,
				          B.DATNAME AS DB_NAME,
		          		  HOST(B.CLIENT_ADDR) AS CLIENT_ADDR, -- 2014-04-28 추가
		          		  B.USENAME AS USER_NAME,-- 2014-04-28 추가
		          		  B.APPLICATION_NAME AS APPLICATION_NAME,-- 2014-04-28 추가		          
				          A.CPU_UTIME AS AGG_PROC_UTIME,
				          A.CPU_STIME AS AGG_PROC_STIME,
				          --CPU_UTIME - ? AS CURRENT_PROC_UTIME, --@이전값
				          --CPU_STIME - ? AS CURRENT_PROC_STIME, --@이전값
				          --ROUND( ((CPU_UTIME-?)+(CPU_STIME-?)) / CPU_CLOCKS*(MSEC_FROM_EPOCH-?)/1000 * 100, 2) AS PROC_CPU_UTIL, --@이전값 , --@이전값, --@이전값
				          ---- (CPU_UTIME-?)+(CPU_STIME-?) > CPU_CLOCKS*(MSEC_FROM_EPOCH-?)/1000 이면 CPU_CLOCK 연산
				          A.DISK_READ AS AGG_PROC_READ_KB,
				          A.DISK_WRITE AS AGG_PROC_WRITE_KB,
				          --DISK_READ - ? AS CURRENT_PROC_READ_KB,--@이전값
				          --DISK_WRITE - ? AS CURRENT_PROC_WRITE_KB,--@이전값
				          CASE WHEN B.CURRENT_QUERY='<IDLE>' THEN B.BACKEND_START WHEN B.CURRENT_QUERY='<IDLE> in transaction' THEN b.XACT_START ELSE B.QUERY_START END AS QUERY_START,
				          --CASE WHEN NOW()-B.QUERY_START< INTERVAL '0' THEN -(NOW()-B.QUERY_START) ELSE NOW()-B.QUERY_START END AS ELAPSED_TIME,
				        CASE WHEN B.CURRENT_QUERY LIKE '%IDLE%' THEN EXTRACT(EPOCH FROM NOW()-NOW())::NUMERIC ELSE ROUND(EXTRACT(EPOCH FROM NOW()-QUERY_START)::NUMERIC, 2) END AS ELAPSED_TIME,
				          B.CURRENT_QUERY AS SQL,
				          --CASE WHEN B.CURRENT_QUERY IS NULL THEN 'BACKGROUND PROC' ELSE B.CURRENT_QUERY END AS SQL,
				          CASE WHEN B.CURRENT_QUERY='<IDLE>' THEN 'idle' 
					       WHEN B.CURRENT_QUERY='<IDLE> in transaction' THEN 'idle in transaction' 
					       WHEN B.CURRENT_QUERY='<IDLE> in transaction (aborted)' THEN 'idle in transaction (aborted)' 
					       ELSE 'active' END AS STATE, --add state
				          A.SEC_FROM_EPOCH AS SEC_FROM_EPOCH,
				          NOW() AS COLLECT_DT
				  --FROM GET_BACKEND_RSC A LEFT OUTER JOIN PG_STAT_ACTIVITY B ON A.PROC_ID=B.PROCPID AND B.CURRENT_QUERY NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
		  		  FROM GET_BACKEND_RSC A JOIN PG_STAT_ACTIVITY B ON A.PROC_ID=B.PROCPID 
          -- WHERE state NOT IN ('',' ') AND B.QUERY NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
		  		  -- FROM GET_BACKEND_RSC A JOIN PG_STAT_ACTIVITY B ON A.PROC_ID=B.PROCPID AND B.DATNAME <> 'dxmoni'; --DAUM 적용쿼리
				]]>
			</when>
			<!-- when test="instance_db_version >= 9.2 and instance_db_version lt 10.0"-->
			<when test="instance_db_version >= 9.2">
				<![CDATA[
				SELECT /* EXPERDBMABT_BACKEND_RSC_001 (9.2 to 9.6) 24e9ab7301ff1966da4fb30dc1538882 */
				          A.PROC_ID AS PROCESS_ID,
				          B.DATNAME AS DB_NAME,
				          COALESCE(B.DATID, 0) DATID,
				          COALESCE(B.USESYSID, 0) USESYSID,
				          HOST(B.CLIENT_ADDR) AS CLIENT_ADDR,
				          B.USENAME AS USER_NAME,
				          B.APPLICATION_NAME AS APPLICATION_NAME,
				          A.CPU_UTIME AS AGG_PROC_UTIME,
				          A.CPU_STIME AS AGG_PROC_STIME,
				          A.DISK_READ AS AGG_PROC_READ_KB,
				          A.DISK_WRITE AS AGG_PROC_WRITE_KB,
				          CASE WHEN B.STATE='idle' THEN B.BACKEND_START WHEN B.STATE='idle in transaction' THEN b.XACT_START ELSE B.QUERY_START END AS QUERY_START,
				          CASE WHEN B.STATE LIKE 'idle%' THEN 0 WHEN ROUND(EXTRACT(EPOCH FROM NOW()-QUERY_START)::NUMERIC, 2)<0 THEN 0.1 ELSE ROUND(EXTRACT(EPOCH FROM NOW()-QUERY_START)::NUMERIC, 2) END AS ELAPSED_TIME,
				        --B.QUERY AS SQL,
				        --convert_from(convert(decode(B.QUERY, 'escape'), 'euc-kr', 'utf8'), 'utf8') SQL,
				          CASE WHEN B.QUERY LIKE '%pg_catalog.%' THEN B.QUERY
                          ELSE
					          CASE WHEN PG_ENCODING_TO_CHAR(ENCODING) = 'EUC_KR' 
					               THEN CONVERT_FROM(CONVERT(DECODE(B.QUERY, 'escape'), 'EUC-KR', 'UTF8'), 'UTF8')
					               ELSE B.QUERY
					          END
					      END AS SQL,
				          B.STATE AS STATE,
				          A.SEC_FROM_EPOCH AS SEC_FROM_EPOCH,
				          B.BACKEND_XID::text::bigint AS BACKEND_XID,
				           CASE WHEN WAIT_EVENT IS NULL THEN 'CPU' ELSE WAIT_EVENT END AS WAIT_EVENT,
				        --MD5(B.QUERY) AS QUERYID,
				        --MD5(convert_from(convert(decode(B.QUERY, 'escape'), 'euc-kr', 'utf8'), 'utf8')) AS QUERYID,
				          CASE WHEN B.QUERY LIKE '%pg_catalog.%' THEN MD5(B.QUERY)
                          ELSE
					          CASE WHEN PG_ENCODING_TO_CHAR(ENCODING) = 'EUC_KR' 
					               THEN MD5(CONVERT_FROM(CONVERT(DECODE(B.QUERY, 'escape'), 'EUC-KR', 'UTF8'), 'UTF8'))
					               ELSE MD5(B.QUERY)
					          END
				          END AS QUERYID,
				          NOW() AS COLLECT_DT
				  FROM GET_BACKEND_RSC A JOIN PG_STAT_ACTIVITY B ON A.PROC_ID=B.PID
				  JOIN pg_database D on D.oid = B.datid
				  WHERE state NOT IN ('',' ') AND B.QUERY NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%' AND B.DATID IS NOT NULL AND B.APPLICATION_NAME <> 'postgres_fdw'	
	
				]]>
			</when>
			<otherwise>
				SELECT ERROR
			</otherwise>
		</choose>	
	</select>
	
	<select id="BT_BACKEND_RSC_002" parameterType="hashmap" resultType="hashmap" flushCache="true">
				<![CDATA[
                  SELECT /* EXPERDBMABT_BACKEND_RSC_002 (10.0) 24e9ab7301ff1966da4fb30dc1538882 */
                          A.PROC_ID AS PROCESS_ID,
                          B.DATNAME AS DB_NAME,
                          COALESCE(B.DATID, 0) DATID,
                          COALESCE(B.USESYSID, 0) USESYSID,
                          HOST(B.CLIENT_ADDR::inet) AS CLIENT_ADDR,
                          B.USENAME AS USER_NAME,
                          B.APPLICATION_NAME AS APPLICATION_NAME,
                          A.CPU_UTIME AS AGG_PROC_UTIME,
                          A.CPU_STIME AS AGG_PROC_STIME,
                          A.DISK_READ AS AGG_PROC_READ_KB,
                          A.DISK_WRITE AS AGG_PROC_WRITE_KB,
                          CASE WHEN B.STATE='idle' THEN B.BACKEND_START WHEN B.STATE='idle in transaction' THEN b.XACT_START ELSE B.QUERY_START END AS QUERY_START,
                          CASE WHEN B.STATE LIKE 'idle%' THEN 0 WHEN ROUND(EXTRACT(EPOCH FROM NOW()-B.QUERY_START)::NUMERIC, 2)<0 THEN 0.1 ELSE ROUND(EXTRACT(EPOCH FROM NOW()-B.QUERY_START)::NUMERIC, 2) END AS ELAPSED_TIME,
                          MD5(C.QUERY) AS QUERYID,
                          '' AS SQL,
                          B.STATE AS STATE,
                          A.SEC_FROM_EPOCH AS SEC_FROM_EPOCH,
				          B.BACKEND_XID::text::bigint AS BACKEND_XID,
                          COALESCE(B.WAIT_EVENT, '') AS WAIT_EVENT,
                          NOW() AS COLLECT_DT
                  FROM GET_BACKEND_RSC A
                       JOIN PG_ACTIVE_STATEMENTS B ON A.PROC_ID=B.PID
                       join PG_STAT_STATEMENTS C on B.queryid = C.queryid AND b.usesysid = C.userid AND B.datid = C.dbid
                  WHERE state IS NOT NULL AND B.QUERY NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%'  AND B.APPLICATION_NAME <> 'postgres_fdw'
                    ORDER BY process_id;
				]]>
	</select>
	
	<insert id="TB_BACKEND_RSC_I001" parameterType="hashmap" >
		INSERT INTO TB_BACKEND_RSC	
		(	
		    REG_DATE,
		    ACTV_REG_SEQ,
		    PROCESS_ID,
		    DB_NAME,
		    CLIENT_ADDR,
		    USER_NAME,
		    CLIENT_APP,
		    AGG_PROC_UTIME,
		    AGG_PROC_STIME,
		    CURRENT_PROC_UTIME,
		    CURRENT_PROC_STIME,
		    PROC_CPU_UTIL,
		    AGG_PROC_READ_KB,
		    AGG_PROC_WRITE_KB,
		    CURRENT_PROC_READ_KB,
		    CURRENT_PROC_WRITE_KB,
		    QUERY_START,
		    ELAPSED_TIME,
		    STATE,
		    WAIT_EVENT,
		    QUERYID,
		    SQL,
		    COLLECT_DT
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('ACTV_REG_SEQ'),
			#{process_id},
			#{db_name},
			#{client_addr},
			#{user_name},
			#{application_name},
			#{agg_proc_utime},
			#{agg_proc_stime},
			#{current_proc_utime},
			#{current_proc_stime},
			#{proc_cpu_util},
			#{agg_proc_read_kb},
			#{agg_proc_write_kb},
			#{current_proc_read_kb},
			#{current_proc_write_kb},
			#{query_start},
			#{elapsed_time},
			#{state},
			(SELECT CODE FROM TB_SYS_CODE WHERE CODE_NAME = #{wait_event}),
			'0',
--			sharp{sql},
			'',
			#{collect_dt}
		)
	</insert>
		<insert id="TB_BACKEND_RSC_I002" parameterType="hashmap" >
		INSERT INTO TB_BACKEND_RSC	
		(	
		    REG_DATE,
		    ACTV_REG_SEQ,
		    PROCESS_ID,
		    DB_NAME,
		    CLIENT_ADDR,
		    USER_NAME,
		    CLIENT_APP,
		    AGG_PROC_UTIME,
		    AGG_PROC_STIME,
		    CURRENT_PROC_UTIME,
		    CURRENT_PROC_STIME,
		    PROC_CPU_UTIL,
		    AGG_PROC_READ_KB,
		    AGG_PROC_WRITE_KB,
		    CURRENT_PROC_READ_KB,
		    CURRENT_PROC_WRITE_KB,
		    QUERY_START,
		    ELAPSED_TIME,
		    STATE,
		    WAIT_EVENT,
		    QUERYID,
		    SQL,
		    BACKEND_XID,
		    COLLECT_DT
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('ACTV_REG_SEQ'),
			#{process_id},
			#{db_name},
			#{client_addr},
			#{user_name},
			#{application_name},
			#{agg_proc_utime},
			#{agg_proc_stime},
			#{current_proc_utime},
			#{current_proc_stime},
			#{proc_cpu_util},
			#{agg_proc_read_kb},
			#{agg_proc_write_kb},
			#{current_proc_read_kb},
			#{current_proc_write_kb},
			#{query_start},
			#{elapsed_time},
			#{state},
			(SELECT CODE FROM TB_SYS_CODE WHERE CODE_NAME = #{wait_event}),
			#{queryid},
--			sharp{sql},
			'',
			#{backend_xid},
			#{collect_dt}
		)
	</insert>
	<insert id="TB_BACKEND_RSC_I003" parameterType="hashmap" >
		INSERT INTO TB_BACKEND_RSC	
		(	
		    REG_DATE,
		    ACTV_REG_SEQ,
		    PROCESS_ID,
		    DB_NAME,
		    CLIENT_ADDR,
		    USER_NAME,
		    CLIENT_APP,
		    AGG_PROC_UTIME,
		    AGG_PROC_STIME,
		    CURRENT_PROC_UTIME,
		    CURRENT_PROC_STIME,
		    PROC_CPU_UTIL,
		    AGG_PROC_READ_KB,
		    AGG_PROC_WRITE_KB,
		    CURRENT_PROC_READ_KB,
		    CURRENT_PROC_WRITE_KB,
		    QUERY_START,
		    ELAPSED_TIME,
		    STATE,
		    WAIT_EVENT,
		    QUERYID,
		    SQL,
		    BACKEND_XID,
		    COLLECT_DT
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('ACTV_REG_SEQ'),
			#{process_id},
			#{db_name},
			#{client_addr},
			#{user_name},
			#{application_name},
			#{agg_proc_utime},
			#{agg_proc_stime},
			#{current_proc_utime},
			#{current_proc_stime},
			#{proc_cpu_util},
			#{agg_proc_read_kb},
			#{agg_proc_write_kb},
			#{current_proc_read_kb},
			#{current_proc_write_kb},
			#{query_start},
			#{elapsed_time},
			#{state},
			(SELECT CODE FROM TB_SYS_CODE WHERE CODE_NAME = #{wait_event}),
			#{queryid},
			--sharp{sql},
			'',
			#{backend_xid},
			#{collect_dt}
		)
	</insert>
	
	<select id="PG_STAT_DATABASE_INFO_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMABT_PG_STAT_DATABASE_INFO_001 24e9ab7301ff1966da4fb30dc1538882 */
			   DATID, DATNAME AS DB_NAME 
		  FROM PG_STAT_DATABASE WHERE DATNAME NOT IN ('template0','template1');
	</select>
	
	
	<select id="BT_ACCESS_INFO_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<![CDATA[
		 SELECT /* EXPERDBMABT_ACCESS_INFO_001 24e9ab7301ff1966da4fb30dc1538882 */                                                                                                                                                                              
		        --? AS REG_DATE, --@ TO_CHAR(NOW(), 'YYYYMMDD')                                                                                                                                                           
		        --? AS OBJT_REG_SEQ, --@NEXTVAL('OBJT_REG_SEQ')                                                                                                                                                           
		        #{db_name} AS DB_NAME, -- @DATNAME                                                                                                                                                                        
		        PG_DATABASE_SIZE(#{datid})/1024 AS DB_SIZE_KB, -- @DATID                                                                                                                                                  
		        COUNT(A.RELID) AS TABLE_CNT,                                                                                                                                                                              
		        (SELECT COUNT(INDEXRELID) FROM PG_STAT_USER_INDEXES) AS INDEX_CNT,                                                                                                                                         
		        COALESCE(SUM(A.HEAP_BLKS_READ), 0) AS AGG_HEAP_BLKS_READ_KB,                                                                                                                                                           
		        COALESCE(SUM(A.HEAP_BLKS_HIT), 0) AS AGG_HEAP_BLKS_HIT_KB,                                                                                                                                                             
		        COALESCE(SUM(B.SEQ_TUP_READ), 0) AS AGG_SEQ_READ_TUPLES,                                                                                                                                                               
		        COALESCE(SUM(B.IDX_TUP_FETCH), 0) AS AGG_IDX_FETCH_TUPLES,
	          	COALESCE(SUM(B.n_tup_ins), 0) AS AGG_INSERT_TUPLES,-- insert
	          	COALESCE(SUM(B.n_tup_upd), 0) AS AGG_UPDATE_TUPLES,-- update
	          	COALESCE(SUM(B.n_tup_del), 0) AS AGG_DELETE_TUPLES,-- delete
		        COALESCE(SUM(B.SEQ_SCAN), 0) AS AGG_SEQ_SCAN_CNT,
		        COALESCE(SUM(B.IDX_SCAN), 0) AS AGG_IDX_SCAN_CNT,
		        COALESCE(SUM(HEAP_BLKS_READ),0)+COALESCE(SUM(IDX_BLKS_READ),0)+COALESCE(SUM(TOAST_BLKS_READ),0)+COALESCE(SUM(TIDX_BLKS_READ),0) AS AGG_PHY_READ,	          	
	          	(SELECT XACT_COMMIT FROM PG_STAT_DATABASE WHERE DATNAME=CURRENT_DATABASE()) AS AGG_COMMIT,
	          	(SELECT XACT_ROLLBACK FROM PG_STAT_DATABASE WHERE DATNAME=CURRENT_DATABASE()) AS AGG_ROLLBACK,		        
		        COALESCE(SUM(HEAP_BLKS_READ), 0) - #{agg_heap_blks_read_kb} AS CURRENT_HEAP_BLKS_READ_KB, -- @이전값                                                                                                               
		        COALESCE(SUM(HEAP_BLKS_HIT), 0) - #{agg_heap_blks_hit_kb} AS CURRENT_HEAP_BLKS_HIT_KB, -- @이전값                                                                                                                  
		        COALESCE(SUM(B.SEQ_TUP_READ), 0) - #{agg_seq_read_tuples} AS CURRENT_SEQ_READ_TUPLES, -- @이전값 (AGG_SEQ_READ_TUPLES 의 current value)                                                                            
		        COALESCE(SUM(B.IDX_TUP_FETCH), 0) - #{agg_idx_fetch_tuples} AS CURRENT_IDX_FETCH_TUPLES, -- @이전값 (AGG_IDX_FETCH_TUPLES의 current value)
   	            COALESCE(SUM(B.n_tup_ins), 0) - #{agg_insert_tuples} AS CURRENT_INSERT_TUPLES,-- insert
	            COALESCE(SUM(B.n_tup_upd), 0) - #{agg_update_tuples} AS CURRENT_UPDATE_TUPLES,-- update
	            COALESCE(SUM(B.n_tup_del), 0) - #{agg_delete_tuples} AS CURRENT_DELETE_TUPLES,-- delete
        		COALESCE(SUM(B.SEQ_SCAN), 0) - #{agg_seq_scan_cnt} AS CURRENT_SEQ_SCAN_CNT,
          		COALESCE(SUM(B.IDX_SCAN), 0) - #{agg_idx_scan_cnt} AS CURRENT_IDX_SCAN_CNT,
          		COALESCE(SUM(HEAP_BLKS_READ),0)+COALESCE(SUM(IDX_BLKS_READ),0)+COALESCE(SUM(TOAST_BLKS_READ),0)+COALESCE(SUM(TIDX_BLKS_READ),0) - #{agg_phy_read} AS CURRENT_PHY_READ,
	            (SELECT XACT_COMMIT FROM PG_STAT_DATABASE WHERE DATNAME=CURRENT_DATABASE()) - #{agg_commit} as CURRENT_COMMIT,
	            (SELECT XACT_ROLLBACK FROM PG_STAT_DATABASE WHERE DATNAME=CURRENT_DATABASE()) - #{agg_rollback} as CURRENT_ROLLBACK,		        
		        --CASE WHEN SUM(A.HEAP_BLKS_HIT)<>0 AND SUM(A.HEAP_BLKS_HIT) > SUM(A.HEAP_BLKS_READ) THEN ROUND((SUM(A.HEAP_BLKS_HIT) - SUM(A.HEAP_BLKS_READ)) / SUM(A.HEAP_BLKS_HIT)*100,2) ELSE 0 END AS BUFFER_HIT_RATIO,
		        (SELECT CASE WHEN BLKS_HIT = 0 AND BLKS_READ = 0 THEN 0 ELSE TRUNC(((BLKS_HIT::DECIMAL/(BLKS_READ+BLKS_HIT)::DECIMAL) * 100), 2) END AS CACHE_HIT_RATIO FROM PG_STAT_DATABASE WHERE DATNAME=CURRENT_DATABASE()) AS BUFFER_HIT_RATIO,
		        --(SELECT ROUND(TOTAL_TIME::NUMERIC/CALLS,5) FROM PG_STAT_STATEMENTS ORDER BY TOTAL_TIME/CALLS DESC LIMIT 1) AS MAX_SQL_ELAPSED_SEC, --NOTICE!! V9.2 : MILLI SEC                                          
		        --(SELECT ROUND(SUM(TOTAL_TIME::NUMERIC)/SUM(CALLS),5) FROM PG_STAT_STATEMENTS) AS AVG_SQL_ELAPSED_SEC, --NOTICE!! V9.2 : MILLI SEC                                                                       
		        NOW() AS COLLECT_DT,
		        EXTRACT(EPOCH FROM NOW()-#{collect_dt})::NUMERIC(10,3) AS DELTA_TIME
		FROM PG_STATIO_USER_TABLES A, PG_STAT_USER_TABLES B WHERE A.RELNAME=B.RELNAME
		]]>
	</select>
	
	<insert id="TB_ACCESS_INFO_I001" parameterType="hashmap" >
	<![CDATA[
		INSERT INTO TB_ACCESS_INFO	
		(
			REG_DATE,
			ACTV_REG_SEQ,
			DB_NAME,
			DB_SIZE_KB,
			TABLE_CNT,
			INDEX_CNT,
			AGG_HEAP_BLKS_READ_KB,
			AGG_HEAP_BLKS_HIT_KB,
			AGG_SEQ_READ_TUPLES,
			AGG_IDX_FETCH_TUPLES,
			AGG_INSERT_TUPLES,
			AGG_UPDATE_TUPLES,
			AGG_DELETE_TUPLES,
			AGG_SEQ_SCAN_CNT,
			AGG_IDX_SCAN_CNT,
			AGG_COMMIT,
			AGG_ROLLBACK,
			AGG_PHY_READ,
			CURRENT_HEAP_BLKS_READ_KB,
			CURRENT_HEAP_BLKS_HIT_KB,
			CURRENT_SEQ_READ_TUPLES,
			CURRENT_IDX_FETCH_TUPLES,
			CURRENT_INSERT_TUPLES,
			CURRENT_UPDATE_TUPLES,
			CURRENT_DELETE_TUPLES,
			CURRENT_SEQ_SCAN_CNT,
			CURRENT_IDX_SCAN_CNT,
			CURRENT_PHY_READ,
			CURRENT_COMMIT,
			CURRENT_ROLLBACK,
			BUFFER_HIT_RATIO,
			COLLECT_DT,
			DELTA_TIME
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('ACTV_REG_SEQ'),
			#{db_name},
			#{db_size_kb},
			#{table_cnt},
			#{index_cnt},
			#{agg_heap_blks_read_kb},
			#{agg_heap_blks_hit_kb},
			#{agg_seq_read_tuples},
			#{agg_idx_fetch_tuples},
			#{agg_insert_tuples},
			#{agg_update_tuples},
			#{agg_delete_tuples},
			#{agg_seq_scan_cnt},
			#{agg_idx_scan_cnt},
			#{agg_commit},
			#{agg_rollback},
			#{agg_phy_read},
			CASE WHEN (#{current_heap_blks_read_kb}) < 0 THEN 0 ELSE #{current_heap_blks_read_kb} END,
			CASE WHEN (#{current_heap_blks_hit_kb} ) < 0 THEN 0 ELSE #{current_heap_blks_hit_kb}  END,
			CASE WHEN (#{current_seq_read_tuples}  ) < 0 THEN 0 ELSE #{current_seq_read_tuples}   END,
			CASE WHEN (#{current_idx_fetch_tuples} ) < 0 THEN 0 ELSE #{current_idx_fetch_tuples}  END,
			CASE WHEN (#{current_insert_tuples}    ) < 0 THEN 0 ELSE #{current_insert_tuples}     END,
			CASE WHEN (#{current_update_tuples}    ) < 0 THEN 0 ELSE #{current_update_tuples}     END,
			CASE WHEN (#{current_delete_tuples}    ) < 0 THEN 0 ELSE #{current_delete_tuples}     END,
			CASE WHEN (#{current_seq_scan_cnt}     ) < 0 THEN 0 ELSE #{current_seq_scan_cnt}      END,
			CASE WHEN (#{current_idx_scan_cnt}	   ) < 0 THEN 0 ELSE #{current_idx_scan_cnt}	  END,
			CASE WHEN (#{current_phy_read}		   ) < 0 THEN 0 ELSE #{current_phy_read}	      END,
			CASE WHEN (#{current_commit}           ) < 0 THEN 0 ELSE #{current_commit}            END,
			CASE WHEN (#{current_rollback}         ) < 0 THEN 0 ELSE #{current_rollback}          END,
			#{buffer_hit_ratio},
			#{collect_dt},
			#{delta_time}
		)
		]]>
	</insert>
<!-- ********************************************************** -->
<!-- ActvCollect END -->
<!-- ********************************************************** -->



<!-- ********************************************************** -->
<!-- HchkCollect START -->
<!-- ********************************************************** -->
	<select id="TB_HCHK_COLLECT_INFO_S001" parameterType="hashmap" resultType="hashmap">
		select max(reg_date) as max_reg_date, TO_CHAR(NOW(), 'YYYYMMDD') as reg_date from TB_HCHK_COLLECT_INFO;
	</select>

	<select id="SEQ_SETVAL_HCHK" parameterType="hashmap" resultType="hashmap">
		select setval('hchk_reg_seq',1);
	</select>

	<select id="HCHK_REG_SEQ_001" parameterType="hashmap" resultType="hashmap">
		SELECT NEXTVAL('HCHK_REG_SEQ');
	</select>
	
	<insert id="TB_HCHK_COLLECT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_HCHK_COLLECT_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('HCHK_REG_SEQ'),
			#{instance_id},
			#{hchk_name},
			#{value},
			#{collect_group},
			#{collect_reg_date},
			#{collect_reg_seq},
			#{reg_time}
		)
	</insert>
	
	<update id="TB_HCHK_THRD_LIST_U001" parameterType="hashmap" >
	 	UPDATE TB_HCHK_THRD_LIST SET CRITICAL_START_TIME = #{critical_start_time}
	 	 WHERE INSTANCE_ID = #{instance_id} AND HCHK_NAME = #{hchk_name};
	</update>

	<select id="EXPERDBMA_BT_HCHK_BUFFERHITRATIO_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[		
		SELECT /* EXPERDBMA_BT_HCHK_BUFFERHITRATIO_001 */
		         OCM.INSTANCE_ID,
		         ROUND(AVG(BUFFER_HIT_RATIO),2) AS BUFFERHITRATIO,
		         --CASE WHEN SUM(ACS.CURRENT_COMMIT)=0 THEN 0 ELSE ROUND(SUM(ACS.CURRENT_COMMIT) / (SUM(ACS.CURRENT_COMMIT) + SUM(ACS.CURRENT_ROLLBACK)) * 100, 2) END AS COMMITRATIO,
		         CASE WHEN SUM(ACS.CURRENT_COMMIT)=0 AND SUM(ACS.CURRENT_ROLLBACK)=0 THEN 100.00 ELSE ROUND(SUM(ACS.CURRENT_COMMIT) / (SUM(ACS.CURRENT_COMMIT) + SUM(ACS.CURRENT_ROLLBACK)) * 100, 2) END AS COMMITRATIO,
		         '1' AS COLLECT_GROUP,
		         ACS.REG_DATE AS COLLECT_REG_DATE,
		         ACS.ACTV_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
		         MAX(OCM.REG_TIME) AS REG_TIME
		         --'BUFFERHITRATIO,COMMITRATIO' AS ITEM
		  FROM TB_ACTV_COLLECT_INFO AS OCM,
		          TB_INSTANCE_INFO IST,
		          TB_ACCESS_INFO ACS
		WHERE ACS.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
		   AND ACS.REG_DATE = OCM.REG_DATE
		   AND ACS.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
		   AND ACS.ACTV_REG_SEQ = OCM.ACTV_REG_SEQ
		   AND IST.INSTANCE_ID = OCM.INSTANCE_ID
			AND IST.COLLECT_YN = 'Y'
		   AND IST.DELETE_YN='N'
		   AND BUFFER_HIT_RATIO != 0 -- except buffer ratio zero 
		GROUP BY ACS.REG_DATE,ACS.ACTV_REG_SEQ,OCM.INSTANCE_ID;  
		]]>
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_LOCKCNT_001" parameterType="hashmap" resultType="hashmap">
			 SELECT /* EXPERDBMA_BT_HCHK_LOCKCNT_001 */
		         ACM.INSTANCE_ID,
		         SUM(CASE WHEN BLOCKED_PID is null THEN 0 ELSE 1 END) AS LOCKCNT,
		         '2' AS COLLECT_GROUP,
		         LCK.REG_DATE AS COLLECT_REG_DATE,
		         LCK.ACTV_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
		         MAX(ACM.REG_TIME) AS REG_TIME 
		  FROM TB_INSTANCE_INFO AS IST,
		  	   TB_ACTV_COLLECT_INFO AS ACM 
		  LEFT OUTER JOIN 
		  	   TB_CURRENT_LOCK AS LCK ON ACM.REG_DATE = LCK.REG_DATE AND ACM.ACTV_REG_SEQ = LCK.ACTV_REG_SEQ  
		WHERE ACM.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
		   AND ACM.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
		   AND IST.INSTANCE_ID = ACM.INSTANCE_ID   
		   AND IST.COLLECT_YN = 'Y'             
		   AND IST.DELETE_YN='N'
		   --AND LCK.BLOCKED_PID IS NOT NULL 
		GROUP BY LCK.REG_DATE,LCK.ACTV_REG_SEQ,ACM.INSTANCE_ID;
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_LOCKCNT_001_OLD" parameterType="hashmap" resultType="hashmap">
		 SELECT /* EXPERDBMA_BT_HCHK_LOCKCNT_001 */
		         ACM.INSTANCE_ID,
		         SUM(1) AS LOCKCNT,
		         '2' AS COLLECT_GROUP,
		         LCK.REG_DATE AS COLLECT_REG_DATE,
		         LCK.ACTV_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
		         MAX(ACM.REG_TIME) AS REG_TIME 
		  FROM TB_ACTV_COLLECT_INFO AS ACM,
		          TB_CURRENT_LOCK AS LCK,
		          TB_INSTANCE_INFO AS IST
		WHERE LCK.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
		   AND LCK.REG_DATE = ACM.REG_DATE
		   AND LCK.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
		   AND LCK.ACTV_REG_SEQ = ACM.ACTV_REG_SEQ  
		   AND IST.INSTANCE_ID = ACM.INSTANCE_ID   
		   AND IST.COLLECT_YN = 'Y'             
		   AND IST.DELETE_YN='N'
		   AND LCK.BLOCKED_PID IS NOT NULL 
		GROUP BY LCK.REG_DATE,LCK.ACTV_REG_SEQ,ACM.INSTANCE_ID;
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_CONNECTION_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		WITH IST AS (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN='N')
		SELECT /* EXPERDBMA_BT_HCHK_CONNECTION_001 */
		         ACM.INSTANCE_ID,
		         --ROUND(SUM(CASE WHEN BAK.SQL <> '<IDLE>' THEN 0 ELSE 1 END)::NUMERIC/MAX(IST.MAX_CONN_CNT) * 100, 2) AS ACTIVECONNECTION,
		         ROUND(SUM(1)::NUMERIC/MAX(IST.MAX_CONN_CNT) * 100, 2) AS ACTIVECONNECTION,
		         --add state SUM(CASE WHEN SQL = '<IDLE> in transaction' THEN 1 ELSE 0 END)  AS TRAXIDLECNT,
		         SUM(CASE WHEN STATE = 'idle in transaction' THEN 1 ELSE 0 END)  AS TRAXIDLECNT,
		         --MAX(ELAPSED_TIME) AS LONGRUNSQL,
		         '2' AS COLLECT_GROUP,
		         BAK.REG_DATE AS COLLECT_REG_DATE,
		         BAK.ACTV_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
		         CURRENT_TIME AS REG_TIME
		         --'ACTIVECONNECTION,TRAXIDLECNT,LONGRUNSQL' AS ITEM
		 FROM IST,
		 	  TB_ACTV_COLLECT_INFO AS ACM,
		      TB_BACKEND_RSC AS BAK
		WHERE BAK.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
		   AND BAK.REG_DATE = ACM.REG_DATE
		   AND BAK.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
		   AND BAK.ACTV_REG_SEQ = ACM.ACTV_REG_SEQ
		   AND BAK.USER_NAME IS NOT NULL
		   AND IST.INSTANCE_ID = ACM.INSTANCE_ID
		GROUP BY BAK.REG_DATE,BAK.ACTV_REG_SEQ,ACM.INSTANCE_ID;
		]]>
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_LONGRUNSQL_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		SELECT INSTANCEID AS INSTANCE_ID,
			   --ACTIVECONNECTION, TRAXIDLECNT, 
			   LONGRUNSQL, COLLECT_GROUP, COLLECT_REG_DATE, REG_SEQ COLLECT_REG_SEQ, REG_TIME FROM  GET_SESSION_HEALTH()
		ORDER BY INSTANCE_ID
		]]>
	</select>	
	
	<select id="EXPERDBMA_BT_HCHK_LONGRUNSQL_CHK_FN_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		SELECT EXISTS(SELECT * FROM pg_proc WHERE proname = 'get_session_health') as exists;
		]]>
	</select>	
	
	<select id="EXPERDBMA_BT_HCHK_LONGRUNSQL_CREATE_FN_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
 			CREATE OR REPLACE FUNCTION GET_SESSION_HEALTH()
				RETURNS TABLE (INSTANCEID INT, LONGRUNSQL INT, COLLECT_GROUP VARCHAR, COLLECT_REG_DATE VARCHAR, REG_SEQ VARCHAR, REG_TIME TIME) AS 
				$$
			DECLARE    
			    VAR_INSTANCE_ID INT;
  			    VAR_COND_LEFT VARCHAR;
  			    VAR_COND_RIGHT VARCHAR;
  			    VAR_COND VARCHAR;
			    TMP_CONDTYPE VARCHAR;
			    TMP_STR VARCHAR;
			    VAR_SQL VARCHAR;
			BEGIN    
				VAR_INSTANCE_ID = -1;
				VAR_SQL = '';
				FOR VAR_INSTANCE_ID IN
	        		SELECT INSTANCE_ID INSTANCEID FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN='N'	order by instance_id        		
			    loop
					VAR_COND_LEFT := '''ZZ'' ';
					VAR_COND_RIGHT := '''ZZ'' ';
			    	FOR tmp_condtype, tmp_str IN
					    SELECT JSONB_ARRAY_ELEMENTS(RESERVED_STR::JSONB)->>'coltype' CONDTYPE,
					           JSONB_ARRAY_ELEMENTS(RESERVED_STR::JSONB)->>'typestr' STR FROM TB_HCHK_THRD_LIST THTL WHERE INSTANCE_ID = VAR_INSTANCE_ID AND HCHK_NAME = 'LONGRUNSQL' AND RESERVED_STR <> '' ORDER BY CONDTYPE
					loop
					RAISE NOTICE 'tmp_condtype,tmp_str: %,%', tmp_condtype, tmp_str;
						if tmp_condtype = '1' then
							VAR_COND_LEFT := VAR_COND_LEFT || ' ||BAK.USER_NAME';
							VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || tmp_str || '''';
					    elseif tmp_condtype = '2' then 
							VAR_COND_LEFT := concat(VAR_COND_LEFT, '||BAK.DB_NAME');
							VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || tmp_str || '''';
					    elseif tmp_condtype = '3' then
							VAR_COND_LEFT := concat(VAR_COND_LEFT, '||BAK.CLIENT_ADDR');
							VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || tmp_str || '''';
					    end if;
					end loop;
					if VAR_COND_RIGHT <> '''ZZ'' ' then
						VAR_COND := VAR_COND_LEFT || '<>' || VAR_COND_RIGHT;
					else
						VAR_COND := ' 1=1';
					end if;
			        VAR_SQL := 'WITH IST AS (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = ''Y'' AND DELETE_YN=''N'')
						SELECT ACM.INSTANCE_ID,
						       MAX(ELAPSED_TIME) AS LONGRUNSQL,
						       ''2'' AS COLLECT_GROUP,
						       BAK.REG_DATE AS COLLECT_REG_DATE,
						       BAK.ACTV_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
						       CURRENT_TIME AS REG_TIME
						 FROM TB_ACTV_COLLECT_INFO AS ACM FULL OUTER JOIN TB_BACKEND_RSC AS BAK ON ACM.REG_DATE = BAK.REG_DATE AND ACM.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ 
						WHERE BAK.REG_DATE=TO_CHAR(NOW(), ''YYYYMMDD'')
						   AND BAK.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), ''YYYYMMDD'') AND X.INSTANCE_ID=' || VAR_INSTANCE_ID || ')
						   AND BAK.USER_NAME IS NOT NULL
   						   AND ACM.INSTANCE_ID = ' || VAR_INSTANCE_ID || 
   						   ' AND' || VAR_COND ||
						' GROUP BY BAK.REG_DATE,BAK.ACTV_REG_SEQ,ACM.INSTANCE_ID';
   					--RAISE NOTICE 'VAR_SQL: %', VAR_SQL;
			    	FOR INSTANCEID, LONGRUNSQL, COLLECT_GROUP, COLLECT_REG_DATE, REG_SEQ, REG_TIME in execute VAR_SQL
					LOOP
						RETURN NEXT;
				    END LOOP;
			    END LOOP;
 			END $$
 			LANGUAGE 'plpgsql';
		]]>
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_CONNECTIONFAIL_001" parameterType="hashmap" resultType="hashmap">
		SELECT  /* EXPERDBMA_BT_HCHK_CONNECTIONFAIL_001 */
		         INSTANCE_ID,
		         SUM(CASE WHEN IS_COLLECT_OK='N' THEN 1 ELSE 0 END) AS CONNECTIONFAIL,
		         MAX('0') COLLECT_GROUP,
		         REG_DATE AS COLLECT_REG_DATE,
		         STRING_AGG(REG_SEQ::VARCHAR, ',') AS COLLECT_REG_SEQ,
		         CURRENT_TIME AS REG_TIME 	
		 FROM (
		         /* SELECT A.REG_DATE,A.OBJT_REG_SEQ AS REG_SEQ, A.INSTANCE_ID, A.IS_COLLECT_OK
		                    FROM TB_OBJT_COLLECT_INFO A,
		                            TB_INSTANCE_INFO B
		                   WHERE REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') 
		                    	AND OBJT_REG_SEQ=(SELECT MAX(X.OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=B.INSTANCE_ID )
		                    	AND B.COLLECT_YN='Y'
		                    	AND B.DELETE_YN='N'
		         UNION ALL */
		         SELECT A.REG_DATE,A.ACTV_REG_SEQ AS REG_SEQ, A.INSTANCE_ID, A.IS_COLLECT_OK
		                    FROM TB_ACTV_COLLECT_INFO A,
		                            TB_INSTANCE_INFO B
		                   WHERE REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') 
		                    	AND ACTV_REG_SEQ=(SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=B.INSTANCE_ID )
		                    	AND B.COLLECT_YN='Y'
		                    	AND B.DELETE_YN='N'
		         UNION ALL
		         SELECT A.REG_DATE,A.RSC_REG_SEQ AS REG_SEQ, A.INSTANCE_ID, A.IS_COLLECT_OK
		                    FROM TB_RSC_COLLECT_INFO A,
		                            TB_INSTANCE_INFO B
		                   WHERE REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') 
		                    	AND RSC_REG_SEQ=(SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=B.INSTANCE_ID )
		                    	AND B.COLLECT_YN='Y'
		                    	AND B.DELETE_YN='N') AS T
		GROUP BY INSTANCE_ID,REG_DATE,CURRENT_TIME;
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_UNUSEDINDEX_001" parameterType="hashmap" resultType="hashmap">
		WITH IST AS (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN='N'),
		IDX AS (
			SELECT /* EXPERDBMA_BT_HCHK_UNUSEDINDEX_001 */
			         OCM.INSTANCE_ID,
			         SUM(CASE WHEN AGG_INDEX_SCAN_CNT = 0 THEN 1 ELSE 0 END)  AS UNUSEDINDEX,
			         SUM(CASE WHEN INDEX_IS_VALID = false THEN 1 ELSE 0 END)  AS INVALIDINDEX,			         
			         --IDX.AGG_INDEX_SCAN_CNT AS VALUE,
			         '1' AS COLLECT_GROUP,
			         IDX.REG_DATE AS COLLECT_REG_DATE,
			         IDX.OBJT_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
			         CURRENT_TIME AS REG_TIME 	
			  FROM TB_OBJT_COLLECT_INFO AS OCM,
			          TB_INSTANCE_INFO AS IST,
			          TB_INDEX_INFO IDX
			WHERE IDX.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
			   AND IDX.REG_DATE = OCM.REG_DATE
			   AND IDX.OBJT_REG_SEQ = (SELECT MAX(X.OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
			   AND IDX.OBJT_REG_SEQ = OCM.OBJT_REG_SEQ  
			   AND IST.INSTANCE_ID = OCM.INSTANCE_ID   
				AND IST.COLLECT_YN = 'Y'             
			   AND IST.DELETE_YN='N' 
			GROUP BY IDX.REG_DATE,IDX.OBJT_REG_SEQ,OCM.INSTANCE_ID
		),
		TTE AS (
			SELECT O.INSTANCE_ID, CAST(MAX(T.MAXAGE) AS REAL) / CAST(trunc(((2^32)/2)-1-1000000) AS REAL) M1, CAST(MAX(T.MAXAGE) AS REAL) * 100 M2
			  FROM IST, 
			  	   TB_OBJT_COLLECT_INFO O,
			  	   TB_TABLE_EXT_INFO T
			 WHERE O.REG_DATE = TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD')
			   AND T.REG_DATE = O.REG_DATE
			   AND IST.INSTANCE_ID = O.INSTANCE_ID
			   AND O.OBJT_REG_SEQ = (SELECT MAX(X.OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
			   AND O.OBJT_REG_SEQ = T.OBJT_REG_SEQ
			 GROUP BY O.REG_DATE,O.OBJT_REG_SEQ,O.INSTANCE_ID
		)
--		SELECT IDX.INSTANCE_ID, IDX.UNUSEDINDEX, TTE.M1::NUMERIC(5,2) FROZENMAXAGE, '1' AS COLLECT_GROUP, IDX.COLLECT_REG_DATE, IDX.COLLECT_REG_SEQ, IDX.REG_TIME 	
		SELECT IDX.INSTANCE_ID, IDX.UNUSEDINDEX, IDX.INVALIDINDEX, M1*100 FROZENMAXAGE, '1' AS COLLECT_GROUP, IDX.COLLECT_REG_DATE, IDX.COLLECT_REG_SEQ, IDX.REG_TIME 	
		  FROM IDX, TTE
		 WHERE IDX.INSTANCE_ID = TTE.INSTANCE_ID
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_LASTANALYZE_002" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMA_BT_HCHK_LASTANALYZE_001 */
		         OCM.INSTANCE_ID,
		         CASE WHEN MAX(NOW()::DATE - LAST_ANALYZE::DATE) >= 99999 THEN 99999 ELSE MAX(NOW()::DATE - LAST_ANALYZE::DATE) END AS LASTANALYZE,
				 -- CASE WHEN EXTRACT(DAY FROM MAX(NOW()::DATE - LAST_ANALYZE::DATE)) >= 99999 THEN 99999 ELSE EXTRACT(DAY FROM MAX(NOW()::DATE - LAST_ANALYZE::DATE)) END AS LASTANALYZE, --DAUM 적용쿼리         
		         CASE WHEN MAX(NOW()::DATE - LAST_VACUUM::DATE) >= 99999 THEN 99999 ELSE MAX(NOW()::DATE - LAST_VACUUM::DATE) END AS LASTVACUUM,
		         -- CASE WHEN EXTRACT(DAY FROM MAX(NOW()::DATE - LAST_VACUUM::DATE)) >= 99999 THEN 99999 ELSE EXTRACT(DAY FROM MAX(NOW()::DATE - LAST_VACUUM::DATE)) END AS LASTVACUUM, --DAUM 적용쿼리
		         '1' AS COLLECT_GROUP,
		         TBS.REG_DATE AS COLLECT_REG_DATE,
		         TBS.OBJT_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
		         CURRENT_TIME AS REG_TIME 	
		  FROM TB_OBJT_COLLECT_INFO AS OCM,
		         TB_INSTANCE_INFO AS IST,
		          TB_TABLE_INFO TBS
		WHERE TBS.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
		   AND TBS.REG_DATE = OCM.REG_DATE
		   AND TBS.OBJT_REG_SEQ = (SELECT MAX(X.OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
		   AND TBS.OBJT_REG_SEQ = OCM.OBJT_REG_SEQ  
		   AND IST.INSTANCE_ID = OCM.INSTANCE_ID   
			AND IST.COLLECT_YN = 'Y'             
		   AND IST.DELETE_YN='N' 
		GROUP BY TBS.REG_DATE,TBS.OBJT_REG_SEQ,OCM.INSTANCE_ID;
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_LASTANALYZE_001" parameterType="hashmap" resultType="hashmap">
			SELECT   INSTANCE_ID,
				 max(LASTANALYZE) LASTANALYZE,
				 max(LASTVACUUM) LASTVACUUM,
		         max(COLLECT_GROUP) COLLECT_GROUP,
		         COLLECT_REG_DATE,
		         COLLECT_REG_SEQ,
		         CURRENT_TIME AS REG_TIME
			FROM
			(
			SELECT /* EXPERDBMA_BT_HCHK_LASTANALYZE_001 */
			         OCM.INSTANCE_ID,
			         CASE WHEN NEED_ANALYZE = true
			         	  THEN CASE WHEN NOW()::DATE - LAST_ANALYZE::DATE >= 99999 THEN 99999 
			         	  ELSE (NOW()::DATE - LAST_ANALYZE::DATE) END
			         	  ELSE 0 END AS LASTANALYZE,
			         	  NEED_ANALYZE,
			         CASE WHEN NEED_VACUUM = true
			         	  THEN CASE WHEN NOW()::DATE - LAST_VACUUM::DATE >= 99999 THEN 99999 
			         	  ELSE (NOW()::DATE - LAST_VACUUM::DATE) END
			         	  ELSE 0 END AS LASTVACUUM,
			         	  NEED_VACUUM,
			         '1' AS COLLECT_GROUP,
			         TBS.REG_DATE AS COLLECT_REG_DATE,
			         TBS.OBJT_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ         
			  FROM TB_OBJT_COLLECT_INFO AS OCM,
			         TB_TABLE_INFO TBS, 
			         TB_INSTANCE_INFO AS IST
			WHERE TBS.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
			   AND TBS.REG_DATE = OCM.REG_DATE
			   AND TBS.OBJT_REG_SEQ = (SELECT MAX(X.OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
			   AND TBS.OBJT_REG_SEQ = OCM.OBJT_REG_SEQ  
			   AND IST.INSTANCE_ID = OCM.INSTANCE_ID
			   AND IST.COLLECT_YN = 'Y'
			   AND IST.DELETE_YN='N'
			) AS A
			GROUP BY COLLECT_REG_DATE,COLLECT_REG_SEQ,INSTANCE_ID;
	</select>

	
	<select id="EXPERDBMA_BT_HCHK_DISKUSAGE_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
SELECT /* EXPERDBMA_BT_HCHK_DISKUSAGE_001 */
         RCM.INSTANCE_ID,
         MAX(ROUND(100 - (avail_KB / TOTAL_KB * 100), 2)) AS DISKUSAGE,
         '3' AS COLLECT_GROUP,
         DUS.REG_DATE AS COLLECT_REG_DATE,
         DUS.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
  FROM TB_RSC_COLLECT_INFO AS RCM,
          TB_INSTANCE_INFO AS IST,
          TB_DISK_USAGE DUS
WHERE DUS.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND DUS.REG_DATE = RCM.REG_DATE
   AND DUS.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND DUS.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N' 
GROUP BY DUS.REG_DATE,DUS.RSC_REG_SEQ,RCM.INSTANCE_ID;
		]]>
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_CPUUTIL_001" parameterType="hashmap" resultType="hashmap">
SELECT /* EXPERDBMA_BT_HCHK_CPUUTIL_001 */
         RCM.INSTANCE_ID,
         CASE WHEN CPU.USER_UTIL_RATE + CPU.NICE_UTIL_RATE + CPU.SYS_UTIL_RATE + CPU.WAIT_UTIL_RATE > 100 THEN 100 ELSE CPU.USER_UTIL_RATE + CPU.NICE_UTIL_RATE + CPU.SYS_UTIL_RATE + CPU.WAIT_UTIL_RATE END AS CPUUTIL,
         '3' AS COLLECT_GROUP,
         CPU.REG_DATE AS COLLECT_REG_DATE,
         CPU.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
  FROM TB_RSC_COLLECT_INFO AS RCM,
          TB_INSTANCE_INFO  AS IST,
          TB_CPU_STAT_MASTER CPU
WHERE CPU.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND CPU.REG_DATE = RCM.REG_DATE
   AND CPU.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND CPU.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N';
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_CPUWAIT_001" parameterType="hashmap" resultType="hashmap">
SELECT /* EXPERDBMA_BT_HCHK_CPUWAIT_001 */
         RCM.INSTANCE_ID,
         WAIT_UTIL_RATE AS CPUWAIT,
         '3' AS COLLECT_GROUP,
         CPU.REG_DATE AS COLLECT_REG_DATE,
         CPU.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
  FROM TB_RSC_COLLECT_INFO AS RCM,
          TB_INSTANCE_INFO  AS IST,
          TB_CPU_STAT_MASTER CPU
WHERE CPU.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND CPU.REG_DATE = RCM.REG_DATE
   AND CPU.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND CPU.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N';
	</select>
	<select id="EXPERDBMA_BT_HCHK_MEMUSAGE_001" parameterType="hashmap" resultType="hashmap">
   SELECT /* EXPERDBMA_BT_HCHK_MEMUSAGE_001 */
         RCM.INSTANCE_ID,
         /*ROUND((MEM.SWP_USED_KB - MEM.SWP_CACHED_KB) / SWP_TOTAL_KB * 100, 2) AS SWAPUSAGE,*/
         CASE WHEN MEM.MEM_TOTAL_KB != 0 THEN (((MEM.MEM_TOTAL_KB - (MEM.MEM_FREE_KB +MEM.MEM_BUFFERED_KB + MEM.MEM_CACHED_KB)) / MEM.MEM_TOTAL_KB ) * 100)::int ELSE MEM.MEM_TOTAL_KB END AS MEMUSAGE,
         '3' AS COLLECT_GROUP,
         MEM.REG_DATE AS COLLECT_REG_DATE,
         MEM.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
  FROM TB_RSC_COLLECT_INFO AS RCM,
          TB_INSTANCE_INFO  AS IST,
          TB_MEMORY_STAT MEM
WHERE MEM.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND MEM.REG_DATE = RCM.REG_DATE
   AND MEM.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND MEM.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N';
	</select>
	<select id="EXPERDBMA_BT_HCHK_SWAPUSAGE_001" parameterType="hashmap" resultType="hashmap">
   SELECT /* EXPERDBMA_BT_HCHK_SWAPUSAGE_001 */
         RCM.INSTANCE_ID,
         /*ROUND((MEM.SWP_USED_KB - MEM.SWP_CACHED_KB) / SWP_TOTAL_KB * 100, 2) AS SWAPUSAGE,*/
         CASE WHEN SWP_TOTAL_KB=0 THEN 0 ELSE ROUND((MEM.SWP_USED_KB - MEM.SWP_CACHED_KB) / SWP_TOTAL_KB * 100, 2) END AS SWAPUSAGE,
         '3' AS COLLECT_GROUP,
         MEM.REG_DATE AS COLLECT_REG_DATE,
         MEM.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
         CURRENT_TIME AS REG_TIME 	
  FROM TB_RSC_COLLECT_INFO AS RCM,
          TB_INSTANCE_INFO  AS IST,
          TB_MEMORY_STAT MEM
WHERE MEM.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
   AND MEM.REG_DATE = RCM.REG_DATE
   AND MEM.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
   AND MEM.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
	AND IST.COLLECT_YN = 'Y'             
   AND IST.DELETE_YN='N';
	</select>
	
<select id="EXPERDBMA_BT_HCHK_REPLICATIONDELAY_001" parameterType="hashmap" resultType="hashmap">
   	SELECT /* EXPERDBMA_BT_HCHK_REPLICATIONDELAY_001 */
             B.REPL_INSTANCE_ID INSTANCE_ID,
             (B.REPLAY_LAG_SIZE / 1024 / 1024) AS REPLICATION_DELAY,
             '4' AS COLLECT_GROUP,
             B.REG_DATE AS COLLECT_REG_DATE,
			 B.REPL_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
             CURRENT_TIME AS REG_TIME
          FROM TB_INSTANCE_INFO A, TB_REPLICATION_LAG_INFO B
          WHERE B.REG_DATE = TO_char(now(), 'YYYYMMDD')
            AND B.REPL_REG_SEQ = (SELECT MAX(X.REPL_REG_SEQ) RSC_REG_SEQ FROM TB_REPLICATION_LAG_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.REPL_INSTANCE_ID=A.INSTANCE_ID )
            AND A.INSTANCE_ID = B.REPL_INSTANCE_ID
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
</select>
<select id="EXPERDBMA_BT_HCHK_REPLICATIONDELAY_001_20191021" parameterType="hashmap" resultType="hashmap">
   	SELECT /* EXPERDBMA_BT_HCHK_REPLICATIONDELAY_001 */
             B.INSTANCE_ID,
             (B.REPLAY_LAG_SIZE / 1024 / 1024) AS REPLICATION_DELAY,
             '4' AS COLLECT_GROUP,
             B.REG_DATE AS COLLECT_REG_DATE,
			 B.REPL_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
             CURRENT_TIME AS REG_TIME
          FROM TB_INSTANCE_INFO A, TB_REPLICATION_LAG_INFO B
          WHERE B.REG_DATE = TO_char(now(), 'YYYYMMDD')
            AND B.REPL_REG_SEQ = (SELECT MAX(X.REPL_REG_SEQ) RSC_REG_SEQ FROM TB_REPLICATION_LAG_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=A.INSTANCE_ID )
            AND A.INSTANCE_ID = B.INSTANCE_ID
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_REPLICATIONSLOT_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
  SELECT /* EXPERDBMA_BT_HCHK_REPLICATIONSLOT_001 */
         INSTANCE_ID,
         MAX(REPLICATION_SLOT) REPLICATION_SLOT,
         MAX(COLLECT_GROUP) COLLECT_GROUP,
         MAX(COLLECT_REG_DATE) COLLECT_REG_DATE,
		 MAX(COLLECT_REG_SEQ) COLLECT_REG_SEQ,
         MAX(REG_TIME) REG_TIME
	FROM (
			WITH MAX_SEQ AS (SELECT MAX(X.REPL_REG_SEQ) RSC_REG_SEQ, INSTANCE_ID FROM TB_REPLICATION_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') GROUP BY X.INSTANCE_ID )
		    SELECT   B.INSTANCE_ID,
		             CASE WHEN min(B.ACTIVE::integer) = 1 THEN 0
		             	  ELSE 1 END REPLICATION_SLOT,
		             '4' AS COLLECT_GROUP,
		             MAX(B.REG_DATE) AS COLLECT_REG_DATE,
					 MAX(B.REPL_REG_SEQ)::VARCHAR AS COLLECT_REG_SEQ,
		             CURRENT_TIME AS REG_TIME
		          FROM TB_INSTANCE_INFO A, TB_REPLICATION_SLOTS B
		          WHERE B.REG_DATE = TO_char(now(), 'YYYYMMDD')
		            AND B.REPL_REG_SEQ = (SELECT RSC_REG_SEQ FROM MAX_SEQ X WHERE X.INSTANCE_ID=A.INSTANCE_ID )
		            AND A.INSTANCE_ID = B.INSTANCE_ID
		            AND A.COLLECT_YN = 'Y'
		            AND A.DELETE_YN = 'N'
		            AND B.RESTART_LSN IS NOT NULL
		            AND B.SLOT_NAME <> 'wal_keep_slot' -- except alert to retend wal for replication node
				  GROUP BY B.INSTANCE_ID
			UNION 
				(
					WITH 
				    VS AS (
						  SELECT instance_id, slot_name FROM TB_replication_slots  
						   WHERE REG_DATE = TO_char(CURRENT_TIMESTAMP, 'YYYYMMDD')
							 AND REPL_REG_SEQ in (SELECT MAX(X.REPL_REG_SEQ) RSC_REG_SEQ FROM TB_REPLICATION_slots X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') GROUP BY instance_id)
						 )
					SELECT B.INSTANCE_ID,
						   CASE WHEN B.SLOT_NAME IS NULL THEN 2 ELSE 0 END REPLICATION_SLOT,
			               '5' AS COLLECT_GROUP,
			               B.REG_DATE AS COLLECT_REG_DATE,
						   B.REPL_REG_SEQ::varchar COLLECT_REG_SEQ,
						   CURRENT_TIME AS REG_TIME
						   --VS.instance_id
			          FROM TB_INSTANCE_INFO A JOIN TB_REPLICATION_INFO B ON A.INSTANCE_ID = B.INSTANCE_ID LEFT OUTER JOIN VS ON A.HA_GROUP = VS.instance_id AND b.SLOT_NAME = vs.slot_name
			          WHERE A.COLLECT_YN = 'Y'
			            AND B.IS_COLLECT_OK = 'Y'
			            AND A.DELETE_YN = 'N'
			            AND B.REG_DATE = TO_char(now(), 'YYYYMMDD')
			            AND A.HA_ROLE = 'S'
			            AND B.REPL_REG_SEQ IN (SELECT MAX(REPL_REG_SEQ) REPL FROM TB_REPLICATION_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND IS_COLLECT_OK = 'Y' GROUP BY INSTANCE_ID)
			            AND B.SLOT_NAME <> 'wal_keep_slot' -- except alert to retend wal for replication node  
		            )
		    ) AS HSOT     
    GROUP BY INSTANCE_ID
        ]]>  
	</select>
	<select id="EXPERDBMA_BT_HCHK_VIRTUALIP_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		SELECT /* EXPERDBMA_BT_HCHK_VIRTUALIP_001 */
			   I.INSTANCE_ID,
			   CASE WHEN VIRTUAL_IP_STAT = 0 THEN 1 
			   ELSE CASE WHEN R.HA_ROLE = 'P' AND VIRTUAL_IP IS NULL THEN 2
		  		 		 WHEN R.HA_ROLE = 'S' AND VIRTUAL_IP IS NOT NULL THEN 2 
					ELSE 0 END
			   END AS VIRTUAL_IP,
			   '4' AS COLLECT_GROUP,
	           TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') AS COLLECT_REG_DATE,
			   -1 AS COLLECT_REG_SEQ,	
	           CURRENT_TIME AS REG_TIME	
		    FROM TB_INSTANCE_INFO I, TB_REPLICATION_INFO R
		   WHERE COLLECT_YN = 'Y'
             AND DELETE_YN = 'N'
             AND I.HA_GROUP IN (SELECT HA_GROUP FROM TB_INSTANCE_INFO WHERE VIRTUAL_IP IS NOT NULL)
             AND I.INSTANCE_ID = R.INSTANCE_ID
             AND R.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
             AND R.REPL_REG_SEQ IN (SELECT MAX(REPL_REG_SEQ) AS MAX_REG_SEQ 
								 	  FROM TB_REPLICATION_INFO  
								 	 WHERE REG_DATE    = TO_CHAR(NOW(), 'YYYYMMDD')
								 	 GROUP BY INSTANCE_ID )
		]]>  
	</select>
		<select id="EXPERDBMA_BT_HCHK_VIRTUALIP_001_PREV" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		SELECT /* EXPERDBMA_BT_HCHK_VIRTUALIP_001 */
			   I.INSTANCE_ID,
		  	   CASE WHEN R.HA_ROLE = 'P' AND VIRTUAL_IP IS NULL THEN 1
		  		 	WHEN R.HA_ROLE = 'S' AND VIRTUAL_IP IS NOT NULL THEN 1 
		  		 	ELSE 0 END AS VIRTUAL_IP,
		  	   '4' AS COLLECT_GROUP,
	           TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') AS COLLECT_REG_DATE,
			   -1 AS COLLECT_REG_SEQ,	
	           CURRENT_TIME AS REG_TIME	
		    FROM TB_INSTANCE_INFO I, TB_REPLICATION_INFO R
		   WHERE COLLECT_YN = 'Y'
             AND DELETE_YN = 'N'
             AND I.HA_GROUP IN (SELECT HA_GROUP FROM TB_INSTANCE_INFO WHERE VIRTUAL_IP IS NOT NULL)
             AND I.INSTANCE_ID = R.INSTANCE_ID
             AND R.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
             AND R.REPL_REG_SEQ IN (SELECT MAX(REPL_REG_SEQ) AS MAX_REG_SEQ 
								 	  FROM TB_REPLICATION_INFO  
								 	 WHERE REG_DATE    = TO_CHAR(NOW(), 'YYYYMMDD')
								 	 GROUP BY INSTANCE_ID )
		]]>  
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_WALCNT_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		WITH MAXSEQ AS (
			SELECT INSTANCE_ID, MAX(REPL_REG_SEQ) REPL_REG_SEQ FROM TB_WAL_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') GROUP BY INSTANCE_ID
		)
		 SELECT /* EXPERDBMA_BT_HCHK_WALCNT_001 */
		         W.INSTANCE_ID,
		         MAX(WAL_COUNT) AS WALCNT,
		         '2' AS COLLECT_GROUP,
		         W.REG_DATE AS COLLECT_REG_DATE,
		         W.REPL_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
		         CURRENT_TIME AS REG_TIME
		  FROM TB_WAL_INFO AS W,
		       TB_INSTANCE_INFO AS I       
		WHERE W.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
		   AND W.REPL_REG_SEQ = (SELECT REPL_REG_SEQ FROM MAXSEQ WHERE INSTANCE_ID=I.INSTANCE_ID)
		   AND I.INSTANCE_ID = W.INSTANCE_ID   
		   AND I.COLLECT_YN = 'Y'             
		   AND I.DELETE_YN='N'
		   AND W.COLLECT_DT > now() - ((SELECT HCHK_PERIOD_SEC * 10 FROM TB_CONFIG)::varchar || ' sec')::interval
		GROUP BY W.REG_DATE,W.REPL_REG_SEQ,W.INSTANCE_ID
		]]>  
	</select>
<!-- ********************************************************** -->
<!-- HchkCollect END -->
<!-- ********************************************************** -->



<!-- ********************************************************** -->
<!-- StartCollect START -->
<!-- ********************************************************** -->
	<select id="EXPERDBMA_BT_UPTIME_MAXCONN_001" parameterType="hashmap" resultType="hashmap"  flushCache="true">
		 SELECT /* EXPERDBMA_BT_UPTIME_MAXCONN_001 24e9ab7301ff1966da4fb30dc1538882 */
		        PG_POSTMASTER_START_TIME() AS INSTANCE_UPTIME, 
		        SETTING AS MAX_CONN_CNT, 
		        GET_CPU_CLOCKS() AS CPU_CLOCKS, 
		        GET_HOSTNAME() AS HOST_NAME,
		        VERSION() AS PG_VERSION,
		        (SELECT setting::int4 FROM pg_settings WHERE name = 'autovacuum_freeze_max_age' ) AS AFMA
		  FROM PG_SETTINGS 
		  WHERE NAME='max_connections'
	</select>
<!--	add to update ha_info by robin 201712  -->
	<select id="EXPERDBMA_BT_UPTIME_MAXCONN_002" parameterType="hashmap" resultType="hashmap"  flushCache="true">
		<choose>
			<when test="instance_db_version >= 10.0">
				<![CDATA[
					 SELECT /* EXPERDBMA_BT_UPTIME_MAXCONN_002 24e9ab7301ff1966da4fb30dc1538882 */
					        PG_POSTMASTER_START_TIME() AS INSTANCE_UPTIME, 
					        SETTING AS MAX_CONN_CNT, 
					        GET_CPU_CLOCKS() AS CPU_CLOCKS, 
					        GET_HOSTNAME() AS HOST_NAME,
					        VERSION() AS PG_VERSION,
					  		CASE WHEN pg_is_in_recovery() THEN 'S' ELSE (CASE WHEN (SELECT COUNT(*) FROM PG_STAT_REPLICATION) <= 0 THEN 'A' ELSE 'P' END) END AS HA_ROLE, 
					        CASE WHEN pg_is_in_recovery() THEN 
								TRIM(BOTH FROM COALESCE((SELECT substring(ARR_COL, length('host=')+1) FROM 
									(SELECT regexp_split_to_table(conninfo, E'\\s+') ARR_COL 
								   	   FROM pg_stat_wal_receiver) ARR 
							  	  WHERE ARR_COL LIKE 'host=%' 
							  	  ORDER BY arr_col), '-'), '''') ELSE '-' END AS HA_HOST, 
					        CASE WHEN pg_is_in_recovery() THEN 
								COALESCE((SELECT substring(ARR_COL, length('port=')+1) FROM 
									(SELECT regexp_split_to_table(conninfo, E'\\s+') ARR_COL 
								   		FROM pg_stat_wal_receiver) ARR2 
							  	  WHERE ARR_COL LIKE 'port=%' 
							  	  ORDER BY arr_col), '-') ELSE '0' END AS HA_PORT,
						    CASE WHEN pg_is_in_recovery() THEN 
									(SELECT slot_name FROM pg_stat_wal_receiver)									
						  	     ELSE '-' END AS SLOT_NAME,						    
							CASE WHEN pg_is_in_recovery() THEN 
								CASE WHEN pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() THEN 0
								     ELSE EXTRACT (EPOCH FROM now() - #{start_delay}::timestamp) END
							ELSE '0' END AS REPLAY_LAG,
							CASE WHEN pg_is_in_recovery() THEN 
								CASE WHEN pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() THEN 0
								     ELSE pg_last_wal_receive_lsn() - pg_last_wal_replay_lsn() END
							ELSE '0' END AS REPLAY_LAG_SIZE,
							(SELECT setting::int4 FROM pg_settings WHERE name = 'autovacuum_freeze_max_age' ) AS AFMA
					  FROM PG_SETTINGS 
					 WHERE NAME='max_connections'
					 ]]>
			</when>
			<when test="instance_db_version >= 9.6">
				<![CDATA[
					 SELECT /* EXPERDBMA_BT_UPTIME_MAXCONN_002 24e9ab7301ff1966da4fb30dc1538882 */
					        PG_POSTMASTER_START_TIME() AS INSTANCE_UPTIME, 
					        SETTING AS MAX_CONN_CNT, 
					        GET_CPU_CLOCKS() AS CPU_CLOCKS, 
					        GET_HOSTNAME() AS HOST_NAME,
					        VERSION() AS PG_VERSION,
					  		CASE WHEN pg_is_in_recovery() THEN 'S' ELSE (CASE WHEN (SELECT COUNT(*) FROM PG_STAT_REPLICATION) <= 0 THEN 'A' ELSE 'P' END) END AS HA_ROLE, 
					        CASE WHEN pg_is_in_recovery() THEN 
								COALESCE((SELECT substring(ARR_COL, length('host=')+1) FROM 
									(SELECT regexp_split_to_table(conninfo, E'\\s+') ARR_COL 
								   	   FROM pg_stat_wal_receiver) ARR 
							  	  WHERE ARR_COL LIKE 'host=%' 
							  	  ORDER BY arr_col), '-') ELSE '-' END AS HA_HOST, 
					        CASE WHEN pg_is_in_recovery() THEN 
								COALESCE((SELECT substring(ARR_COL, length('port=')+1) FROM 
									(SELECT regexp_split_to_table(conninfo, E'\\s+') ARR_COL 
								   		FROM pg_stat_wal_receiver) ARR2 
							  	  WHERE ARR_COL LIKE 'port=%' 
							  	  ORDER BY arr_col), '-') ELSE '0' END AS HA_PORT,
						    CASE WHEN pg_is_in_recovery() THEN 
									(SELECT slot_name FROM pg_stat_wal_receiver)									
						  	     ELSE '-' END AS SLOT_NAME,						    
							CASE WHEN pg_is_in_recovery() THEN 
								CASE WHEN pg_last_xlog_receive_location() = pg_last_xlog_replay_location() THEN 0
								     ELSE EXTRACT (EPOCH FROM now() - #{start_delay}::timestamp) END
							 ELSE '0' END AS REPLAY_LAG,		
							CASE WHEN pg_is_in_recovery() THEN 
								CASE WHEN pg_last_xlog_receive_location() = pg_last_xlog_replay_location() THEN 0
								     ELSE pg_last_xlog_receive_location() - pg_last_xlog_replay_location() END
							 ELSE '0' END AS REPLAY_LAG_SIZE,
							(SELECT setting::int4 FROM pg_settings WHERE name = 'autovacuum_freeze_max_age' ) AS AFMA		
					  FROM PG_SETTINGS 
					 WHERE NAME='max_connections'
					 ]]>
			</when>
			<otherwise>
			<![CDATA[
					 SELECT /* EXPERDBMA_BT_UPTIME_MAXCONN_002 24e9ab7301ff1966da4fb30dc1538882 */
					        PG_POSTMASTER_START_TIME() AS INSTANCE_UPTIME, 
					        SETTING AS MAX_CONN_CNT, 
					        GET_CPU_CLOCKS() AS CPU_CLOCKS, 
					        GET_HOSTNAME() AS HOST_NAME,
					        VERSION() AS PG_VERSION,
					  		CASE WHEN pg_is_in_recovery() THEN 'S' ELSE (CASE WHEN (SELECT COUNT(*) FROM PG_STAT_REPLICATION) <= 0 THEN 'A' ELSE 'P' END) END AS HA_ROLE, 
							CASE WHEN pg_is_in_recovery() THEN 
								TRIM(BOTH FROM COALESCE((SELECT SUBSTRING(ARR_COL, length('host=')+1) FROM 
									(SELECT regexp_split_to_table(pg_read_file('recovery.conf', 0, 1000), E'\\s+') ARR_COL) ARR
								      WHERE ARR_COL LIKE 'host=%' 
								      ORDER BY arr_col), '-'), '''') ELSE '-' END AS HA_HOST,  
							CASE WHEN pg_is_in_recovery() THEN 
								COALESCE((SELECT substring(ARR_COL, length('port=')+1) FROM 
									(SELECT regexp_split_to_table(pg_read_file('recovery.conf', 0, 1000), E'\\s+') ARR_COL) ARR2
								  	  WHERE ARR_COL LIKE 'port=%' 
								  	  ORDER BY arr_col), '-') ELSE '0' END AS HA_PORT,
							CASE WHEN pg_is_in_recovery() THEN 
									  CASE WHEN pg_last_xlog_receive_location() = pg_last_xlog_replay_location() THEN 0
									     ELSE EXTRACT (EPOCH FROM now() - #{start_delay}::timestamp) END
								 ELSE '0' END AS REPLAY_LAG,	
							CASE WHEN pg_is_in_recovery() THEN 
									  CASE WHEN pg_last_xlog_receive_location() = pg_last_xlog_replay_location() THEN 0
									     ELSE pg_last_xlog_receive_location() - pg_last_xlog_replay_location() END
								 ELSE '0' END AS REPLAY_LAG_SIZE,
							(SELECT setting::int4 FROM pg_settings WHERE name = 'autovacuum_freeze_max_age' ) AS AFMA
					   FROM PG_SETTINGS 
					   WHERE NAME='max_connections'					   
					]]>
			</otherwise>
		</choose>
	</select>
	<select id="EXPERDBMA_BT_CHECK_VIP_001" parameterType="hashmap" resultType="hashmap"  flushCache="true">
		 SELECT /* EXPERDBMA_BT_CHECK_VIP_001 24e9ab7301ff1966da4fb30dc1538882 */
		        GET_HOSTNAME() AS HOST_NAME
	</select>
	<select id="EXPERDBMA_BT_REPLICATION_LAG" parameterType="hashmap" resultType="hashmap"  flushCache="true">
		<choose>
			<when test="instance_db_version >= 10.0">
				<![CDATA[
					 SELECT /* EXPERDBMA_BT_REPLICATION_LAG 24e9ab7301ff1966da4fb30dc1538882 */
					 		--COALESCE(client_hostname, application_name) AS HOST_NAME,
					 		APPLICATION_NAME AS HOST_NAME,
							--CASE WHEN pg_is_in_recovery() = FALSE THEN  
							CASE WHEN true THEN
								      EXTRACT(epoch FROM replay_lag) 
								      --EXTRACT(epoch FROM COALESCE(replay_lag, '0'::interval)) 
								 ELSE -1 END AS REPLAY_LAG,
							--CASE WHEN pg_is_in_recovery() = FALSE THEN  
							CASE WHEN true THEN  
									  sent_lsn - replay_lsn
								 ELSE -1 END AS REPLAY_LAG_SIZE
					   FROM PG_STAT_REPLICATION;
					 ]]>
			</when>
			<otherwise>
			<![CDATA[
					 SELECT /* EXPERDBMA_BT_UPTIME_MAXCONN_002 24e9ab7301ff1966da4fb30dc1538882 */
					        GET_HOSTNAME() AS HOST_NAME,
							CASE WHEN pg_is_in_recovery() THEN 
								CASE WHEN pg_last_xlog_receive_location() = pg_last_xlog_replay_location() THEN 0
								     ELSE EXTRACT (EPOCH FROM now() - pg_last_xact_replay_timestamp()) END
							 ELSE '0' END AS REPLAY_LAG,		
							CASE WHEN pg_is_in_recovery() THEN 
								CASE WHEN pg_last_xlog_receive_location() = pg_last_xlog_replay_location() THEN 0
								     ELSE pg_last_xlog_receive_location() - pg_last_xlog_replay_location() END
							 ELSE '0' END AS REPLAY_LAG_SIZE		
					  FROM PG_SETTINGS 
					 WHERE NAME='max_connections'
					]]>
			</otherwise>
		</choose>
	</select>
    <select id="EXPERDBMA_BT_REPLICATION_SLOT" parameterType="hashmap" resultType="hashmap"  flushCache="true">
            <choose>
            <when test="instance_db_version >= 10.0">
                <![CDATA[
                    SELECT /* EXPERDBMA_BT_REPLICATION_SLOT 24e9ab7301ff1966da4fb30dc1538882 */
                        CASE WHEN R.client_hostname IS NULL
                                THEN R.application_name
                                ELSE R.client_hostname END slave_hostname,
                           S.slot_name, S.plugin, S.slot_type, S.datoid, S.temporary, S.active, S.xmin, S.restart_lsn, S.confirmed_flush_lsn
                      FROM pg_replication_slots S LEFT OUTER JOIN pg_stat_replication R ON S.active_pid = R.pid;
                  ]]>
             </when>
            <otherwise>
              <![CDATA[
                    SELECT /* EXPERDBMA_BT_REPLICATION_SLOT 24e9ab7301ff1966da4fb30dc1538882 */
                        CASE WHEN R.client_hostname IS NULL
                                THEN R.application_name
                                ELSE R.client_hostname END slave_hostname,
                           S.slot_name, S.plugin, S.slot_type, S.datoid, false as temporary, S.active, S.xmin, S.restart_lsn, S.confirmed_flush_lsn
                      FROM pg_replication_slots S LEFT OUTER JOIN pg_stat_replication R ON S.active_pid = R.pid;
                  ]]>
            </otherwise>
            </choose>
    </select>
	<select id="EXPERDBMA_BT_GET_PGVERSION_001" parameterType="hashmap" resultType="hashmap"  flushCache="true">
		       SELECT /* EXPERDBMA_BT_GET_PGVERSION_001 24e9ab7301ff1966da4fb30dc1538882 */ 
		       		SPLIT_PART(SPLIT_PART(VERSION(), ' ', 2), '.', 1)  || '.' || SPLIT_PART(SPLIT_PART(VERSION(), ' ', 2), '.', 2) AS pg_version;
	</select>
<!--	add to update ha_info by robin 201712  end -->
	<update id="TB_INSTANCE_INFO_U001" parameterType="hashmap" >
		UPDATE TB_INSTANCE_INFO 
		   SET INSTANCE_UPTIME = #{instance_uptime}, 
			   MAX_CONN_CNT = #{max_conn_cnt},
			   CPU_CLOCKS = #{cpu_clocks},
			   HOST_NAME = #{host_name},
			   PG_VERSION = #{pg_version},
			   AFMA = #{afma}
		 WHERE INSTANCE_ID=#{instance_id}
	</update>
	<update id="TB_INSTANCE_INFO_U002" parameterType="hashmap" >
		UPDATE TB_INSTANCE_INFO 
		   SET INSTANCE_UPTIME = #{instance_uptime}, 
			   MAX_CONN_CNT = #{max_conn_cnt},
			   CPU_CLOCKS = #{cpu_clocks},
			   HOST_NAME = #{host_name},
			   PG_VERSION = #{pg_version},
			   HA_GROUP = #{ha_group},
			   EXTENSIONS = #{extensions},
			   AFMA = #{afma}
		 WHERE INSTANCE_ID=#{instance_id}
	</update>
	<update id="TB_INSTANCE_INFO_U003" parameterType="hashmap" >
		UPDATE TB_INSTANCE_INFO 
		   SET VIRTUAL_IP = (CASE WHEN host_name = #{host_name} THEN #{virtual_ip} ELSE NULL END), 
		       VIRTUAL_IP_STAT = (CASE WHEN host_name = #{host_name} THEN #{virtual_ip_stat} ELSE NULL END)  
		 WHERE ha_group = #{ha_group} ;
	</update>
	<update id="TB_INSTANCE_INFO_U004" parameterType="hashmap" >
		UPDATE TB_INSTANCE_INFO 
		   SET VIRTUAL_IP2 = (CASE WHEN host_name = #{host_name} THEN #{virtual_ip2} ELSE NULL END) 
		 WHERE ha_group = #{ha_group} ;
	</update>
	<select id="EXPERDBMA_BT_GET_PGUSER_001" parameterType="hashmap" resultType="hashmap"  flushCache="true">
       SELECT /* EXPERDBMA_BT_GET_PGUSER_001 24e9ab7301ff1966da4fb30dc1538882 */ 
       		  USENAME AS USER_NAME, USESYSID AS USER_ID FROM PG_USER;
	</select>
	<insert id="TB_PGUSER_I001" parameterType="hashmap" >
		INSERT INTO TB_USER_INFO
		(	
			REG_DATE,
			COLLECT_DT,
			INSTANCE_ID,
			USER_NAME,
			USER_ID
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			NOW(),
			#{instance_id},
			#{user_name},			
			#{user_id}
		)
	</insert>
	
	<insert id="TB_PGUSER_I002" parameterType="hashmap" >
		WITH UPSERT AS (
		UPDATE TB_USER_INFO U
		   SET USER_NAME = #{user_name},
		       COLLECT_DT = NOW(),
		       REG_DATE = TO_CHAR(now(), 'YYYYMMDD')
		 WHERE U.INSTANCE_ID = #{instance_id}
		   AND U.USER_ID = #{user_id}
		RETURNING *)
		INSERT INTO TB_USER_INFO (REG_DATE, COLLECT_DT, INSTANCE_ID, USER_ID, USER_NAME)
		SELECT TO_CHAR(now(), 'YYYYMMDD'), NOW(), #{instance_id}, #{user_id}, #{user_name} 
		 WHERE NOT EXISTS(SELECT 1 FROM UPSERT);
	</insert>
		
	<select id="EXPERDBMA_BT_GET_PGDATABASE_001" parameterType="hashmap" resultType="hashmap"  flushCache="true">
		       SELECT /* EXPERDBMA_BT_GET_PGDATABASE_001 24e9ab7301ff1966da4fb30dc1538882 */ 
		       		  DATNAME AS DATABASE_NAME, DATID
		         FROM pg_stat_database
				WHERE datname NOT IN ('template0', 'template1');
	</select>	
	<insert id="TB_PGDATABASE_I001" parameterType="hashmap" >
		INSERT INTO TB_DATABASE_INFO
		(	
			REG_DATE,
			COLLECT_DT,
			INSTANCE_ID,
			DATABASE_NAME,
			DATID
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			NOW(),
			#{instance_id},
			#{database_name},			
			#{datid}
		)
	</insert>
	
	<insert id="TB_PGDATABASE_I002" parameterType="hashmap" >
		WITH UPSERT AS (
		UPDATE TB_DATABASE_INFO D
		   SET DATABASE_NAME = #{database_name},
		       COLLECT_DT = NOW(),
		       REG_DATE = TO_CHAR(now(), 'YYYYMMDD')
		 WHERE D.INSTANCE_ID = #{instance_id}
		   AND D.DATID = #{datid}
		RETURNING *)
		INSERT INTO TB_DATABASE_INFO (REG_DATE, COLLECT_DT, INSTANCE_ID, DATID, DATABASE_NAME)
		SELECT TO_CHAR(now(), 'YYYYMMDD'), NOW(), #{instance_id}, #{datid}, #{database_name} 
		 WHERE NOT EXISTS(SELECT 1 FROM UPSERT);
	</insert>

<!-- ********************************************************** -->
<!-- DailyBatchTask START -->
<!-- ********************************************************** -->
	<insert id="TB_SYS_LOG_I001" parameterType="hashmap">
		INSERT INTO TB_SYS_LOG (REG_DATE, TASK_CD, START_DT, STATUS)
		VALUES 
		(
			#{reg_date},
			'2',
			NOW(),
			'1'
		);
	</insert>

	<update id="TB_SYS_LOG_U001" parameterType="hashmap">
		UPDATE TB_SYS_LOG 
		   SET STATUS = #{status}, 
			   END_DT = NOW(),
			   COMMENTS = #{comments}
		 WHERE REG_DATE=#{reg_date}
		   AND TASK_CD='2';
	</update>



	<delete id="PGMONBT_BATCH_ACTV_COLLECT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_ACTV_COLLECT_INFO_001 */ FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_ACTV_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_CURRENT_LOCK_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_CURRENT_LOCK_001 */ FROM TB_CURRENT_LOCK      WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_ACTV_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_BACKEND_RSC_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_BACKEND_RSC_001 */ FROM TB_BACKEND_RSC       WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_ACTV_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_ACCESS_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_ACCESS_INFO_001 */ FROM TB_ACCESS_INFO       WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_ACTV_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
		
	<delete id="PGMONBT_BATCH_OBJT_COLLECT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_OBJT_COLLECT_INFO_001 */ FROM TB_OBJT_COLLECT_INFO WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_OBJT_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_TABLESPACE_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_TABLESPACE_INFO_001 */ FROM TB_TABLESPACE_INFO   WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_OBJT_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_TABLE_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_TABLE_INFO_001 */ FROM TB_TABLE_INFO        WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_OBJT_COLLECT_INFO) - 1, 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_TABLE_INFO_001_ORG" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_TABLE_INFO_001 */ FROM TB_TABLE_INFO        WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_OBJT_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_INDEX_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_INDEX_INFO_001 */ FROM TB_INDEX_INFO        WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_OBJT_COLLECT_INFO) - 1, 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_INDEX_INFO_001_ORG" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_INDEX_INFO_001 */ FROM TB_INDEX_INFO        WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_OBJT_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	
	<delete id="PGMONBT_BATCH_RSC_COLLECT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_RSC_COLLECT_INFO_001 */ FROM TB_RSC_COLLECT_INFO  WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_RSC_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_MEMORY_STAT_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_MEMORY_STAT_001 */ FROM TB_MEMORY_STAT       WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_RSC_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_CPU_STAT_MASTER_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_CPU_STAT_MASTER_001 */ FROM TB_CPU_STAT_MASTER   WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_RSC_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_CPU_STAT_DETAIL_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_CPU_STAT_DETAIL_001 */ FROM TB_CPU_STAT_DETAIL   WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_RSC_COLLECT_INFO) - 1, 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_CPU_STAT_DETAIL_001_ORG" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_CPU_STAT_DETAIL_001 */ FROM TB_CPU_STAT_DETAIL   WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_RSC_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_DISK_IO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_DISK_IO_001 */ FROM TB_DISK_IO           WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_RSC_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_DISK_USAGE_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_DISK_USAGE_001 */ FROM TB_DISK_USAGE        WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_RSC_COLLECT_INFO) - 1, 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_DISK_USAGE_001_ORG" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_DISK_USAGE_001 */ FROM TB_DISK_USAGE        WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_RSC_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	
	<delete id="PGMONBT_BATCH_HCHK_COLLECT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_HCHK_COLLECT_INFO_001 */ FROM TB_HCHK_COLLECT_INFO WHERE REG_DATE <= TO_CHAR( (SELECT MAX(REG_DATE)::DATE FROM TB_HCHK_COLLECT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>

	<delete id="PGMONBT_BATCH_REPL_SLOTS_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_REPL_SLOTS_001 */ FROM TB_REPLICATION_SLOTS WHERE COLLECT_DT < (now() - INTERVAL '1 hour');
		]]>	
	</delete>
	
<!-- ********************************************************** -->
<!-- for Alert Start-->
<!-- ********************************************************** -->
	<delete id="PGMONTB_BATCH_CONTROL_PROCESS_HIST_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONTB_BATCH_CONTROL_PROCESS_HIST_001 */ FROM TB_CONTROL_PROCESS_HIST WHERE REG_DATE <= TO_CHAR((SELECT MAX(REG_DATE)::DATE FROM TB_CONTROL_PROCESS_HIST) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	<delete id="PGMONTB_BATCH_HCHK_ALERT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONTB_BATCH_HCHK_ALERT_INFO_I001 */ FROM TB_HCHK_ALERT_INFO WHERE REG_DATE <= TO_CHAR((SELECT MAX(REG_DATE)::DATE FROM TB_HCHK_ALERT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	
<!-- ********************************************************** -->
<!-- for Alert Start-->
<!-- ********************************************************** -->

<!-- ********************************************************** -->
<!-- for Replication Start-->
<!-- ********************************************************** -->
	<delete id="PGMONTB_BATCH_REPLICATION_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONTB_BATCH_REPLICATION_INFO_001 */ FROM TB_REPLICATION_INFO WHERE REG_DATE <= TO_CHAR((SELECT MAX(REG_DATE)::DATE FROM TB_REPLICATION_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	
<!-- ********************************************************** -->
<!-- ********************************************************** -->
<!-- for checkpoint Start-->
<!-- ********************************************************** -->
	<delete id="PGMONTB_BATCH_CHECKPOINT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONTB_BATCH_CHECKPOINT_INFO_001 */ FROM TB_CHECKPOINT_INFO WHERE REG_DATE <= TO_CHAR((SELECT MAX(REG_DATE)::DATE FROM TB_CHECKPOINT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	
<!-- ********************************************************** -->
<!-- Additional tables-->
<!-- ********************************************************** -->
	<delete id="PGMONTB_BATCH_QEURY_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONTB_BATCH_QEURY_INFO_001 */ FROM TB_QUERY_INFO WHERE To_char(COLLECT_DT::DATE, 'YYYYMMDD') <= TO_CHAR((SELECT MAX(COLLECT_DT)::DATE FROM TB_QUERY_INFO)-(SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	
	<delete id="PGMONTB_BATCH_PG_STAT_STATEMENT_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONTB_BATCH_PG_STAT_STATEMENT_001 */ FROM TB_PG_STAT_STATEMENTS WHERE REG_DATE <= TO_CHAR((SELECT MAX(REG_DATE)::DATE FROM TB_PG_STAT_STATEMENTS) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1), 'YYYYMMDD');
		]]>	
	</delete>
	
	<delete id="PGMONBT_BATCH_TABLE_EXT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_TABLE_EXT_INFO_001 */ FROM TB_TABLE_EXT_INFO WHERE COLLECT_DT::DATE <= (SELECT COALESCE(MAX(COLLECT_DT)::DATE, now()::date) FROM TB_TABLE_EXT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1);
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_TB_USER_INFO_001" parameterType="hashmap" >
		<![CDATA[
		/*DELETE /* PGMONBT_BATCH_TB_USER_INFO_001 */ FROM TB_USER_INFO WHERE COLLECT_DT::DATE <= (SELECT COALESCE(MAX(COLLECT_DT)::DATE, now()::date) FROM TB_USER_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1);*/
		DELETE /* PGMONBT_BATCH_TB_USER_INFO_001 */ FROM TB_USER_INFO WHERE COLLECT_DT::DATE <= (SELECT COALESCE(MAX(COLLECT_DT)::DATE, now()::date) FROM TB_USER_INFO) - 2;
		]]>	
	</delete>

	<delete id="PGMONBT_BATCH_TB_DATABASE_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_TB_DATABASE_INFO_001 */ FROM TB_DATABASE_INFO WHERE COLLECT_DT::DATE <= (SELECT COALESCE(MAX(COLLECT_DT)::DATE, now()::date) FROM TB_DATABASE_INFO) - 2;
		]]>	
	</delete>	
	
	<delete id="PGMONBT_BATCH_TB_ALERT_EXPORT_INFO_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_TB_ALERT_EXPORT_INFO_001 */ FROM TB_ALERT_EXPORT_INFO WHERE COLLECT_DT::DATE <= (SELECT COALESCE(MAX(COLLECT_DT)::DATE, now()::date) FROM TB_ALERT_EXPORT_INFO) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1);
		]]>	
	</delete>
	<delete id="PGMONBT_BATCH_TB_MON_USER_AUDIT_001" parameterType="hashmap" >
		<![CDATA[
		DELETE /* PGMONBT_BATCH_TB_MON_USER_AUDIT_001 */ FROM TB_MON_USER_AUDIT WHERE ACCESS_DT::DATE <= (SELECT COALESCE(MAX(ACCESS_DT)::DATE, now()::date) FROM TB_MON_USER_AUDIT) - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1);
		]]>	
	</delete>
	
	<update id="VACUUM_ANALYZE_U001" parameterType="hashmap" >
		vacuum analyze TB_INSTANCE_INFO    ;
	</update>
	<update id="VACUUM_ANALYZE_U002" parameterType="hashmap" >	
		vacuum analyze TB_ACTV_COLLECT_INFO;
	</update>
	<update id="VACUUM_ANALYZE_U003" parameterType="hashmap" >		
		vacuum analyze TB_CURRENT_LOCK     ;
	</update>
	<update id="VACUUM_ANALYZE_U006" parameterType="hashmap" >		
		vacuum analyze TB_BACKEND_RSC      ;
	</update>
	<update id="VACUUM_ANALYZE_U007" parameterType="hashmap" >		
		vacuum analyze TB_OBJT_COLLECT_INFO;
	</update>
	<update id="VACUUM_ANALYZE_U008" parameterType="hashmap" >		
		vacuum analyze TB_ACCESS_INFO      ;
	</update>
	<update id="VACUUM_ANALYZE_U009" parameterType="hashmap" >		
		vacuum analyze TB_TABLESPACE_INFO  ;
	</update>
	<update id="VACUUM_ANALYZE_U010" parameterType="hashmap" >		
		vacuum analyze TB_TABLE_INFO       ;
	</update>
	<update id="VACUUM_ANALYZE_U011" parameterType="hashmap" >		
		vacuum analyze TB_INDEX_INFO       ;
	</update>
	<update id="VACUUM_ANALYZE_U012" parameterType="hashmap" >		
		vacuum analyze TB_RSC_COLLECT_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_U013" parameterType="hashmap" >		
		vacuum analyze TB_MEMORY_STAT      ;
	</update>
	<update id="VACUUM_ANALYZE_U014" parameterType="hashmap" >		
		vacuum analyze TB_CPU_STAT_MASTER  ;
	</update>
	<update id="VACUUM_ANALYZE_U015" parameterType="hashmap" >		
		vacuum analyze TB_CPU_STAT_DETAIL  ;
	</update>
	<update id="VACUUM_ANALYZE_U016" parameterType="hashmap" >		
		vacuum analyze TB_DISK_IO          ;
	</update>
	<update id="VACUUM_ANALYZE_U017" parameterType="hashmap" >		
		vacuum analyze TB_DISK_USAGE       ;
	</update>
	<update id="VACUUM_ANALYZE_U018" parameterType="hashmap" >		
		vacuum analyze TB_HCHK_COLLECT_INFO;
	</update>
	<update id="VACUUM_ANALYZE_U019" parameterType="hashmap" >		
		vacuum analyze TB_HCHK_THRD_LIST   ;
	</update>
	<update id="VACUUM_ANALYZE_U020" parameterType="hashmap" >		
		vacuum analyze TB_CONFIG           ;
	</update>
	<update id="VACUUM_ANALYZE_U021" parameterType="hashmap" >		
		vacuum analyze TB_SYS_LOG          ;
	</update>
	<update id="VACUUM_ANALYZE_U022" parameterType="hashmap" >		
		vacuum analyze TB_GROUP_INFO       ;
	</update>
	<update id="VACUUM_ANALYZE_U023" parameterType="hashmap" >		
		vacuum analyze TB_HCHK_ALERT_INFO  ;
	</update>
	<update id="VACUUM_ANALYZE_U024" parameterType="hashmap" >		
		vacuum analyze TB_CONTROL_PROCESS_HIST ;
	</update>
	<update id="VACUUM_ANALYZE_U025" parameterType="hashmap" >		
		vacuum analyze TB_REPLICATION_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_U026" parameterType="hashmap" >		
		vacuum analyze TB_CHECKPOINT_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_U027" parameterType="hashmap" >		
		vacuum analyze TB_QUERY_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_U028" parameterType="hashmap" >		
		vacuum analyze TB_PG_STAT_STATEMENTS ;
	</update>
	<update id="VACUUM_ANALYZE_U029" parameterType="hashmap" >		
		vacuum analyze TB_TABLE_EXT_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_U030" parameterType="hashmap" >		
		vacuum analyze TB_USER_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_U031" parameterType="hashmap" >		
		vacuum analyze TB_DATABASE_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_U032" parameterType="hashmap" >		
		vacuum analyze TB_ALERT_EXPORT_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_U033" parameterType="hashmap" >		
		vacuum analyze TB_REPLICATION_LAG_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_U034" parameterType="hashmap" >		
		vacuum analyze TB_WAL_INFO ;
	</update>
	<update id="VACUUM_ANALYZE_REPL_SLOTS_U001" parameterType="hashmap" >
		vacuum analyze TB_REPLICATION_SLOTS   ;
	</update>
	
<!-- ********************************************************** -->
<!-- DailyBatchTask END -->
<!-- ********************************************************** -->



<!-- ********************************************************** -->
<!-- SocketTask START -->
<!-- ********************************************************** -->
	<select id="DX004_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		SELECT /* EXPERDBMADX004_001 24e9ab7301ff1966da4fb30dc1538882 */
				DATID, DATNAME FROM PG_STAT_DATABASE WHERE DATNAME NOT IN ('template0','template1');
	</select>
	
	<select id="DX004_002" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<![CDATA[
		select nspname from pg_namespace where nspname not like 'pg\_%' and nspname<>'information_schema';
		]]>
	</select>
	
	<select id="DX001_001" parameterType="hashmap" resultType="hashmap">
		select INSTANCE_ID, 
		       SERVER_IP, 
		       SERVICE_PORT, 
		       CONN_USER_ID, 
		       CONN_USER_PWD, 
		       COLLECT_PERIOD_SEC, 
		       CONN_DB_NAME, 
		       LAST_MOD_DT
		  from TB_INSTANCE_INFO
		 where INSTANCE_ID IN 
				<foreach item="item" index="index" collection="list" open="(" separator="," close=")">
					#{item}
				</foreach>
	</select>
	
	<select id="DX005_001" parameterType="hashmap" resultType="hashmap" flushCache="true">
		<![CDATA[
		${query}
		]]>
	</select>
<!-- ********************************************************** -->
<!-- SocketTask END -->
<!-- ********************************************************** -->

	<select id="LICENSE_001" parameterType="hashmap" resultType="hashmap">
		SELECT TO_CHAR(NOW(), 'YYYYMMDD') AS TODAY
	</select>

	<insert id="LICENSE_I001" parameterType="hashmap">
		INSERT INTO TB_SYS_LOG (REG_DATE, TASK_CD, START_DT, STATUS, END_DT, COMMENTS)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			'3',
			NOW(),
			#{status},
			NOW(),
			#{comments}
		); 
	</insert>
	
	<update id="TB_SYS_LOG_U002" parameterType="hashmap">
		UPDATE TB_SYS_LOG 
		   SET DRIVER_STATUS = COALESCE(DRIVER_STATUS,'') || #{driver_status}
		 WHERE REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
		   AND TASK_CD='3'
		   AND START_DT = (SELECT MAX(START_DT) FROM TB_SYS_LOG);
	</update>
	
	
	<select id="RSC_NOW" parameterType="hashmap" resultType="hashmap">
		SELECT NOW() AS DT_NOW
	</select>
	
<!-- ********************************************************** -->
<!-- for log -->
<!-- ********************************************************** -->
	
	<select id="PG_CHECK_EXTENSION_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */
				1 AS INS FROM PG_AVAILABLE_EXTENSIONS WHERE NAME='adminpack'
	</select>
	<select id="PG_CHECK_EXTENSION_002" parameterType="hashmap" resultType="hashmap">
		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */
				1 from pg_extension WHERE extname = 'adminpack'
	</select>	
	<select id="PG_CHECK_EXTENSION_003" parameterType="hashmap" resultType="hashmap">
		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */
				SUM(CASE WHEN EXTNAME = 'experdb_pgmon' THEN 1
		            WHEN EXTNAME = 'pg_stat_statements' THEN CASE WHEN EXTVERSION = '1.6e' THEN 10 ELSE 2 END
					WHEN EXTNAME = 'pg_actstatement' THEN 4
					ELSE 0 END) AS EXTENSIONS
		FROM PG_EXTENSION;
	</select>	
	<update id="PG_CREATE_EXTENSION_001" parameterType="hashmap">
		CREATE EXTENSION adminpack
	</update>
	<select id="PG_SHOW_LOGLINE_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */ setting FROM pg_settings WHERE name = 'log_line_prefix'
	</select>
	
	<select id="PG_SHOW_DIRECTORY_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */ setting FROM pg_settings WHERE  name = 'log_directory'
	</select>
	
	<select id="PG_LOG_DESTINATION_001" parameterType="hashmap" resultType="String">
		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */ setting FROM pg_settings WHERE  name = 'log_destination'
	</select>
	
	<select id="PG_GET_LOGFILES_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */ 
				DIR||'/'||FL AS filename, 
		       (pg_stat_file(DIR||'/'||FL)).modification::TIMESTAMP WITHOUT TIME ZONE::TEXT AS filetime,
		       --pg_file_length(DIR||'/'||FL) AS len
		       (pg_stat_file(DIR||'/'||FL)).size As len
		  FROM pg_ls_dir((SELECT setting FROM pg_settings WHERE  name = 'log_directory')) AS FL,
		       (SELECT setting AS DIR FROM pg_settings WHERE  name = 'log_directory') D
		 WHERE FL like '%.log'
		 ORDER BY filename DESC
	</select>
	
	<select id="PG_GET_LOGFILE_LEN_001" parameterType="hashmap" resultType="String">
		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */ 
				(pg_stat_file(DIR||'/'||FL)).size AS len
		FROM pg_ls_dir((SELECT setting FROM pg_settings WHERE  name = 'log_directory')) AS FL,
		   	(SELECT setting AS DIR FROM pg_settings WHERE  name = 'log_directory') D
		WHERE FL = SPLIT_PART(#{filename}, (SELECT setting FROM pg_settings WHERE  name = 'log_directory') || '/', 2)
	</select>
	<select id="PG_GET_LOGFILE_LEN_001_PREV" parameterType="hashmap" resultType="String">
		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */ 
				(pg_stat_file(DIR||'/'||FL)).size AS len
		FROM pg_ls_dir((SELECT setting FROM pg_settings WHERE  name = 'log_directory')) AS FL,
		   	(SELECT setting AS DIR FROM pg_settings WHERE  name = 'log_directory') D
		WHERE FL = SPLIT_PART(#{filename}, '/', 2)
	</select>
		
	<select id="PG_GET_LOGFILES_003" parameterType="hashmap" resultType="hashmap">
 		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */ 
 				DIR||'/'||FL AS filename, 
		       (pg_stat_file(DIR||'/'||FL)).modification::TIMESTAMP WITHOUT TIME ZONE::TEXT AS filetime,
		       (pg_stat_file(DIR||'/'||FL)).size AS len
		  FROM pg_ls_dir((SELECT setting FROM pg_settings WHERE  name = 'log_directory')) AS FL,
		       (SELECT setting AS DIR FROM pg_settings WHERE  name = 'log_directory') D
		 WHERE FL like '%.csv'
		 ORDER BY filename DESC
	</select>
	
	<select id="PG_GET_LOGFILES_004" parameterType="hashmap" resultType="String">
		SELECT /* 24e9ab7301ff1966da4fb30dc1538882 */ 
				(pg_stat_file(PGCSV.filename)).size AS len 
		FROM
		(SELECT filename FROM pg_logdir_ls() AS A(filetime timestamp, filename text)) AS PGLOG
		JOIN
		(SELECT (SELECT setting || '/' FROM pg_settings WHERE  name = 'log_directory')||filename AS filename 
		 FROM pg_ls_dir((SELECT setting FROM pg_settings WHERE  name = 'log_directory')) as filename 
		 WHERE filename = replace(#{filename},'pg_log/','')) AS PGCSV
		ON replace(PGLOG.filename, '.log', '') = replace(PGCSV.filename, '.csv', '')
	</select>

	<select id="PG_READ_LOGFILE_001" parameterType="hashmap" resultType="String">
		SELECT * from pg_read_file(#{filename}, #{logoffset}, #{length})
	</select>	
	
	<select id="PG_CANCEL_QUERY_001" parameterType="hashmap" resultType="hashmap">
		SELECT pg_cancel_backend(#{pid}) AS RESULT
	</select>
	
	<select id="PG_TERMINATE_QUERY_001" parameterType="hashmap" resultType="hashmap">
		SELECT pg_terminate_backend(#{pid}) AS RESULT
	</select>	
	
	<insert id="TB_CONTROL_PROCESS_HIST_I001" parameterType="hashmap" >
		INSERT INTO TB_CONTROL_PROCESS_HIST
		VALUES 
		(
			#{reg_date},
			#{actv_reg_seq},
			#{instance_id},
			#{process_id},
			#{control_type},
			#{access_type},
			NOW()
		)
	</insert>
<!-- ********************************************************** -->
<!-- for Alert Start-->
<!-- ********************************************************** -->
	<select id="TB_HCHK_THOLD_INFO_001" parameterType="hashmap" resultType="hashmap">
		   SELECT /* EXPERDBMA_TB_HCHK_THOLD_INFO_001 */
		           INSTANCE_ID, HCHK_NAME, IS_HIGHER, WARNING_THRESHOLD, CRITICAL_THRESHOLD, FIXED_THRESHOLD, 
   				   (CASE WHEN ((PAUSE_COLLECT_DT - now()) > interval '00:00:00') then 1 else 0 end) AS PAUSE,
   				   RETENTION_TIME, CRITICAL_START_TIME
		     FROM TB_HCHK_THRD_LIST
		     WHERE INSTANCE_ID > 0
	</select>	
	
	
	
	<select id="TB_HCHK_ALERT_PREV_INFO_001" resultType="hashmap">
	<![CDATA[
		SELECT A.*, NOTIFICATION_LEVEL FROM TB_HCHK_ALERT_INFO A JOIN TB_HCHK_THRD_LIST B ON A.INSTANCE_ID = B.INSTANCE_ID AND A.HCHK_NAME = B.HCHK_NAME AND A.STATE > NOTIFICATION_LEVEL*100
	     WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
		   AND HCHK_REG_SEQ = (SELECT MAX(HCHK_REG_SEQ) HCHK_REG_SEQ FROM TB_HCHK_ALERT_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD'))
		   AND STATE <> 400 AND STATE >= 200
		   ]]>
	</select>	
	
	<select id="TB_HCHK_ALERT_PREV_INFO_001_OLD" resultType="hashmap">
	<![CDATA[
		SELECT * FROM TB_HCHK_ALERT_INFO
	     WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
		   AND HCHK_REG_SEQ = (SELECT MAX(HCHK_REG_SEQ) HCHK_REG_SEQ FROM TB_HCHK_ALERT_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD'))
		   and state <> 400
		   ]]>
	</select>	
		   		   
	<insert id="TB_HCHK_ALERT_INFO_I001" parameterType="hashmap" >
	<![CDATA[	
		WITH UPSERT AS (
			UPDATE TB_HCHK_ALERT_INFO QU
			   SET STATE = #{state}
			 WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
				 AND HCHK_REG_SEQ = CURRVAL('HCHK_REG_SEQ')
				 AND INSTANCE_ID = #{instance_id}
				 AND HCHK_NAME = #{hchk_name}
			RETURNING *) 
		INSERT INTO TB_HCHK_ALERT_INFO (reg_date,hchk_reg_seq,instance_id,hchk_name,state,check_user_id,check_comment,check_ip,check_dt)
		SELECT TO_CHAR(NOW(), 'YYYYMMDD'), CURRVAL('HCHK_REG_SEQ'), #{instance_id}, #{hchk_name}, #{state}, null,null,null,null 
		 WHERE NOT EXISTS(SELECT 1 FROM UPSERT);
		]]>
	</insert>
		 		 
	<insert id="TB_HCHK_ALERT_INFO_I001_220613" parameterType="hashmap" >
	<![CDATA[
		INSERT INTO TB_HCHK_ALERT_INFO	
		SELECT 
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('HCHK_REG_SEQ'),
			#{instance_id},
			#{hchk_name},
			#{state},
			NULL,
			NULL,
			NULL,
			NULL
		WHERE NOT EXISTS
		(
			SELECT 1 FROM TB_HCHK_ALERT_INFO
			 WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
			 AND HCHK_REG_SEQ = CURRVAL('HCHK_REG_SEQ')
			 AND INSTANCE_ID = #{instance_id}
			 AND HCHK_NAME = #{hchk_name}
		)
		]]>
	</insert>
	<insert id="TB_HCHK_ALERT_INFO_I001_OLD" parameterType="hashmap" >
		INSERT INTO TB_HCHK_ALERT_INFO	
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('HCHK_REG_SEQ'),
			#{instance_id},
			#{hchk_name},
			#{state},
			NULL,
			NULL,
			NULL,
			NULL
		)
	</insert>
<!-- ********************************************************** -->
<!-- for Alert End -->
<!-- ********************************************************** -->

<!--	add to update ha_info by robin 201712  -->
<!-- ********************************************************** -->
<!-- ReplCollect START -->
<!-- ********************************************************** -->
	<select id="TB_REPL_COLLECT_INFO_S001" parameterType="hashmap" resultType="hashmap">
		select max(reg_date) as max_reg_date, TO_CHAR(NOW(), 'YYYYMMDD') as reg_date from TB_REPLICATION_INFO;
	</select>
	
	<select id="SEQ_SETVAL_REPL" parameterType="hashmap" resultType="hashmap">
		select setval('repl_reg_seq',1);
	</select>
	
	<select id="EXPERDBMA_BT_SELECT_HA_GROUP_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMA_BT_SELECT_HA_GROUP_001 */
		   CASE WHEN A.HA_ROLE = 'P' THEN A.INSTANCE_ID ELSE 
		   			(SELECT B.HA_GROUP FROM TB_INSTANCE_INFO B 
		   			  WHERE (B.HOST_NAME = A.HA_HOST AND B.SERVICE_PORT = A.SERVICE_PORT) 
		   			     OR (B.HOST_NAME = A.HA_REPL_HOST AND B.SERVICE_PORT = A.SERVICE_PORT) 
		   			     OR (B.SERVER_IP = A.HA_HOST AND B.SERVICE_PORT = A.SERVICE_PORT)) 
		   	END AS HA_GROUP
		FROM TB_INSTANCE_INFO A
		WHERE INSTANCE_ID = #{instance_id}
	</select>	

	<insert id="TB_REPL_COLLECT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_REPLICATION_INFO
		(	
			REG_DATE,
			REPL_REG_SEQ,
			INSTANCE_ID,
			IS_COLLECT_OK,
			FAILED_COLLECT_TYPE,
			HA_ROLE,
			HA_HOST,
			HA_PORT,
			SLOT_NAME,
			HA_GROUP,
			REPLAY_LAG,
			REPLAY_LAG_SIZE,
			COLLECT_DT
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			NEXTVAL('REPL_REG_SEQ'),
			#{instance_id},
			#{is_collect_ok},			
			#{failed_collect_type},
			#{ha_role},
  			#{ha_host},
  			#{ha_port},
  			#{slot_name},  
  			(select ha_group from TB_INSTANCE_INFO where INSTANCE_ID = #{instance_id}),
  			#{replay_lag},
  			#{replay_lag_size},
			NOW()
		)
	</insert>	
	
	<select id="TB_INSTANCE_INFO_S001" parameterType="hashmap" resultType="hashmap">
			SELECT INSTANCE_ID
			  FROM TB_INSTANCE_INFO
			 WHERE (HA_ROLE = 'P' OR HA_ROLE = 'A') AND COLLECT_YN = 'Y' AND DELETE_YN = 'N'
	</select>

	<select id="TB_REPL_LAG_INFO_S001" parameterType="hashmap" resultType="hashmap">
		SELECT INSTANCE_ID, HA_GROUP 
		  FROM TB_INSTANCE_INFO 
		 WHERE (HOST_NAME = #{host_name} OR SERVER_IP = #{host_name}) and COLLECT_YN = 'Y' AND DELETE_YN = 'N' AND HA_GROUP = (select HA_GROUP from tb_instance_info where instance_id = #{instance_id}); 
	</select>
	
	<select id="TB_REPL_LAG_INFO_S002" parameterType="hashmap" resultType="hashmap">
		SELECT INSTANCE_ID 
		  FROM TB_INSTANCE_INFO 
		 WHERE (HOST_NAME = #{host_name} OR SERVER_IP = #{host_name}) and COLLECT_YN = 'Y' AND DELETE_YN = 'N' AND HA_GROUP = #{instance_id}; 
	</select>
		 
	<insert id="TB_REPL_LAG_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_REPLICATION_LAG_INFO
		(	
			REG_DATE,
			REPL_REG_SEQ,
			INSTANCE_ID,
			REPL_INSTANCE_ID,
			REPLAY_LAG,
			REPLAY_LAG_SIZE,
			COLLECT_DT
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('REPL_REG_SEQ'),
			#{instance_id},
  			(SELECT CASE WHEN (select instance_id from TB_INSTANCE_INFO where host_name = #{host_name} AND COLLECT_YN = 'Y' AND DELETE_YN = 'N' AND HA_GROUP = #{ha_group}) IS NOT NULL 
				 		 THEN (select instance_id from TB_INSTANCE_INFO where host_name = #{host_name} AND COLLECT_YN = 'Y' AND DELETE_YN = 'N' AND HA_GROUP = #{ha_group}) 
	                ELSE (select instance_id from TB_INSTANCE_INFO where server_ip = #{host_name} AND COLLECT_YN = 'Y' AND DELETE_YN = 'N' AND HA_GROUP = #{ha_group}) END),
  			#{replay_lag},
  			#{replay_lag_size},
			NOW()
		)
	</insert>
	
	<insert id="TB_REPL_SLOT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_REPLICATION_SLOTS
		(	
			REG_DATE,
			REPL_REG_SEQ,
			INSTANCE_ID,
			SLOT_NAME,
			PLUGIN,
			SLOT_TYPE,
			DATOID,
			TEMPORARY,
			ACTIVE,
			OLDXMIN,
			RESTART_LSN,
			CONFIRMED_FLUSH_LSN,
			COLLECT_DT
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('REPL_REG_SEQ'),
  			#{instance_id},
  			#{slot_name},
  			#{plugin},
  			#{slot_type},
  			#{datoid},
  			#{temporary},
  			#{active},
  			#{oldxmin},
  			#{restart_lsn}::pg_lsn,
  			#{confirmed_flush_lsn}::pg_lsn,
			NOW()
		)
	</insert>
	<!-- select id="EXPERDBMA_BT_HCHK_HA_STATUS_CHANGED_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT /* EXPERDBMA_BT_SELECT_HA_STATUS_CHANGED_001 */
				 REPL.INSTANCE_ID,
			         CASE WHEN IST.HA_ROLE = REPL.HA_ROLE THEN 0 ELSE 1 END AS CHK_HAROLE,
			         CASE WHEN IST.HA_HOST = REPL.HA_HOST THEN 0 ELSE 1 END AS CHK_HAHOST,
			         CASE WHEN IST.HA_PORT = REPL.HA_PORT THEN 0 ELSE 1 END AS CHK_HAPORT,
			         '4' AS COLLECT_GROUP,
			         REPL.REG_DATE AS COLLECT_REG_DATE,
			         REPL.REPL_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
			         REPL.COLLECT_DT::time AS REG_TIME 	
			  FROM TB_REPLICATION_INFO AS REPL, 
			       TB_INSTANCE_INFO AS IST
			WHERE REPL.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
			   AND REPL.INSTANCE_ID = IST.INSTANCE_ID   
			   AND IST.COLLECT_YN = 'Y'             
			   AND IST.DELETE_YN='N' 
			   AND (IST.HA_ROLE <> REPL.HA_ROLE
					OR IST.HA_HOST <> REPL.HA_HOST
					OR IST.HA_PORT <> REPL.HA_PORT)
			   AND REPL.REPL_REG_SEQ = (SELECT MAX(A.REPL_REG_SEQ) from TB_REPLICATION_INFO A WHERE A.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') AND A.INSTANCE_ID = REPL.INSTANCE_ID)
			ORDER BY REPL.REG_DATE,REPL.REPL_REG_SEQ,REPL.INSTANCE_ID;
			]]>
	</select-->	


	
	<select id="EXPERDBMA_BT_HCHK_HA_STATUS_CHANGED_OLD_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			WITH TMP_MAX_SEQ AS 
			(
				SELECT INSTANCE_ID, MAX(A.REPL_REG_SEQ) AS MAX_REG_SEQ 
			 	  FROM   TB_REPLICATION_INFO A 
			 	 WHERE  A.REG_DATE    = TO_CHAR(NOW(), 'YYYYMMDD')
			 	 GROUP BY INSTANCE_ID 
			)
			  SELECT /* EXPERDBMA_BT_SELECT_HA_STATUS_CHANGED_001 24E9AB7301FF1966DA4FB30DC1538882*/
			            REPL.INSTANCE_ID,
			          CASE WHEN MM.MC > 1 THEN 2  
			               --when MM.MC = 0 then 2 ELSE
			               WHEN MM.MC = 0 THEN CASE WHEN IST.HA_ROLE = 'A' THEN 0 ELSE 2 END ELSE  
			          (CASE WHEN IST.HA_ROLE = REPL.HA_ROLE THEN 0 ELSE 1 END |
			           CASE WHEN IST.HA_REPL_HOST = REPL.HA_HOST THEN 0 ELSE 1 END |
			           CASE WHEN IST.HA_PORT = REPL.HA_PORT THEN 0 ELSE 1 END) END AS HASTATUS,        
			           '4' AS COLLECT_GROUP,
			          REPL.REG_DATE AS COLLECT_REG_DATE,
			          REPL.REPL_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
			          REPL.COLLECT_DT::TIME AS REG_TIME          
			    FROM  TB_REPLICATION_INFO AS REPL INNER JOIN TB_INSTANCE_INFO    AS IST
			          ON  REPL.REG_DATE      = TO_CHAR(NOW(), 'YYYYMMDD')
			          AND REPL.INSTANCE_ID  = IST.INSTANCE_ID
			          AND IST.COLLECT_YN    = 'Y'             
			          AND IST.DELETE_YN     = 'N' 
			          INNER JOIN TMP_MAX_SEQ T 
			          ON   REPL.INSTANCE_ID = T.INSTANCE_ID 
			          AND  REPL.REPL_REG_SEQ = T.MAX_REG_SEQ
			          LEFT OUTER JOIN
			         (SELECT IST.HA_GROUP,  
			                 --SUM(CASE WHEN REPL.HA_ROLE IN ('A','S') THEN 0 
			                 SUM(CASE WHEN REPL.HA_ROLE IN ('S') THEN 0 
			                    	  WHEN REPL.HA_ROLE IS NULL THEN 0
			                     ELSE
			                         CASE WHEN REPL.HA_ROLE = 'P' THEN 1
			                         ELSE 1 END
			                     END ) AS MC    
			          FROM   TB_REPLICATION_INFO AS REPL, 
			                 (SELECT INSTANCE_ID, HA_GROUP, HA_ROLE  
			                  FROM   TB_INSTANCE_INFO
			                  --WHERE  HA_ROLE = 'P' AND COLLECT_YN   = 'Y' AND DELETE_YN    = 'N' 
			                  WHERE  COLLECT_YN   = 'Y' AND DELETE_YN    = 'N' 
			                  ) AS IST,
			                  TMP_MAX_SEQ 
			          WHERE   REPL.REG_DATE    = TO_CHAR(NOW(), 'YYYYMMDD')
			          AND     REPL.INSTANCE_ID = IST.INSTANCE_ID
			          AND     REPL.INSTANCE_ID = TMP_MAX_SEQ.INSTANCE_ID
			          AND     REPL.REPL_REG_SEQ = TMP_MAX_SEQ.MAX_REG_SEQ
			          GROUP BY IST.HA_GROUP  
			         ) AS MM 
			         ON    IST.HA_GROUP =  MM.HA_GROUP
			  ORDER BY REPL.REG_DATE,REPL.REPL_REG_SEQ,REPL.INSTANCE_ID;
			]]>
	</select>
	
	<select id="EXPERDBMA_BT_HCHK_HA_STATUS_CHANGED_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
				  SELECT /* EXPERDBMA_BT_HCHK_HA_STATUS_CHANGED_001 24E9AB7301FF1966DA4FB30DC1538882*/
			            REPL.INSTANCE_ID,
			          CASE WHEN MM.MC > 1 THEN 2  
			               --when MM.MC = 0 then 2 ELSE
			               WHEN MM.MC = 0 THEN CASE WHEN IST.HA_ROLE = 'A' THEN 0 ELSE 3 END ELSE  
			               0 END AS HASTATUS,
			          --(CASE WHEN IST.HA_ROLE = REPL.HA_ROLE THEN 0 ELSE 1 END |
			          -- CASE WHEN IST.HA_REPL_HOST = REPL.HA_HOST THEN 0 ELSE 1 END |
			          -- CASE WHEN IST.HA_PORT = REPL.HA_PORT THEN 0 ELSE 1 END) END AS HASTATUS,        
			           '4' AS COLLECT_GROUP,
			          REPL.REG_DATE AS COLLECT_REG_DATE,
			          REPL.REPL_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
			          REPL.COLLECT_DT::TIME AS REG_TIME          
			    FROM  TB_REPLICATION_INFO AS REPL INNER JOIN TB_INSTANCE_INFO    AS IST
			          ON  REPL.REG_DATE      = TO_CHAR(NOW(), 'YYYYMMDD')
			          AND REPL.INSTANCE_ID  = IST.INSTANCE_ID
			          AND IST.COLLECT_YN    = 'Y'             
			          AND IST.DELETE_YN     = 'N' 
			         -- INNER JOIN TMP_MAX_SEQ T 
			         -- ON   REPL.INSTANCE_ID = T.INSTANCE_ID 
			         -- AND  REPL.REPL_REG_SEQ = T.MAX_REG_SEQ
			          LEFT OUTER JOIN
			         (
				         SELECT IST.HA_GROUP,  
				                 --SUM(CASE WHEN REPL.HA_ROLE IN ('A','S') THEN 0 
				                 SUM(CASE WHEN REPL.HA_ROLE IN ('S') THEN 0 
				                    	  WHEN REPL.HA_ROLE IS NULL THEN 0
				                     ELSE
				                         CASE WHEN REPL.HA_ROLE = 'P' THEN 1
				                         ELSE 1 END
				                     END ) AS MC    
				          FROM   TB_REPLICATION_INFO AS REPL, 
				                 (SELECT INSTANCE_ID, HA_GROUP, HA_ROLE  
				                  FROM   TB_INSTANCE_INFO
				                  --WHERE  HA_ROLE = 'P' AND COLLECT_YN   = 'Y' AND DELETE_YN    = 'N' 
				                  WHERE  COLLECT_YN   = 'Y' AND DELETE_YN    = 'N' 
				                  ) AS IST
				          WHERE   REPL.REG_DATE    = TO_CHAR(NOW(), 'YYYYMMDD')
				          AND     REPL.INSTANCE_ID = IST.INSTANCE_ID
				          --AND     REPL.INSTANCE_ID = TMP_MAX_SEQ.INSTANCE_ID
				          AND     REPL.REPL_REG_SEQ = (SELECT MAX(X.REPL_REG_SEQ) FROM TB_REPLICATION_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
				          GROUP BY IST.HA_GROUP  
			         ) AS MM 
			         ON    IST.HA_GROUP =  MM.HA_GROUP
			  WHERE REPL.INSTANCE_ID = IST.INSTANCE_ID
			   AND REPL.REPL_REG_SEQ =  (SELECT MAX(X.REPL_REG_SEQ) FROM TB_REPLICATION_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
			   AND REPL.REPL_REG_SEQ > 3
			  ORDER BY REPL.REG_DATE,REPL.REPL_REG_SEQ,REPL.INSTANCE_ID;
			  ]]>
	</select>
			  
	<select id="EXPERDBMA_BT_HCHK_SO_STATUS_CHANGED_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		SELECT /* EXPERDBMA_BT_HCHK_HA_STATUS_CHANGED_001 24E9AB7301FF1966DA4FB30DC1538882*/ 
				INSTANCE_ID, 
			   ((CASE WHEN WITHSOLUTIONS ISNULL THEN 0 ELSE WITHSOLUTIONS END) # (CASE WHEN STATSOLUTIONS ISNULL THEN 0 ELSE STATSOLUTIONS END)) SOLUTIONSTATUS,  
			   '4' AS COLLECT_GROUP,
			   TO_CHAR(NOW(), 'YYYYMMDD') AS COLLECT_REG_DATE,
			   0 AS COLLECT_REG_SEQ,
			   TO_CHAR(NOW(), 'HH24:MI:SS')::time AS REG_TIME
		  FROM TB_INSTANCE_INFO 
		 WHERE COLLECT_YN = 'Y' 
		   AND DELETE_YN = 'N'
			  ]]>
	</select>
		<select id="EXPERDBMA_BT_HCHK_HA_STATUS_CHANGED_001_PREV" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT /* EXPERDBMA_BT_SELECT_HA_STATUS_CHANGED_001 24e9ab7301ff1966da4fb30dc1538882*/
				  REPL.INSTANCE_ID, 
				 CASE WHEN MM.MC > 0 THEN 2 ELSE 
				 (CASE WHEN IST.HA_ROLE = REPL.HA_ROLE THEN 0 ELSE 1 END |
				 CASE WHEN IST.HA_REPL_HOST = REPL.HA_HOST THEN 0 ELSE 1 END |
				 CASE WHEN IST.HA_PORT = REPL.HA_PORT THEN 0 ELSE 1 END) END AS HASTATUS, 	  
				 '4' AS COLLECT_GROUP,
				 REPL.REG_DATE AS COLLECT_REG_DATE,
				 REPL.REPL_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
				 REPL.COLLECT_DT::time AS REG_TIME          
			  FROM TB_REPLICATION_INFO AS REPL
			       ,TB_INSTANCE_INFO AS IST left outer join
			       (SELECT IST.HA_GROUP, COUNT(REPL.HA_ROLE) AS MC
						FROM TB_REPLICATION_INFO AS REPL, 
							TB_INSTANCE_INFO AS IST
					       WHERE REPL.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
						 AND REPL.INSTANCE_ID = IST.INSTANCE_ID   
						 AND IST.COLLECT_YN = 'Y'             
						 AND IST.DELETE_YN='N' 
						 AND REPL.HA_ROLE = 'P'
						 AND REPL.REPL_REG_SEQ = (SELECT MAX(A.REPL_REG_SEQ) 
										    FROM TB_REPLICATION_INFO A 
										   WHERE A.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
										       AND A.INSTANCE_ID = REPL.INSTANCE_ID 
										       AND A.HA_ROLE = REPL.HA_ROLE)
				  GROUP BY REPL.REG_DATE,IST.HA_GROUP
				  HAVING COUNT(REPL.HA_ROLE) > 1) AS MM on IST.HA_GROUP =  MM.HA_GROUP
			WHERE REPL.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
			   AND REPL.INSTANCE_ID = IST.INSTANCE_ID   
			   --AND IST.HA_GROUP =  MM.HA_GROUP
			   AND IST.COLLECT_YN = 'Y'             
			   AND IST.DELETE_YN='N' 
			   AND REPL.REPL_REG_SEQ = (SELECT MAX(A.REPL_REG_SEQ) from TB_REPLICATION_INFO A WHERE A.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') AND A.INSTANCE_ID = REPL.INSTANCE_ID)
			ORDER BY REPL.REG_DATE,REPL.REPL_REG_SEQ,REPL.INSTANCE_ID;
			]]>
	</select>
	
	<select id="EXPERDBMA_BT_SELECT_HA_MULTI_MASTER_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		  SELECT /* EXPERDBMA_BT_SELECT_HA_MULTI_MASTER_001 24e9ab7301ff1966da4fb30dc1538882*/
		      MIST.INSTANCE_ID
		  FROM (SELECT REPL.REG_DATE, IST.HA_GROUP, COUNT(REPL.HA_ROLE) AS MC
						   FROM TB_REPLICATION_INFO AS REPL, 
						        TB_INSTANCE_INFO AS IST
						  WHERE REPL.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
						    AND REPL.INSTANCE_ID = IST.INSTANCE_ID   
						    AND IST.COLLECT_YN = 'Y'             
						    AND IST.DELETE_YN='N' 
						    AND REPL.HA_ROLE = 'P'
						    AND REPL.REPL_REG_SEQ = (SELECT MAX(A.REPL_REG_SEQ) 
						                               FROM TB_REPLICATION_INFO A 
						                              WHERE A.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') 
						                                AND A.INSTANCE_ID = REPL.INSTANCE_ID 
						                                AND A.HA_ROLE = REPL.HA_ROLE)
					GROUP BY REPL.REG_DATE,IST.HA_GROUP
					HAVING COUNT(REPL.HA_ROLE) > 1) AS MM,
					TB_INSTANCE_INFO MIST
		  WHERE MM.HA_GROUP = MIST.HA_GROUP
		  ]]>
	</select>
	<select id="EXPERDBMA_BT_CHECKPOINT_001" parameterType="hashmap" resultType="hashmap">
		<choose>
			<when test="instance_db_version >= 9.2">
				<![CDATA[
					SELECT /* EXPERDBMA_BT_CHECKPOINT_001 24e9ab7301ff1966da4fb30dc1538882 */
						CHECKPOINTS_TIMED, CHECKPOINTS_REQ, CHECKPOINT_WRITE_TIME+CHECKPOINT_SYNC_TIME::NUMERIC AS CHECKPOINT_TIME 
					  FROM PG_STAT_BGWRITER
				  ]]>
			</when>
            <otherwise>
					SELECT /* EXPERDBMA_BT_CHECKPOINT_001 24e9ab7301ff1966da4fb30dc1538882 */
						CHECKPOINTS_TIMED, CHECKPOINTS_REQ, 0::NUMERIC AS CHECKPOINT_TIME 
					  FROM PG_STAT_BGWRITER
            </otherwise>
		</choose>		  
	</select>
	
	<select id="EXPERDBMA_BT_WALS_001" parameterType="hashmap" resultType="hashmap">
		<choose>
			<when test="instance_db_version > 9.6">
				<![CDATA[
					SELECT /* EXPERDBMA_BT_WALS_001 24e9ab7301ff1966da4fb30dc1538882 */
						   COUNT(*) AS WAL_COUNT FROM pg_ls_dir('pg_wal') WHERE pg_ls_dir ~ '^[0-9A-F]{24}';
				  ]]>
			</when>
            <otherwise>
					SELECT /* EXPERDBMA_BT_WALS_001 24e9ab7301ff1966da4fb30dc1538882 */
						   COUNT(*) AS WAL_COUNT FROM pg_ls_dir('pg_xlog') WHERE pg_ls_dir ~ '^[0-9A-F]{24}';
            </otherwise>
		</choose>		  
	</select>
	<insert id="TB_CHECKPOINT_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_CHECKPOINT_INFO
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('REPL_REG_SEQ'),
			#{instance_id},
			#{checkpoints_timed},
			#{checkpoints_req},
			#{checkpoint_time},
			#{checkpoints_timed_delta},
			#{checkpoints_req_delta},
			#{checkpoints_timed_time_delta},
			#{checkpoints_req_time_delta},
			NOW()
		)
	</insert>	
	<insert id="TB_WAL_INFO_I001" parameterType="hashmap" >
		INSERT INTO TB_WAL_INFO
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			CURRVAL('REPL_REG_SEQ'),
			#{instance_id},
			#{wal_count},
			NOW()
		)
	</insert>	
	<select id="TB_QUERY_INFO_S001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT /* EXPERDBMA_TB_QUERY_INFO_S001 24e9ab7301ff1966da4fb30dc1538882 */
					QUERYID 
			  FROM TB_QUERY_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND INSTANCE_ID = #{instance_id} AND DBID = #{dbid} AND USERID = #{userid} AND QUERYID = #{queryid}
			 ORDER BY STMT_QUERYID ASC LIMIT 1
		  ]]>	  
	</select>
	<select id="TB_QUERY_INFO_S002" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT /* EXPERDBMA_TB_QUERY_INFO_S002 24e9ab7301ff1966da4fb30dc1538882 */
					QUERYID 
			  FROM TB_QUERY_INFO WHERE INSTANCE_ID = #{instance_id} 
			   AND DBID = #{dbid} 
			   AND USERID = #{userid} 
			   AND STMT_QUERYID = #{queryid}
			 ORDER BY STMT_QUERYID ASC LIMIT 1
		  ]]>	  
	</select>
	<insert id="TB_QUERY_INFO_I001_OLD" parameterType="hashmap" >
		INSERT INTO TB_QUERY_INFO 
		(
			INSTANCE_ID,
			DBID,
			USERID,
			QUERYID,
			STMT_QUERYID,
			QUERY,
			COLLECT_DT
		)VALUES 
		(
			#{instance_id},
			#{dbid},
			#{userid},
			#{queryid},
			#{stmt_queryid},
			#{query}
			, NOW()
		) ON CONFLICT DO NOTHING;
	</insert>
	
	<insert id="TB_QUERY_INFO_I001" parameterType="hashmap" >
		<![CDATA[
			INSERT INTO TB_QUERY_INFO
			(
				REG_DATE,
				INSTANCE_ID,
				DBID,
				USERID,
				QUERYID,
				STMT_QUERYID,
				QUERY,
				COLLECT_DT
			) 
		    SELECT TO_CHAR(NOW(), 'YYYYMMDD'), #{instance_id}, coalesce(#{dbid}, 0), coalesce(#{userid}, 0), #{queryid}, #{stmt_queryid}, #{query}, NOW()
		    WHERE NOT EXISTS (
		        SELECT 1 FROM TB_QUERY_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND INSTANCE_ID = #{instance_id} AND DBID = #{dbid} AND USERID = coalesce(#{userid}, 0) AND QUERYID = #{queryid}
		    );
	    ]]>
	</insert>
	<insert id="TB_QUERY_INFO_I002" parameterType="hashmap" >
		WITH UPSERT AS (
		UPDATE TB_QUERY_INFO QU
		   SET STMT_QUERYID = #{stmt_queryid},
		       QUERY = #{query},
		       COLLECT_DT = NOW()		  
		 WHERE QU.INSTANCE_ID = #{instance_id}
		   AND QU.QUERYID = MD5(coalesce(#{queryid}, ''))
		RETURNING *) 
		INSERT INTO TB_QUERY_INFO (INSTANCE_ID, QUERYID, STMT_QUERYID, QUERY, COLLECT_DT)
		SELECT #{instance_id}, MD5(coalesce(#{queryid}, '')), #{stmt_queryid}, #{query}, NOW() 
		 WHERE NOT EXISTS(SELECT 1 FROM UPSERT);
	</insert>
		<select id="TB_PGSS_INFO_S001_NEW" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		/* EXPERDBMA_TB_PGSS_INFO_S001 24e9ab7301ff1966da4fb30dc1538882 */
		WITH RTST 
		AS
		(		
		SELECT T.INSTANCE_ID, T.REG_DATE, T.COLLECT_DT
          		,(select user_id from tb_user_info where user_name = USERID limit 1) as USERID
          		,(select datid from tb_database_info where database_name = dbid limit 1) as DBID
				,QUERYID
				,CQUERYID
				,CALLS
				,TOTAL_TIME 
				,MIN_TIME 
				,MAX_TIME 
				,MEAN_TIME
				,STDDEV_TIME
				,ROWS 
				,SHARED_BLKS_HIT
				,SHARED_BLKS_READ 
				,SHARED_BLKS_DIRTIED
				,SHARED_BLKS_WRITTEN
				,LOCAL_BLKS_HIT 
				,LOCAL_BLKS_READ
				,LOCAL_BLKS_DIRTIED 
				,LOCAL_BLKS_WRITTEN 
				,TEMP_BLKS_READ 
				,TEMP_BLKS_WRITTEN
				,BLK_READ_TIME
				,BLK_WRITE_TIME  
							FROM TB_PG_STAT_STATEMENTS T
							LEFT   JOIN LATERAL (
								   SELECT 	(elem->>'userid') AS USERID 
											,elem->>'dbid'AS DBID 
											,(elem->>'queryid')::int8 AS QUERYID
											,(elem->>'cqueryid')::varchar AS CQUERYID
                      						,(elem->>'calls')::int8 AS CALLS
											,(elem->>'total_time')::float8 AS TOTAL_TIME 
											,(elem->>'min_time')::float8 AS MIN_TIME 
											,(elem->>'max_time')::float8 AS MAX_TIME 
											,(elem->>'mean_time')::float8 AS MEAN_TIME
											,(elem->>'stddev_time')::float8 AS STDDEV_TIME
											,(elem->>'rows')::int8 AS ROWS 
											,(elem->>'shared_blks_hit')::int8 AS SHARED_BLKS_HIT
											,(elem->>'shared_blks_read')::int8 AS SHARED_BLKS_READ 
											,(elem->>'shared_blks_dirtied')::int8 AS SHARED_BLKS_DIRTIED
											,(elem->>'shared_blks_written')::int8 AS SHARED_BLKS_WRITTEN
											,(elem->>'local_blks_hit')::int8 AS LOCAL_BLKS_HIT 
											,(elem->>'local_blks_read')::int8 AS LOCAL_BLKS_READ
											,(elem->>'local_blks_dirtied')::int8 AS LOCAL_BLKS_DIRTIED 
											,(elem->>'local_blks_written')::int8 AS LOCAL_BLKS_WRITTEN 
											,(elem->>'temp_blks_read')::int8 AS TEMP_BLKS_READ 
											,(elem->>'temp_blks_written')::int8 AS TEMP_BLKS_WRITTEN
											,(elem->>'blk_read_time')::float8 AS BLK_READ_TIME
											,(elem->>'blk_write_time')::float8 AS BLK_WRITE_TIME 
								   FROM   JSONB_ARRAY_ELEMENTS(T.PGSS) A(ELEM)   
							   ) AA ON TRUE                              -- PRESERVE ALL ROWS FROM T
							 JOIN TB_PGSS_RESET R ON T.INSTANCE_ID = R.INSTANCE_ID AND T.COLLECT_DT = R.COLLECT_DT 
             WHERE REG_DATE = TO_CHAR(R.COLLECT_DT, 'YYYYMMDD') 
			 AND T.INSTANCE_ID = ${instance_id}	
			)
		   SELECT 
		        RTST.INSTANCE_ID,
     		    U.USER_NAME USERNAME, D.database_name AS DB_NAME,
				F.USERID	          ,
				F.DBID	              ,
				F.QUERYID             ,
				MD5(F.QUERY) QUERY    ,
				F.CALLS     + coalesce(RTST.CALLS, 0)          CALLS,
				F.TOTAL_TIME          + coalesce(RTST.TOTAL_TIME         , 0)   TOTAL_TIME         ,
				F.MIN_TIME            + coalesce(RTST.MIN_TIME           , 0)   MIN_TIME           ,
				F.MAX_TIME            + coalesce(RTST.MAX_TIME           , 0)   MAX_TIME           ,
				F.MEAN_TIME           + coalesce(RTST.MEAN_TIME          , 0)   MEAN_TIME          ,
				F.STDDEV_TIME         + coalesce(RTST.STDDEV_TIME        , 0)   STDDEV_TIME        ,
				F.ROWS                + coalesce(RTST.ROWS               , 0)   "rows"             ,
				F.SHARED_BLKS_HIT     + coalesce(RTST.SHARED_BLKS_HIT    , 0)   SHARED_BLKS_HIT    ,
				F.SHARED_BLKS_READ    + coalesce(RTST.SHARED_BLKS_READ   , 0)   SHARED_BLKS_READ   ,
				F.SHARED_BLKS_DIRTIED + coalesce(RTST.SHARED_BLKS_DIRTIED, 0)   SHARED_BLKS_DIRTIED,
				F.SHARED_BLKS_WRITTEN + coalesce(RTST.SHARED_BLKS_WRITTEN, 0)   SHARED_BLKS_WRITTEN,
				F.LOCAL_BLKS_HIT      + coalesce(RTST.LOCAL_BLKS_HIT     , 0)   LOCAL_BLKS_HIT     ,
				F.LOCAL_BLKS_READ     + coalesce(RTST.LOCAL_BLKS_READ    , 0)   LOCAL_BLKS_READ    ,
				F.LOCAL_BLKS_DIRTIED  + coalesce(RTST.LOCAL_BLKS_DIRTIED , 0)   LOCAL_BLKS_DIRTIED ,
				F.LOCAL_BLKS_WRITTEN  + coalesce(RTST.LOCAL_BLKS_WRITTEN , 0)   LOCAL_BLKS_WRITTEN ,
				F.TEMP_BLKS_READ      + coalesce(RTST.TEMP_BLKS_READ     , 0)   TEMP_BLKS_READ     ,
				F.TEMP_BLKS_WRITTEN   + coalesce(RTST.TEMP_BLKS_WRITTEN  , 0)   TEMP_BLKS_WRITTEN  ,
				F.BLK_READ_TIME       + coalesce(RTST.BLK_READ_TIME      , 0)   BLK_READ_TIME      ,
				F.BLK_WRITE_TIME      + coalesce(RTST.BLK_WRITE_TIME     , 0)   BLK_WRITE_TIME
		  FROM fdw${instance_id} F 
		  LEFT OUTER JOIN RTST ON RTST.DBID = F.DBID AND RTST.USERID = F.USERID AND RTST.QUERYID = F.QUERYID 
		  LEFT OUTER JOIN TB_USER_INFO U ON F.USERID=U.USER_ID and U.INSTANCE_ID = ${instance_id}  JOIN TB_DATABASE_INFO D ON F.DBID = D.DATID and D.INSTANCE_ID = ${instance_id} 
		  WHERE F.QUERY NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
		  ]]>	  
	</select>
	<select id="TB_PGSS_INFO_S001" parameterType="hashmap" resultType="hashmap">
	  <choose>
	  <when test="instance_db_version >= 13.0">
		<![CDATA[
         	SELECT /* EXPERDBMA_TB_PGSS_INFO_S001 24e9ab7301ff1966da4fb30dc1538882 */
     		   U.USENAME USERNAME, D.DATNAME AS DB_NAME,
     		   MAX(USERID) USERID,	
     		   MAX(DBID) DBID,	
     		   MAX(PGS.QUERYID) QUERYID, 
     		   MAX(MD5(PGS.QUERY)) QUERY,
     		   SUM(CALLS) CALLS,
     		   SUM(TOTAL_exec_TIME) TOTAL_TIME,
     		   MIN(MIN_exec_TIME) MIN_TIME,
     		   MAX(MAX_exec_TIME) MAX_TIME,
     		   AVG(MEAN_exec_TIME) MEAN_TIME,
     		   AVG(STDDEV_exec_TIME) STDDEV_TIME,
     		   SUM(ROWS) AS ROWS,
     		   SUM(SHARED_BLKS_HIT)		SHARED_BLKS_HIT,	  	
     		   SUM(SHARED_BLKS_READ)    SHARED_BLKS_READ,  
     		   SUM(SHARED_BLKS_DIRTIED) SHARED_BLKS_DIRTIED,
     		   SUM(SHARED_BLKS_WRITTEN) SHARED_BLKS_WRITTEN,
     		   SUM(LOCAL_BLKS_HIT)      LOCAL_BLKS_HIT,    
     		   SUM(LOCAL_BLKS_READ)     LOCAL_BLKS_READ,   
     		   SUM(LOCAL_BLKS_DIRTIED)  LOCAL_BLKS_DIRTIED,
     		   SUM(LOCAL_BLKS_WRITTEN)  LOCAL_BLKS_WRITTEN,
     		   SUM(TEMP_BLKS_READ)      TEMP_BLKS_READ,    
     		   SUM(TEMP_BLKS_WRITTEN)   TEMP_BLKS_WRITTEN, 
     		   SUM(BLK_READ_TIME)       BLK_READ_TIME,     
     		   SUM(BLK_WRITE_TIME)      BLK_WRITE_TIME
		  FROM PG_STAT_STATEMENTS AS PGS
		           JOIN PG_USER U ON PGS.USERID=U.USESYSID JOIN PG_DATABASE D ON PGS.DBID = D.OID
		           WHERE PGS.QUERY NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%'
		           GROUP BY U.USENAME, D.DATNAME, QUERYID;
		  ]]>	  
	  </when>
	  <otherwise>
		<![CDATA[
         	SELECT /* EXPERDBMA_TB_PGSS_INFO_S001 24e9ab7301ff1966da4fb30dc1538882 */
     		   U.USENAME USERNAME, D.DATNAME AS DB_NAME,
     		   MAX(USERID) USERID,	
     		   MAX(DBID) DBID,	
     		   MAX(PGS.QUERYID) QUERYID, 
     		   MAX(MD5(PGS.QUERY)) QUERY,
     		   SUM(CALLS) CALLS,
     		   SUM(TOTAL_TIME) TOTAL_TIME,
     		   MIN(MIN_TIME) MIN_TIME,
     		   MAX(MAX_TIME) MAX_TIME,
     		   AVG(MEAN_TIME) MEAN_TIME,
     		   AVG(STDDEV_TIME) STDDEV_TIME,
     		   SUM(ROWS) AS ROWS,
     		   SUM(SHARED_BLKS_HIT)		SHARED_BLKS_HIT,	  	
     		   SUM(SHARED_BLKS_READ)    SHARED_BLKS_READ,  
     		   SUM(SHARED_BLKS_DIRTIED) SHARED_BLKS_DIRTIED,
     		   SUM(SHARED_BLKS_WRITTEN) SHARED_BLKS_WRITTEN,
     		   SUM(LOCAL_BLKS_HIT)      LOCAL_BLKS_HIT,    
     		   SUM(LOCAL_BLKS_READ)     LOCAL_BLKS_READ,   
     		   SUM(LOCAL_BLKS_DIRTIED)  LOCAL_BLKS_DIRTIED,
     		   SUM(LOCAL_BLKS_WRITTEN)  LOCAL_BLKS_WRITTEN,
     		   SUM(TEMP_BLKS_READ)      TEMP_BLKS_READ,    
     		   SUM(TEMP_BLKS_WRITTEN)   TEMP_BLKS_WRITTEN, 
     		   SUM(BLK_READ_TIME)       BLK_READ_TIME,     
     		   SUM(BLK_WRITE_TIME)      BLK_WRITE_TIME
		  FROM PG_STAT_STATEMENTS AS PGS
		           JOIN PG_USER U ON PGS.USERID=U.USESYSID JOIN PG_DATABASE D ON PGS.DBID = D.OID
		           WHERE PGS.QUERY NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%'
		           GROUP BY U.USENAME, D.DATNAME, QUERYID;
		  ]]>	  
	  </otherwise>
	  </choose>
	</select>
	<insert id="TB_PGSS_INFO_I001" parameterType="hashmap" >
		<![CDATA[
		INSERT INTO TB_PG_STAT_STATEMENTS
		(
		    REG_DATE,
		    COLLECT_DT,
		    INSTANCE_ID,
		    PGSS
	    )
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDD'),
			now(),
			#{instance_id},
			#{pgss}::jsonb
		)
		]]>	  
	</insert>	
	
	<select id="EXPERDBMA_BT_PGSS_QUERY_CREATE_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			CREATE OR REPLACE FUNCTION GET_PGSS_TEXT(CHARACTER VARYING) RETURNS SETOF TEXT AS $BODY$
			    use strict;
			    use warnings;
			    use Encode;
			    my $del = $_[0];
			    my $sth = spi_exec_query("select setting || '/pg_stat_tmp/' query_dir from pg_settings where name = 'data_directory'");
			    $sth = $sth->{rows}[0]->{query_dir};
			    my $org = $sth . 'pgss_query_texts.stat';
			    my $prev_size_file = $sth . 'pgssqt_size';
			    my $prev_size = 0;
			    my $encoding = spi_exec_query("SELECT current_setting('server_encoding') as current_encoding");
			    $encoding = $encoding->{rows}[0]->{current_encoding};
			   elog(INFO, 'encoding : ' . $encoding);
				# read previous pgss_query_texts.stat file size. 
				if (-e $prev_size_file) {
					open(my $fh, '<', $prev_size_file) or die "can't open the file: $!";
					my $first_line = <$fh>;
				    $first_line =~ s/\R//g;
					$prev_size = $first_line;
					if($prev_size > 0){
						$prev_size -= 1;
					}
				    close($fh);
				}
			    my $org_size = -s $org;
			    my $new_size = $org_size - $prev_size;
				# check if $new_size is less than 0 : maybe pg_stat_statements reset has been performed.
			    if ($new_size <= 0) {
			        $org_size = 0;
			    }			    
				# write current pgss_query_texts.stat file size. 
				open(my $fh, '>', $prev_size_file) or die "can't open the file: $!";
				print $fh $org_size;
				close($fh);
			    if ($new_size <= 0) {
			        return;
			    }
				# read attached new queries. 
			    my $ddcmd = '/bin/dd if=' . $org . ' bs=1 skip=' . $prev_size . ' count=' . $new_size . ' 2>/dev/null' . ' |sed \'s/\\x0/' . $del . '/g\'';
			    # elog(INFO, 'p and n size' . $prev_size . ',' .  $new_size);
				my $newqueries = qx($ddcmd);
			    my @arr = split $del, $newqueries;
			    shift @arr;
			    foreach( @arr ){
			    		my $euc_kr_text = $_;
			    		eval { decode("euc-kr", $euc_kr_text, Encode::FB_CROAK) };
						if ($@) {
						    return_next decode('utf8', $_);
						} else {
						    return_next decode('euc_kr', $_);
						}
			    }
			    return undef;
			$BODY$ LANGUAGE plperlu;
		  ]]>	  
	</select>
	
	<select id="EXPERDBMA_BT_PGSS_QUERY_CREATE_001_202311" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			CREATE OR REPLACE FUNCTION GET_PGSS_TEXT(CHARACTER VARYING) RETURNS SETOF TEXT AS $BODY$
			    use strict;
			    use warnings;
			    use Encode;
			    my $del = $_[0];
			    my $sth = spi_exec_query("select setting || '/pg_stat_tmp/' query_dir from pg_settings where name = 'data_directory'");
			    $sth = $sth->{rows}[0]->{query_dir};
			    my $org = $sth . 'pgss_query_texts.stat';
			    my $prev_size_file = $sth . 'pgssqt_size';
			    my $prev_size = 0;
			    my $encoding = spi_exec_query("SELECT current_setting('server_encoding') as current_encoding");
			    $encoding = $encoding->{rows}[0]->{current_encoding};
			   elog(INFO, 'encoding : ' . $encoding);
				# read previous pgss_query_texts.stat file size. 
				if (-e $prev_size_file) {
					open(my $fh, '<', $prev_size_file) or die "can't open the file: $!";
					my $first_line = <$fh>;
				    $first_line =~ s/\R//g;
					$prev_size = $first_line;
					if($prev_size > 0){
						$prev_size -= 1;
					}
				    close($fh);
				}
			    my $org_size = -s $org;
			    my $new_size = $org_size - $prev_size;
				# check if $new_size is less than 0 : maybe pg_stat_statements reset has been performed.
			    if ($new_size <= 0) {
			        $org_size = 0;
			    }			    
				# write current pgss_query_texts.stat file size. 
				open(my $fh, '>', $prev_size_file) or die "can't open the file: $!";
				print $fh $org_size;
				close($fh);
			    if ($new_size <= 0) {
			        return;
			    }
				# read attached new queries. 
			    my $ddcmd = '/bin/dd if=' . $org . ' bs=1 skip=' . $prev_size . ' count=' . $new_size . ' 2>/dev/null' . ' |sed \'s/\\x0/' . $del . '/g\'';
			    # elog(INFO, 'p and n size' . $prev_size . ',' .  $new_size);
				my $newqueries = qx($ddcmd);
			    my @arr = split $del, $newqueries;
			    shift @arr;
			    foreach( @arr ){
			            my $euc_kr_text = $_;
			    		$euc_kr_text =~ s/\r?\n//g;
			            if ($euc_kr_text =~ /^[ -~\xA1-\xFE]*$/) {
			                #elog(INFO, 'encoding : euc_kr ' . $euc_kr_text);
			           		return_next decode('euc_kr', $_);
			            } else {
			                #elog(INFO, 'encoding : utf8 ' . $euc_kr_text);
			           	 	return_next decode('utf8', $_);
			            }
			    }
			    return undef;
			$BODY$ LANGUAGE plperlu;
		  ]]>	  
	</select>
	
	<select id="EXPERDBMA_BT_PGSS_QUERY_CREATE_001_OLD2" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			CREATE OR REPLACE FUNCTION GET_PGSS_TEXT(CHARACTER VARYING) RETURNS SETOF TEXT AS $BODY$
			    use strict;
			    use warnings;
			    use Encode;
			    my $del = $_[0];
			    my $sth = spi_exec_query("select setting || '/pg_stat_tmp/' query_dir from pg_settings where name = 'data_directory'");
			    $sth = $sth->{rows}[0]->{query_dir};
			    my $org = $sth . 'pgss_query_texts.stat';
			    my $prev_size_file = $sth . 'pgssqt_size';
			    my $prev_size = 0;
			    my $encoding = spi_exec_query("SELECT current_setting('server_encoding') as current_encoding");
			    $encoding = $encoding->{rows}[0]->{current_encoding};
			   elog(INFO, 'encoding : ' . $encoding);
				# read previous pgss_query_texts.stat file size. 
				if (-e $prev_size_file) {
					open(my $fh, '<', $prev_size_file) or die "can't open the file: $!";
					my $first_line = <$fh>;
				    $first_line =~ s/\R//g;
					$prev_size = $first_line;
					if($prev_size > 0){
						$prev_size -= 1;
					}
				    close($fh);
				}
			    my $org_size = -s $org;
			    my $new_size = $org_size - $prev_size;
				# check if $new_size is less than 0 : maybe pg_stat_statements reset has been performed.
			    if ($new_size <= 0) {
			        $org_size = 0;
			    }			    
				# write current pgss_query_texts.stat file size. 
				open(my $fh, '>', $prev_size_file) or die "can't open the file: $!";
				print $fh $org_size;
				close($fh);
			    if ($new_size <= 0) {
			        return;
			    }
				# read attached new queries. 
			    my $ddcmd = '/bin/dd if=' . $org . ' bs=1 skip=' . $prev_size . ' count=' . $new_size . ' 2>/dev/null' . ' |sed \'s/\\x0/' . $del . '/g\'';
			    # elog(INFO, 'p and n size' . $prev_size . ',' .  $new_size);
				my $newqueries = qx($ddcmd);
			    my @arr = split $del, $newqueries;
			    shift @arr;
			    foreach( @arr ){
			            return_next decode($encoding, $_);
			    }
			    return undef;
			$BODY$ LANGUAGE plperlu;
		  ]]>	  
	</select>

	<select id="EXPERDBMA_BT_PGSS_QUERY_CREATE_001_OLD" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
            CREATE OR REPLACE FUNCTION GET_PGSS_TEXT(CHARACTER VARYING) RETURNS SETOF TEXT AS $BODY$
			    use strict;
			    use warnings;
			    use Encode;
			    my $del = $_[0];
			    my $sth = spi_exec_query("select setting || '/pg_stat_tmp/' || 'pgss_query_texts.stat' curr from pg_settings where name = 'data_directory'");
			    my $org = $sth->{rows}[0]->{curr};
			    my $prev = $org . '.prev';
			    my $curr = $org . '.curr';
			    my $copycmd = '/bin/cp ' . $org . ' ' . $curr;
			    my $checkcmd = '[ ! -f $PGDATA/pg_stat_tmp/pgss_query_texts.stat.prev ] && echo -n "F"';
				my $res = `$checkcmd`;
				if ($res eq "F"){
					my $firstcmd = '/bin/head -200 ' . $org . '|sed \'s/\\x0/' . $del . '/g\'';
					my $firstqueries = `$firstcmd`;
					my $firstquery = (split($del, $firstqueries))[0];
					return_next decode('utf-8', $firstquery);
					$checkcmd = '/bin/touch ' . $prev;
				}	
			    my $movecmd = '/bin/mv ' . $curr . ' ' . $prev;
			    my $diffcmd = '/bin/diff -a --unchanged-line-format= --old-line-format= --new-line-format=\'%L\' ' . $prev . ' ' . $curr . '|sed \'s/\\x0/' . $del . '/g\'';
			    $res = `$checkcmd`; 
			    $res = `$copycmd`;
			    my $newqueries = `$diffcmd`;
			    my @arr = split $del, $newqueries;
			    shift @arr;
			    foreach( @arr ){
		            if ($_ =~ /^[ -~\xA1-\xFE]*$/) {
		                elog(INFO, 'encoding : euc_kr');
		           		return_next decode('euc_kr', $_);
		            } else {
		                elog(INFO, 'encoding : utf8');
		           	 	return_next decode('utf8', $_);
		            }
			    }
			    $res = `$movecmd`;
			    return undef;
			$BODY$ LANGUAGE plperlu;
		  ]]>	  
	</select>
	<select id="BT_PGSS_QUERY_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT /* BT_PGSS_QUERY_001 24e9ab7301ff1966da4fb30dc1538882 */
			       MD5(GET_PGSS_TEXT(#{delimeter})) AS QUERYID, GET_PGSS_TEXT(#{delimeter}) AS QUERY;
		  ]]>	  
	</select>
	<insert id="TB_PGSS_QUERY_INFO_I001" parameterType="hashmap" >
		<![CDATA[
			INSERT INTO TB_PGSS_QUERY_INFO
			(
				INSTANCE_ID,
				QUERYID,
				QUERY,
			    COLLECT_DT
		    )
			VALUES 
			(
				#{instance_id},
				#{queryid},
				#{query},
				CURRENT_TIMESTAMP
            ) ON CONFLICT (INSTANCE_ID, QUERYID)
            DO UPDATE
            SET (QUERY, COLLECT_DT) = (#{query}, CURRENT_TIMESTAMP)
		]]>	  
	</insert>
	
	<select id="EXPERDBMA_BT_PGSS_QUERY_RESET_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			     CREATE OR REPLACE FUNCTION RESET_PGSS() RETURNS SETOF TEXT AS $BODY$
			    use strict;
			    use warnings;
			    use Encode;
			    my $del = $_[0];
				my $reset = $_[1];
			    my $sth = spi_exec_query("select setting || '/pg_stat_tmp/' query_dir from pg_settings where name = 'data_directory'");
			    my $pgssqt_size = $sth->{rows}[0]->{query_dir} . 'pgssqt_size';
			    my $rmcmd = '/bin/rm -f '  . $pgssqt_size;
				my $res = `$rmcmd`; 
			    return undef;
			$BODY$ LANGUAGE plperlu;
		  ]]>	  
	</select>
			
	<select id="EXPERDBMA_BT_PGSS_QUERY_RESET_001_OLD" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		     CREATE OR REPLACE FUNCTION RESET_PGSS() RETURNS SETOF TEXT AS $BODY$
			    use strict;
			    use warnings;
			    use Encode;
			    my $del = $_[0];
				my $reset = $_[1];
			    my $sth = spi_exec_query("select setting || '/pg_stat_tmp/' || 'pgss_query_texts.stat' curr from pg_settings where name = 'data_directory'");
			    my $org = $sth->{rows}[0]->{curr};
			    my $prev = $org . '.prev';
			    my $rmcmd = '/bin/rm -f '  . $prev;
				elog(INFO, "181818");
				my $res = `$rmcmd`; 
			    return undef;
			$BODY$ LANGUAGE plperlu;
		  ]]>	  
	</select>
	<select id="BT_PGSS_QUERY_002" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT RESET_PGSS();
		  ]]>	  
	</select>
	<select id="BT_PGSS_QUERY_003" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT PG_STAT_STATEMENTS_RESET();
		  ]]>	  
	</select>
<!-- **************************************************************************************************************** -->	
<!-- Delete partitions -->
<!-- **************************************************************************************************************** -->
	<update id="PG_CREATE_FUNCTION_001_OLD" parameterType="hashmap">
		<![CDATA[
		CREATE OR REPLACE FUNCTION MAINTAIN_PARTITION(tablename varchar, drop_date date, create_date date)
		    RETURNS text AS
		$$
		DECLARE
		    is_exists_partition BOOL;
			ddate varchar;
			cdate varchar;
		BEGIN
			ddate = to_char(drop_date, 'YYYYMMDD');
			cdate = to_char(create_date, 'YYYYMMDD');
		    is_exists_partition := (SELECT EXISTS(SELECT 1 FROM information_schema.tables WHERE table_schema = current_schema() AND table_name = (tablename || '_' || ddate)));
		    IF is_exists_partition = TRUE THEN
		        EXECUTE FORMAT('ALTER TABLE ' || tablename || ' DETACH PARTITION ' || tablename || '_' || ddate) ;
				EXECUTE FORMAT('DROP TABLE IF EXISTS ' || tablename || '_' || ddate || ' CASCADE');
				EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS ' || tablename || '_' || cdate || '  PARTITION OF ' || tablename || ' FOR VALUES IN (' || cdate || ')');
				RETURN TRUE;
		    END IF;
		    RETURN FALSE;
		END;
		$$
		LANGUAGE 'plpgsql' VOLATILE
		SECURITY DEFINER
		COST 100;
		]]>	
	</update>
		
	<update id="PG_DROP_FUNCTION_001" parameterType="hashmap">
		<![CDATA[
		DROP FUNCTION MAINTAIN_PARTITION(tablename varchar, drop_date date, create_date date);
		]]>			
	</update>
	
	
	<update id="PG_EXECUTE_FUNCTION_001" parameterType="hashmap">
		<![CDATA[
		SELECT MAINTAIN_PARTITION(#{tablename}, (now()::date - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1))::date, (now() + INTERVAL '1 day')::date);
		]]>			
	</update>
	
	<update id="PG_MAINTAIN_PARTITIONS_001" parameterType="hashmap">
		<![CDATA[
			DO $$
			DECLARE       
			    is_exists_partition BOOL;
			    var_tablename varchar;
			    ddate varchar;
			    cdate varchar;   
			BEGIN    
				var_tablename = '${tablename}';
				ddate = to_char((now()::date - (SELECT LOG_KEEP_DAYS FROM TB_CONFIG LIMIT 1))::date, 'YYYYMMDD') ;
			    cdate = to_char((now() + INTERVAL '1 day')::date, 'YYYYMMDD');
			    EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS ' || var_tablename || '_' || cdate || '  PARTITION OF ' || var_tablename || ' FOR VALUES IN (' || cdate || ')');     
			    is_exists_partition := (SELECT EXISTS(SELECT 1 FROM information_schema.tables WHERE table_schema = current_schema() AND table_name = (var_tablename || '_' || ddate)));       
			    IF is_exists_partition = TRUE THEN           
				    EXECUTE FORMAT('ALTER TABLE ' || var_tablename || ' DETACH PARTITION ' || var_tablename || '_' || ddate) ;     
				    EXECUTE FORMAT('DROP TABLE IF EXISTS ' || var_tablename || '_' || ddate || ' CASCADE');     
		        END IF;       
			 END $$
		]]>	
	</update>

	<update id="PG_MAINTAIN_PARTITIONS_002" parameterType="hashmap">
		<![CDATA[
			DO $$
			DECLARE       
			    is_exists_partition BOOL;
			    var_tablename varchar;
			    ddate varchar;
			    cdate varchar;
			    ndate varchar;   
			BEGIN    
				var_tablename = '${tablename}';
				ddate = '${old_date}';
			    cdate = '${new_date}';
			    ndate = '${now_date}';
			    EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS ' || var_tablename || '_' || ndate || '  PARTITION OF ' || var_tablename || ' FOR VALUES IN (' || ndate || ')');     
			    EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS ' || var_tablename || '_' || cdate || '  PARTITION OF ' || var_tablename || ' FOR VALUES IN (' || cdate || ')');     
			    is_exists_partition := (SELECT EXISTS(SELECT 1 FROM information_schema.tables WHERE table_schema = current_schema() AND table_name = (var_tablename || '_' || ddate)));       
			    IF is_exists_partition = TRUE THEN           
				    EXECUTE FORMAT('ALTER TABLE ' || var_tablename || ' DETACH PARTITION ' || var_tablename || '_' || ddate) ;     
				    EXECUTE FORMAT('DROP TABLE IF EXISTS ' || var_tablename || '_' || ddate || ' CASCADE');     
		        END IF;
			 END $$
		]]>	
	</update>
	
	<update id="PG_ATTACH_PARTITIONS_002" parameterType="hashmap">
		<![CDATA[
			DO $$
			DECLARE       
			    var_tablename varchar;
			    ndate varchar;
				nhour varchar;
			BEGIN    
				var_tablename = '${tablename}';
			    ndate = to_char(now(), 'YYYYMMDD');
			    FOR i IN 0..23 LOOP
					--RAISE NOTICE '%', concat(ndate, to_char(i, 'fm00'));
					nhour = to_char(i, 'fm00');
			    	EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS ' || var_tablename || '_' || ndate || nhour || '  PARTITION OF ' || var_tablename || ' FOR VALUES IN (' || ndate || nhour || ')');     
			    END LOOP;
			    ndate = to_char(now() + interval '1 day', 'YYYYMMDD');
			    FOR i IN 0..23 LOOP
					--RAISE NOTICE '%', concat(ndate, to_char(i, 'fm00'));
					nhour = to_char(i, 'fm00');
			    	EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS ' || var_tablename || '_' || ndate || nhour || '  PARTITION OF ' || var_tablename || ' FOR VALUES IN (' || ndate || nhour || ')');     
			    END LOOP;
			END $$
		]]>	
	</update>
	
	<update id="PG_DETACH_PARTITIONS_002" parameterType="hashmap">
		<![CDATA[
 			DO $$
			DECLARE       
			    var_tablename varchar;
				var_partition_tablename varchar;
			    ddate varchar;
				_tablename varchar;
			BEGIN    
				var_tablename = '${tablename}';
				var_partition_tablename = NULL;
				ddate = '${old_date}';
				--RAISE NOTICE 'tablename: %', var_partition_tablename;
			    FOR var_partition_tablename IN
			       SELECT table_name FROM information_schema.tables WHERE table_schema = current_schema()
									   AND table_name LIKE var_tablename || '_' || '%'
									   AND table_name < var_tablename || '_' || ddate ORDER BY table_name
			    LOOP
					RAISE NOTICE 'tablename: %', var_partition_tablename;
			        EXECUTE FORMAT('ALTER TABLE ' || var_tablename || ' DETACH PARTITION ' || var_partition_tablename) ;     
				    EXECUTE FORMAT('DROP TABLE IF EXISTS ' || var_partition_tablename || ' CASCADE');
			    END LOOP;
 			END $$
		]]>	
	</update>
	
<update id="PG_CONSTRAINT_TB_ACTV_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_actv_collect_info${regdate}'
		              )
		    THEN
		        ALTER TABLE ONLY tb_actv_collect_info${regdate} ADD CONSTRAINT pk_tb_actv_collect_info${regdate} PRIMARY KEY (reg_date,actv_reg_seq);
		    END IF;
		EXCEPTION   
		WHEN others THEN    
			BEGIN
	 			delete from tb_actv_collect_info${regdate};
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_actv_collect_info${regdate} ADD CONSTRAINT pk_tb_actv_collect_info${regdate} PRIMARY KEY (reg_date,actv_reg_seq);
			EXCEPTION   
			WHEN others THEN    
			END;    
		END$$; 
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_ACCESS_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_access_info${regdate}'
		              )
		    THEN
		        ALTER TABLE ONLY tb_access_info${regdate} ADD CONSTRAINT pk_tb_access_info${regdate} PRIMARY KEY (reg_date,actv_reg_seq,db_name);		
		    END IF;
		EXCEPTION   
		WHEN others THEN    
			BEGIN
	 			delete from tb_access_info${regdate};
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
		        ALTER TABLE ONLY tb_access_info${regdate} ADD CONSTRAINT pk_tb_access_info${regdate} PRIMARY KEY (reg_date,actv_reg_seq,db_name);		
			EXCEPTION   
			WHEN others THEN    
			END; 
		END$$; 
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_BACKEND_RSC_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_backend_rsc${regdate}'
		              )
		    THEN
		        ALTER TABLE ONLY tb_backend_rsc${regdate} ADD CONSTRAINT pk_tb_backend_rsc${regdate} PRIMARY KEY (reg_date,actv_reg_seq,process_id);		
		    END IF;
		EXCEPTION   
		WHEN others THEN    
			BEGIN
	 			delete from tb_backend_rsc${regdate};
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
		        ALTER TABLE ONLY tb_backend_rsc${regdate} ADD CONSTRAINT pk_tb_backend_rsc${regdate} PRIMARY KEY (reg_date,actv_reg_seq,process_id);		
			EXCEPTION   
			WHEN others THEN    
			END; 
		END$$; 
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_CPU_STAT_DETAIL_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_cpu_stat_detail${regdate}'
		              )
		    THEN
		        ALTER TABLE ONLY tb_cpu_stat_detail${regdate} ADD CONSTRAINT pk_tb_cpu_stat_detail${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,cpu_logical_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN    
			BEGIN
	 			delete from tb_cpu_stat_detail${regdate};
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
		        ALTER TABLE ONLY tb_cpu_stat_detail${regdate} ADD CONSTRAINT pk_tb_cpu_stat_detail${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,cpu_logical_id);
			EXCEPTION   
			WHEN others THEN    
			END;     
		END$$; 
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_CPU_STAT_MASTER_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_cpu_stat_master${regdate}'
		              )
		    THEN
		        ALTER TABLE ONLY tb_cpu_stat_master${regdate} ADD CONSTRAINT pk_tb_cpu_stat_master${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);		
		    END IF;
		EXCEPTION   
		WHEN others THEN    
			BEGIN
	 			delete from tb_cpu_stat_master${regdate};
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
		        ALTER TABLE ONLY tb_cpu_stat_master${regdate} ADD CONSTRAINT pk_tb_cpu_stat_master${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);		
			EXCEPTION   
			WHEN others THEN    
			END;     
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_DISK_IO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_disk_io${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_disk_io${regdate} ADD CONSTRAINT pk_tb_disk_io${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,disk_name);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_disk_io${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_disk_io${regdate} ADD CONSTRAINT pk_tb_disk_io${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,disk_name);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_DISK_USAGE_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_disk_usage${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_disk_usage${regdate}	ADD CONSTRAINT pk_tb_disk_usage${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,mount_point_dir);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_disk_usage${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_disk_usage${regdate}	ADD CONSTRAINT pk_tb_disk_usage${regdate} PRIMARY KEY (reg_date,rsc_reg_seq,mount_point_dir);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_HCHK_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_hchk_collect_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_hchk_collect_info${regdate} ADD CONSTRAINT pk_tb_hchk_collect_info${regdate} PRIMARY KEY (reg_date,hchk_reg_seq,instance_id,hchk_name);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_hchk_collect_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_hchk_collect_info${regdate} ADD CONSTRAINT pk_tb_hchk_collect_info${regdate} PRIMARY KEY (reg_date,hchk_reg_seq,instance_id,hchk_name);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_REPLICATION_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_replication_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_replication_info${regdate} ADD CONSTRAINT pk_tb_replication_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_replication_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_replication_info${regdate} ADD CONSTRAINT pk_tb_replication_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_REPLICATION_LAG_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_replication_lag_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_replication_lag_info${regdate} ADD CONSTRAINT pk_tb_replication_lag_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id, repl_instance_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_replication_lag_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_replication_lag_info${regdate} ADD CONSTRAINT pk_tb_replication_lag_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id, repl_instance_id);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_CHECKPOINT_INFO_001" parameterType="hashmap">
		<![CDATA[		
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_checkpoint_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_checkpoint_info${regdate} ADD CONSTRAINT pk_tb_checkpoint_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_checkpoint_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_checkpoint_info${regdate} ADD CONSTRAINT pk_tb_checkpoint_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;	
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_MEMORY_STAT_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_memory_stat${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_memory_stat${regdate} ADD CONSTRAINT pk_tb_memory_stat${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_memory_stat${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_memory_stat${regdate} ADD CONSTRAINT pk_tb_memory_stat${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_OBJT_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_objt_collect_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_objt_collect_info${regdate} ADD CONSTRAINT pk_tb_objt_collect_info${regdate} PRIMARY KEY (reg_date,objt_reg_seq);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_objt_collect_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_objt_collect_info${regdate} ADD CONSTRAINT pk_tb_objt_collect_info${regdate} PRIMARY KEY (reg_date,objt_reg_seq);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_RSC_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_rsc_collect_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_rsc_collect_info${regdate}  ADD CONSTRAINT pk_tb_rsc_collect_info${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_rsc_collect_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_rsc_collect_info${regdate}  ADD CONSTRAINT pk_tb_rsc_collect_info${regdate} PRIMARY KEY (reg_date,rsc_reg_seq);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_TABLE_EXT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_table_ext_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_table_ext_info${regdate} ADD CONSTRAINT pk_tb_table_ext_info${regdate} PRIMARY KEY (reg_date,objt_reg_seq,instance_id,relid);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_table_ext_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_table_ext_info${regdate} ADD CONSTRAINT pk_tb_table_ext_info${regdate} PRIMARY KEY (reg_date,objt_reg_seq,instance_id,relid);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_HCHK_ALERT_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_hchk_alert_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_hchk_alert_info${regdate} ADD CONSTRAINT pk_tb_hchk_alert_info${regdate} PRIMARY KEY (reg_date,hchk_reg_seq, instance_id, hchk_name);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_hchk_alert_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_hchk_alert_info${regdate} ADD CONSTRAINT pk_tb_hchk_alert_info${regdate} PRIMARY KEY (reg_date,hchk_reg_seq, instance_id, hchk_name);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>
<update id="PG_CONSTRAINT_TB_PG_STAT_STATEMENTS_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_pg_stat_statements${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_pg_stat_statements${regdate} ADD CONSTRAINT pk_tb_pg_stat_statements${regdate} PRIMARY KEY (reg_date, collect_dt, instance_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_pg_stat_statements${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_pg_stat_statements${regdate} ADD CONSTRAINT pk_tb_pg_stat_statements${regdate} PRIMARY KEY (reg_date, collect_dt, instance_id);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>

<update id="PG_CONSTRAINT_TB_WAL_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_wal_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_wal_info${regdate} ADD CONSTRAINT pk_tb_wal_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
		    END IF;
		EXCEPTION   
		WHEN others THEN
			BEGIN
			    DELETE FROM tb_wal_info${regdate};       
		    EXCEPTION
				WHEN others THEN  
		    END;
			BEGIN
				ALTER TABLE ONLY tb_wal_info${regdate} ADD CONSTRAINT pk_tb_wal_info${regdate} PRIMARY KEY (reg_date, repl_reg_seq, instance_id);
			EXCEPTION
			WHEN others THEN
	    	END;
		END$$;		
		]]>			
</update>

<update id="PG_CONSTRAINT_TB_QUARY_INFO_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		BEGIN
		    IF NOT EXISTS ( SELECT  constraint_schema
		                ,       constraint_name 
		                FROM    information_schema.constraint_column_usage 
		                WHERE   constraint_schema = current_schema()
		                  AND   constraint_name = 'pk_tb_query_info${regdate}'
		              )
		    THEN
				ALTER TABLE ONLY tb_query_info${regdate} ADD CONSTRAINT pk_tb_query_info${regdate} PRIMARY KEY (reg_date,instance_id, dbid, userid, queryid);
		    END IF;
		EXCEPTION   
		WHEN others THEN
		END$$;	
		]]>			
</update>



<update id="PG_CREATE_FUNCTION_FOR_INDEX_001" parameterType="hashmap">
		<![CDATA[
		CREATE or replace FUNCTION to_date_imm(text, text) returns date
		    AS $$ SELECT to_date($1, $2) $$
		LANGUAGE sql immutable STRICT
		COST 1;
		]]>	
</update>

<update id="PG_CREATE_FUNCTION_FOR_INDEX_001_230110" parameterType="hashmap">
		<![CDATA[
		CREATE OR REPLACE FUNCTION to_date_imm(text, text) 
		RETURNS date
		AS 'to_date'
		LANGUAGE internal immutable STRICT
		COST 1;
		]]>	
</update>

<update id="PG_INDEX_TB_ACTV_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_tb_actv_collect_info${regdate} ON tb_actv_collect_info${regdate} USING btree((TO_DATE_IMM(reg_date, 'yyyymmdd') + reg_time), instance_id);
		]]>			
</update>

<update id="PG_INDEX_TB_RSC_COLLECT_INFO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_tb_rsc_collect_info${regdate} ON tb_rsc_collect_info${regdate} USING btree((TO_DATE_IMM(reg_date, 'yyyymmdd') + reg_time), instance_id);
		]]>			
</update>

<update id="PG_INDEX_TB_CURRENT_LOCK_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_current_lock${regdate} ON tb_current_lock${regdate} USING btree (reg_date,actv_reg_seq);
		]]>			
</update>
<update id="PG_INDEX_TB_CURRENT_LOCK_002" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx02_current_lock${regdate} ON tb_current_lock${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_BACKEND_RSC_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_backend_rsc${regdate} ON tb_backend_rsc${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_ACCESS_INFO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_access_info${regdate} ON tb_access_info${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_MEMORY_STAT_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_memory_stat${regdate} ON tb_memory_stat${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_CPU_STAT_MASTER_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_cpu_stat_master${regdate} ON tb_cpu_stat_master${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_DISK_IO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_disk_io${regdate} ON tb_disk_io${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_DISK_USAGE_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_disk_usage${regdate} ON tb_disk_usage${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_TABLE_EXT_INFO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_table_ext_info${regdate} ON tb_table_ext_info${regdate} USING btree (collect_dt DESC);
		]]>			
</update>
<update id="PG_INDEX_TB_REALTIME_STATEMENTS_PARTITIONS_001" parameterType="hashmap">
		<![CDATA[
		DO $$
		DECLARE       
			var_tablename varchar;
			ndate varchar;
			nhour varchar;
		BEGIN    
			var_tablename = 'tb_realtime_statements';
			ndate = to_char(now(), 'YYYYMMDD');
			FOR i IN 0..23 LOOP
				--RAISE NOTICE '%', concat(ndate, to_char(i, 'fm00'));
				nhour = to_char(i, 'fm00');
				EXECUTE FORMAT('CREATE INDEX IF NOT EXISTS idx01_realtime_statements_' || ndate || nhour || ' ON tb_realtime_statements_' || ndate || nhour || ' USING btree (collect_dt DESC)');
		    END LOOP;
			ndate = to_char(now() + interval '1 day', 'YYYYMMDD');
			FOR i IN 0..23 LOOP
				--RAISE NOTICE '%', concat(ndate, to_char(i, 'fm00'));
				nhour = to_char(i, 'fm00');
				EXECUTE FORMAT('CREATE INDEX IF NOT EXISTS idx01_realtime_statements_' || ndate || nhour || ' ON tb_realtime_statements_' || ndate || nhour || ' USING btree (collect_dt DESC)');
		    END LOOP;
		END $$
		]]>			
</update>

<update id="PG_INDEX_TB_REPLICATION_INFO_001" parameterType="hashmap">
		<![CDATA[
		CREATE INDEX IF NOT EXISTS idx01_replication_info${regdate} ON tb_replication_info${regdate} USING btree (collect_dt DESC);
		]]>			
</update>

	<update id="TB_RTSTATEMENTS_INFO_C001" parameterType="hashmap">
	 <choose>
	  <when test="instance_db_version >= 13.0">
		<![CDATA[
			DO $$
			DECLARE       
			    is_exists_fs BOOL;
			    is_version_over_13 BOOL;
			BEGIN
			    is_exists_fs := (SELECT EXISTS(SELECT 1 FROM information_schema.tables WHERE table_schema = current_schema() AND table_name = 'fdw' || '${instance_id}'));       
			    is_version_over_13 := (SELECT CASE WHEN (SPLIT_PART(SPLIT_PART(version(), ' ', 2), '.', 1)  || '.' || SPLIT_PART(SPLIT_PART(version(), ' ', 2), '.', 2)) >= '13' THEN TRUE ELSE FALSE END);
			    IF is_exists_fs = TRUE THEN
			        EXECUTE FORMAT('DROP SERVER fdw' || '${instance_id}' || ' CASCADE');     
			    END IF;
					EXECUTE FORMAT('CREATE SERVER fdw' || '${instance_id}' || ' FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host ''' || '${server_ip}' || ''', port ''' || '${service_port}' || ''', dbname ''' || '${conn_db_name}' || ''')');
					EXECUTE FORMAT('CREATE USER MAPPING FOR current_user SERVER fdw' || ${instance_id} || ' OPTIONS (user ''' || '${conn_user_id}' || ''', password ''' || '${conn_user_pwd}' || ''')');
					EXECUTE FORMAT(' CREATE FOREIGN TABLE fdw' || '${instance_id}' || ' (userid oid NOT NULL,dbid oid NOT NULL,queryid int8 NOT NULL,calls int8 NOT NULL,total_exec_time float8 NOT NULL,MIN_exec_TIME float8 not null,MAX_exec_TIME float8 not null,MEAN_exec_TIME float8 not null,STDDEV_exec_TIME float8 not null,rows int8 not null,SHARED_BLKS_HIT int8 not null,SHARED_BLKS_READ int8 not null,SHARED_BLKS_DIRTIED int8 not null,SHARED_BLKS_WRITTEN int8 not null,LOCAL_BLKS_HIT int8 not null,LOCAL_BLKS_READ int8 not null,LOCAL_BLKS_DIRTIED int8 not null,LOCAL_BLKS_WRITTEN int8 not null,TEMP_BLKS_READ int8 not null,TEMP_BLKS_WRITTEN int8 not null,BLK_READ_TIME float8 not null,BLK_WRITE_TIME float8 not null,query text) SERVER fdw' || '${instance_id}' || ' OPTIONS (schema_name ''' || '${conn_schema_name}' || ''', table_name ''pg_stat_statements'')');
					EXECUTE FORMAT('DROP TABLE IF EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_0');
					EXECUTE FORMAT('DROP TABLE IF EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_1');
				IF is_version_over_13 = TRUE THEN
					EXECUTE FORMAT('CREATE UNLOGGED TABLE IF NOT EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_0 AS SELECT USERID, DBID, QUERYID, CALLS, TOTAL_exec_TIME TOTAL_TIME, NOW() AS COLLECT_DT FROM PG_STAT_STATEMENTS LIMIT 0') ;  
					EXECUTE FORMAT('CREATE UNLOGGED TABLE IF NOT EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_1 AS SELECT USERID, DBID, QUERYID, CALLS, TOTAL_exec_TIME TOTAL_TIME, NOW() AS COLLECT_DT FROM PG_STAT_STATEMENTS LIMIT 0') ;
				else
					EXECUTE FORMAT('CREATE UNLOGGED TABLE IF NOT EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_0 AS SELECT USERID, DBID, QUERYID, CALLS, TOTAL_TIME, NOW() AS COLLECT_DT FROM PG_STAT_STATEMENTS LIMIT 0') ;  
					EXECUTE FORMAT('CREATE UNLOGGED TABLE IF NOT EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_1 AS SELECT USERID, DBID, QUERYID, CALLS, TOTAL_TIME, NOW() AS COLLECT_DT FROM PG_STAT_STATEMENTS LIMIT 0') ;
				END IF;
			END $$
		  ]]>	  
	  </when>
	  <otherwise>
		<![CDATA[
            DO $$
            DECLARE
                is_exists_fs BOOL;
                is_version_over_13 BOOL;
            BEGIN
                is_exists_fs := (SELECT EXISTS(SELECT 1 FROM information_schema.tables WHERE table_schema = current_schema() AND table_name = 'fdw' || '${instance_id}'));
                is_version_over_13 := (SELECT CASE WHEN (SPLIT_PART(SPLIT_PART(version(), ' ', 2), '.', 1)  || '.' || SPLIT_PART(SPLIT_PART(version(), ' ', 2), '.', 2)) >= '13' THEN TRUE ELSE FALSE END);
                IF is_exists_fs = TRUE THEN
                    EXECUTE FORMAT('DROP SERVER fdw' || '${instance_id}' || ' CASCADE');
                END IF;
                            EXECUTE FORMAT('CREATE SERVER fdw' || '${instance_id}' || ' FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host ''' || '${server_ip}' || ''', port ''' || '${service_port}' || ''', dbname ''' || '${conn_db_name}' || ''')');
                            EXECUTE FORMAT('CREATE USER MAPPING FOR current_user SERVER fdw' || ${instance_id} || ' OPTIONS (user ''' || '${conn_user_id}' || ''', password ''' || '${conn_user_pwd}' || ''')');
                            EXECUTE FORMAT(' CREATE FOREIGN TABLE fdw' || '${instance_id}' || ' (userid oid NOT NULL,dbid oid NOT NULL,queryid int8 NOT NULL,calls int8 NOT NULL,total_time float8 NOT NULL,MIN_TIME float8 not null,MAX_TIME float8 not null,MEAN_TIME float8 not null,STDDEV_TIME float8 not null,rows int8 not null,SHARED_BLKS_HIT int8 not null,SHARED_BLKS_READ int8 not null,SHARED_BLKS_DIRTIED int8 not null,SHARED_BLKS_WRITTEN int8 not null,LOCAL_BLKS_HIT int8 not null,LOCAL_BLKS_READ int8 not null,LOCAL_BLKS_DIRTIED int8 not null,LOCAL_BLKS_WRITTEN int8 not null,TEMP_BLKS_READ int8 not null,TEMP_BLKS_WRITTEN int8 not null,BLK_READ_TIME float8 not null,BLK_WRITE_TIME float8 not null,query text) SERVER fdw' || '${instance_id}' || ' OPTIONS (schema_name ''' || '${conn_schema_name}' || ''', table_name ''pg_stat_statements'')');
                            EXECUTE FORMAT('DROP TABLE IF EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_0');
                            EXECUTE FORMAT('DROP TABLE IF EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_1');
                IF is_version_over_13 = TRUE THEN
                            EXECUTE FORMAT('CREATE UNLOGGED TABLE IF NOT EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_0 AS SELECT USERID, DBID, QUERYID, CALLS, TOTAL_EXEC_TIME TOTAL_TIME, NOW() AS COLLECT_DT FROM PG_STAT_STATEMENTS LIMIT 0') ;
                            EXECUTE FORMAT('CREATE UNLOGGED TABLE IF NOT EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_1 AS SELECT USERID, DBID, QUERYID, CALLS, TOTAL_EXEC_TIME TOTAL_TIME, NOW() AS COLLECT_DT FROM PG_STAT_STATEMENTS LIMIT 0') ;
                ELSE
                            EXECUTE FORMAT('CREATE UNLOGGED TABLE IF NOT EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_0 AS SELECT USERID, DBID, QUERYID, CALLS, TOTAL_TIME, NOW() AS COLLECT_DT FROM PG_STAT_STATEMENTS LIMIT 0') ;
                            EXECUTE FORMAT('CREATE UNLOGGED TABLE IF NOT EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_1 AS SELECT USERID, DBID, QUERYID, CALLS, TOTAL_TIME, NOW() AS COLLECT_DT FROM PG_STAT_STATEMENTS LIMIT 0') ;
                END IF;
            END $$
		  ]]>	  
	  </otherwise>
	</choose>
	</update>
	
	<update id="TB_RTSTATEMENTS_INFO_C001_BAK" parameterType="hashmap">
		<![CDATA[
			DO $$
			DECLARE       
			    is_exists_fs BOOL;
			BEGIN
			    is_exists_fs := (SELECT EXISTS(SELECT 1 FROM information_schema.tables WHERE table_schema = current_schema() AND table_name = 'fdw' || '${instance_id}'));       
			    IF is_exists_fs = TRUE THEN
			        EXECUTE FORMAT('DROP SERVER fdw' || '${instance_id}' || ' CASCADE');     
			    END IF;
					EXECUTE FORMAT('CREATE SERVER fdw' || '${instance_id}' || ' FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host ''' || '${server_ip}' || ''', port ''' || '${service_port}' || ''', dbname ''' || '${conn_db_name}' || ''')');
					EXECUTE FORMAT('CREATE USER MAPPING FOR current_user SERVER fdw' || ${instance_id} || ' OPTIONS (user ''' || '${conn_user_id}' || ''', password ''' || '${conn_user_pwd}' || ''')');
					EXECUTE FORMAT(' CREATE FOREIGN TABLE fdw' || '${instance_id}' || ' (userid oid NOT NULL,dbid oid NOT NULL,queryid int8 NOT NULL,calls int8 NOT NULL,total_time float8 NOT NULL,query text) SERVER fdw' || '${instance_id}' || ' OPTIONS (schema_name ''' || '${conn_schema_name}' || ''', table_name ''pg_stat_statements'')');
					EXECUTE FORMAT('DROP TABLE IF EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_0');
					EXECUTE FORMAT('DROP TABLE IF EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_1');
					EXECUTE FORMAT('CREATE UNLOGGED TABLE IF NOT EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_0 AS SELECT USERID, DBID, QUERYID, CALLS, TOTAL_TIME, NOW() AS COLLECT_DT FROM PG_STAT_STATEMENTS LIMIT 0') ;  
					EXECUTE FORMAT('CREATE UNLOGGED TABLE IF NOT EXISTS PG_STAT_STATEMENTS_TMP_' || '${instance_id}' || '_1 AS SELECT USERID, DBID, QUERYID, CALLS, TOTAL_TIME, NOW() AS COLLECT_DT FROM PG_STAT_STATEMENTS LIMIT 0') ;
			END $$
		  ]]>	  
	</update>
	
	<select id="BT_RTSTMT_INFO_001" parameterType="hashmap" resultType="hashmap">
	 <choose>
	  <when test="instance_db_version >= 13.0">
		<![CDATA[
			WITH RTST
			AS
			(
				SELECT *
				FROM (
					SELECT 
							CASE WHEN A.USERID IS NULL THEN B.USERID ELSE A.USERID END USERID, 
							CASE WHEN A.DBID IS NULL THEN B.DBID  ELSE A.DBID END DBID,
							CASE WHEN A.QUERYID IS NULL THEN B.QUERYID  ELSE A.QUERYID END QUERYID,
							ABS((COALESCE(B.CALLS,0)-COALESCE(A.CALLS,0))) CALLS,
							ABS((COALESCE(B.TOTAL_TIME,0)-COALESCE(A.TOTAL_TIME,0))) TOTAL_TIME
							--B.QUERY QUERY
					  FROM PG_STAT_STATEMENTS_TMP_${instance_id}_1 AS A FULL JOIN PG_STAT_STATEMENTS_TMP_${instance_id}_0 AS B ON A.USERID = B.USERID AND A.DBID = B.DBID AND A.QUERYID = B.QUERYID
					 ORDER BY CALLS DESC
					) DIFF
				WHERE CALLS >  0
			)
			SELECT RTST.*, md5(fdw${instance_id}.query) CQUERYID FROM RTST JOIN fdw${instance_id} ON RTST.userid = fdw${instance_id}.userid AND RTST.dbid = fdw${instance_id}.dbid AND RTST.queryid = fdw${instance_id}.queryid
			   AND fdw${instance_id}.query NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
		  ]]>
	  </when>
	  <otherwise>
		<![CDATA[
			WITH RTST
			AS
			(
				SELECT *
				FROM (
					SELECT 
							CASE WHEN A.USERID IS NULL THEN B.USERID ELSE A.USERID END USERID, 
							CASE WHEN A.DBID IS NULL THEN B.DBID  ELSE A.DBID END DBID,
							CASE WHEN A.QUERYID IS NULL THEN B.QUERYID  ELSE A.QUERYID END QUERYID,
							ABS((COALESCE(B.CALLS,0)-COALESCE(A.CALLS,0))) CALLS,
							ABS((COALESCE(B.TOTAL_TIME,0)-COALESCE(A.TOTAL_TIME,0))) TOTAL_TIME
							--B.QUERY QUERY
					  FROM PG_STAT_STATEMENTS_TMP_${instance_id}_1 AS A FULL JOIN PG_STAT_STATEMENTS_TMP_${instance_id}_0 AS B ON A.USERID = B.USERID AND A.DBID = B.DBID AND A.QUERYID = B.QUERYID
					 ORDER BY CALLS DESC
					) DIFF
				WHERE CALLS >  0
			)
			SELECT RTST.*, md5(convert_to(fdw${instance_id}.query, #{server_encoding})) CQUERYID FROM RTST JOIN fdw${instance_id} ON RTST.userid = fdw${instance_id}.userid AND RTST.dbid = fdw${instance_id}.dbid AND RTST.queryid = fdw${instance_id}.queryid
			   AND fdw${instance_id}.query NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
		  ]]>
	  </otherwise>
	 </choose>
	</select>
	
	<select id="BT_RTSTMT_INFO_001_OLD" parameterType="hashmap" resultType="hashmap">
	 <choose>
	  <when test="instance_db_version >= 13.0">
		<![CDATA[
			WITH RTST
			AS
			(
				SELECT *
				FROM (
					SELECT 
							CASE WHEN A.USERID IS NULL THEN B.USERID ELSE A.USERID END USERID, 
							CASE WHEN A.DBID IS NULL THEN B.DBID  ELSE A.DBID END DBID,
							CASE WHEN A.QUERYID IS NULL THEN B.QUERYID  ELSE A.QUERYID END QUERYID,
							ABS((COALESCE(B.CALLS,0)-COALESCE(A.CALLS,0))) CALLS,
							ABS((COALESCE(B.TOTAL_TIME,0)-COALESCE(A.TOTAL_TIME,0))) TOTAL_TIME
							--B.QUERY QUERY
					  FROM PG_STAT_STATEMENTS_TMP_${instance_id}_1 AS A FULL JOIN PG_STAT_STATEMENTS_TMP_${instance_id}_0 AS B ON A.USERID = B.USERID AND A.DBID = B.DBID AND A.QUERYID = B.QUERYID
					 ORDER BY CALLS DESC
					) DIFF
				WHERE CALLS >  0
			)
			SELECT RTST.*, md5(fdw${instance_id}.query) CQUERYID FROM RTST JOIN fdw${instance_id} ON RTST.userid = fdw${instance_id}.userid AND RTST.dbid = fdw${instance_id}.dbid AND RTST.queryid = fdw${instance_id}.queryid
			   AND fdw${instance_id}.query NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
		  ]]>
	  </when>
	  <otherwise>
		<![CDATA[
			WITH RTST
			AS
			(
				SELECT *
				FROM (
					SELECT 
							CASE WHEN A.USERID IS NULL THEN B.USERID ELSE A.USERID END USERID, 
							CASE WHEN A.DBID IS NULL THEN B.DBID  ELSE A.DBID END DBID,
							CASE WHEN A.QUERYID IS NULL THEN B.QUERYID  ELSE A.QUERYID END QUERYID,
							ABS((COALESCE(B.CALLS,0)-COALESCE(A.CALLS,0))) CALLS,
							ABS((COALESCE(B.TOTAL_TIME,0)-COALESCE(A.TOTAL_TIME,0))) TOTAL_TIME
							--B.QUERY QUERY
					  FROM PG_STAT_STATEMENTS_TMP_${instance_id}_1 AS A FULL JOIN PG_STAT_STATEMENTS_TMP_${instance_id}_0 AS B ON A.USERID = B.USERID AND A.DBID = B.DBID AND A.QUERYID = B.QUERYID
					 ORDER BY CALLS DESC
					) DIFF
				WHERE CALLS >  0
			)
			SELECT RTST.*, md5(fdw${instance_id}.query) CQUERYID FROM RTST JOIN fdw${instance_id} ON RTST.userid = fdw${instance_id}.userid AND RTST.dbid = fdw${instance_id}.dbid AND RTST.queryid = fdw${instance_id}.queryid
			   AND fdw${instance_id}.query NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
		  ]]>
	  </otherwise>
	 </choose>
	</select>
	
	<select id="BT_RTSTMT_INFO_002" parameterType="hashmap" resultType="hashmap">
	 <choose>
	  <when test="instance_db_version >= 13.0">
		<![CDATA[
			SELECT userid, dbid, queryid, calls, total_exec_time total_time, md5(query) cqueryid  FROM pg_stat_statements WHERE update_time > #{update_time}::timestamp
			   AND query NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
		  ]]>
	  </when>
	  <otherwise>
		<![CDATA[
			SELECT userid, dbid, queryid, calls, total_time, md5(query) cqueryid  FROM pg_stat_statements WHERE update_time > #{update_time}::timestamp
			   AND query NOT LIKE '%24e9ab7301ff1966da4fb30dc1538882%';
		  ]]>
	  </otherwise>
	 </choose>
	</select>
	
	<delete id="BT_RTSTMT_CALL_INFO_T001" parameterType="hashmap">
		<![CDATA[
			TRUNCATE TABLE PG_STAT_STATEMENTS_TMP_${instance_id}_${table_order};
		  ]]>	  
	</delete>
	
	<insert id="BT_RTSTMT_CALL_INFO_I001" parameterType="hashmap">
	 <choose>
	  <when test="instance_db_version >= 13.0">
		<![CDATA[
			INSERT INTO PG_STAT_STATEMENTS_TMP_${instance_id}_${table_order} SELECT userid, dbid, queryid, calls, total_exec_time total_time, now() FROM fdw${instance_id};
		  ]]>
	  </when>
	  <otherwise>
		<![CDATA[
			INSERT INTO PG_STAT_STATEMENTS_TMP_${instance_id}_${table_order} SELECT userid, dbid, queryid, calls, total_time, now() FROM fdw${instance_id};
		  ]]>
	  </otherwise>
	 </choose>
	</insert>

	<insert id="BT_RTSTMT_INFO_I001" parameterType="hashmap">
		INSERT INTO TB_REALTIME_STATEMENTS	
		(
		    reg_time,
		    instance_id,
		    dbid,
		    userid,
		    queryid,
		    calls,
		    total_time,
		    cqueryid,
		    collect_dt
		)
		VALUES 
		(
			TO_CHAR(NOW(), 'YYYYMMDDHH24'),
			#{instance_id},
			#{dbid},
			#{userid},
			#{queryid},
			#{calls},
			#{total_time},
			#{cqueryid},
			now()
		)
	</insert>
		
	<select id="BT_RTSTMT_INFO_QUERY_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT /* EXPERDBMABT_RTSTMT_INFO_QUERY_001 24e9ab7301ff1966da4fb30dc1538882 */
			 		query, md5(query) queryid FROM pg_stat_statements WHERE userid = #{userid} AND dbid = #{dbid} AND queryid = #{queryid};
		  ]]>
	</select>
	
	<select id="TB_CHECK_PARTITION_R001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			select 1 from ${tablename}_${regdate} limit 1;
		  ]]>
	</select>
	
	<select id="TB_EXPORT_INFO_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT * FROM TB_ALERT_LINK_CONFIG ORDER BY LAST_MOD_DT DESC LIMIT 1;
		  ]]>
	</select>
	
	<select id="TB_EXPORT_ALERT_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
	      SELECT 
	      		0 AS export_type,
			    ALERT.instance_id INSTANCE_ID,
			    (select COALESCE(notification_sender, '') from tb_alert_link_config ORDER BY LAST_MOD_DT DESC LIMIT 1) AS sender,
			    CASE WHEN MU.USER_NOTI_PHONE = 0 THEN MU.USER_PHONE WHEN MU.USER_NOTI_PHONE = 1 THEN MU.USER_PHONE2 ELSE MU.USER_EMPNUM END AS reciever,
	            ALERT.state export_level,
	            '['
			    || (CASE WHEN ALERT.state = 200 THEN 'Warning' ELSE 'Critical' END)
--			    || (CASE WHEN BUSINESS_NAME IS NULL OR length(BUSINESS_NAME) = 0 THEN '' ELSE '] Business : ' || BUSINESS_NAME END)
				|| (CASE WHEN BUSINESS_NAME IS NULL OR length(BUSINESS_NAME) = 0 THEN '] Host : ' || split_part(INS.HOST_NAME,'.',1)  ELSE '] Business : ' || BUSINESS_NAME END)
			    || ', Alert : ' 
			    || SC.code_desc
			    || ':'
			    || CASE WHEN COL.VALUE = 99999.00 THEN '-'
			    		WHEN COL.VALUE IS NULL THEN 0::varchar
			    	    ELSE CASE WHEN COL.HCHK_NAME = 'HASTATUS' THEN CASE WHEN COL.VALUE = 2 THEN 'Multi Primary' WHEN COL.VALUE = 3 THEN 'No Primary' ELSE '-' END
			    	    		  WHEN COL.HCHK_NAME = 'REPLICATION_SLOT' THEN CASE WHEN COL.VALUE = 1 THEN 'Inactive slot' WHEN COL.VALUE = 2 THEN 'No slot' ELSE '-' END
			    	    		  WHEN COL.HCHK_NAME = 'VIRTUAL_IP' THEN CASE WHEN COL.VALUE = 1 THEN 'Connection fail' WHEN COL.VALUE = 2 THEN 'Not Primary' ELSE '-' END
			    	              ELSE 
			    	              	CASE WHEN TH.UNIT <> '%'
			    	              		 THEN (COL.VALUE::integer)::varchar
			    	              	 ELSE COL.VALUE::varchar
			    	                 END
			    	              END 
			    	    END
			    || ' '
			    || TH.UNIT AS messages,
			    DATE(ALERT.REG_DATE) + COL.REG_TIME collect_dt,
			    ALERT.hchk_name,
			    MU.USER_ID
	         FROM TB_HCHK_ALERT_INFO ALERT, 
	            TB_INSTANCE_INFO INS ,
	            TB_HCHK_COLLECT_INFO COL,
	            TB_HCHK_THRD_LIST TH,
	            TB_MON_USER_BY_GROUP UG,
	            TB_MON_USER MU,
	            TB_SYS_CODE SC
	        WHERE ALERT.hchk_reg_seq = (SELECT MAX(hchk_reg_seq) FROM TB_HCHK_COLLECT_INFO WHERE reg_date = TO_CHAR(NOW(), 'YYYYMMDD'))
	        AND ALERT.INSTANCE_ID = INS.INSTANCE_ID
	        AND ALERT.INSTANCE_ID = COL.INSTANCE_ID
	        AND ALERT.REG_DATE = COL.REG_DATE 
	        AND ALERT.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
	        AND ALERT.HCHK_REG_SEQ = COL.HCHK_REG_SEQ
	        AND ALERT.HCHK_NAME = COL.HCHK_NAME
	        AND ALERT.INSTANCE_ID = TH.INSTANCE_ID
	        AND ALERT.HCHK_NAME = TH.HCHK_NAME
	        AND TH.NOTIFICATION_LEVEL > 0
	        AND STATE > (TH.NOTIFICATION_LEVEL) * 100
	        AND STATE < 400
	        AND EXTRACT(EPOCH FROM ((DATE(ALERT.REG_DATE) + COL.REG_TIME) - TH.NOTIFICATION_LASTSENT))::NUMERIC >= (TH.NOTIFICATION_CYCLE * 60 - 1)
	        AND TH.USER_GROUP = UG.GROUP_ID
	        AND UG.USER_ID = MU.USER_ID
	        AND ALERT.hchk_name = SC.code_name
UNION ALL
	       	SELECT 
	      		0 AS export_type,
			    ALERT.instance_id INSTANCE_ID,
			    (select COALESCE(notification_sender, '') from tb_alert_link_config ORDER BY LAST_MOD_DT DESC LIMIT 1) AS sender,
			    CASE WHEN MU.USER_NOTI_PHONE = 0 THEN MU.USER_PHONE WHEN MU.USER_NOTI_PHONE = 1 THEN MU.USER_PHONE2 ELSE MU.USER_EMPNUM END AS reciever,
	            ALERT.state export_level,
	            '['
			    || (CASE WHEN ALERT.state = 200 THEN 'Warning' WHEN ALERT.state = 300 THEN 'Critical' ELSE 'Resolved' END)
				|| (CASE WHEN BUSINESS_NAME IS NULL OR length(BUSINESS_NAME) = 0 THEN '] Host : ' || split_part(INS.HOST_NAME,'.',1)  ELSE '] Business : ' || BUSINESS_NAME END)
			    || ', Alert : ' 
			    || SC.code_desc
			    || ':'
			    || CASE WHEN COL.VALUE = 99999.00 THEN '-'
			    		WHEN COL.VALUE IS NULL THEN 0::varchar
			    	    ELSE CASE WHEN COL.HCHK_NAME = 'HASTATUS' THEN CASE WHEN COL.VALUE = 2 THEN 'Multi Primary' WHEN COL.VALUE = 3 THEN 'No Primary' ELSE '-' END
			    	    		  WHEN COL.HCHK_NAME = 'REPLICATION_SLOT' THEN CASE WHEN COL.VALUE = 1 THEN 'Inactive slot' WHEN COL.VALUE = 2 THEN 'No slot' ELSE '-' END
			    	    		  WHEN COL.HCHK_NAME = 'VIRTUAL_IP' THEN CASE WHEN COL.VALUE = 1 THEN 'Connection fail' WHEN COL.VALUE = 2 THEN 'Not Primary' ELSE '-' END
			    	              ELSE 
			    	              	CASE WHEN TH.UNIT <> '%'
			    	              		 THEN (COL.VALUE::integer)::varchar
			    	              	 ELSE COL.VALUE::varchar
			    	                 END
			    	              END 
			    	    END
			    || ' '
			    || TH.UNIT AS messages,
			    DATE(ALERT.REG_DATE) + COL.REG_TIME collect_dt,
			    ALERT.hchk_name,
			    MU.USER_ID
	         FROM TB_HCHK_ALERT_INFO ALERT, 
	            TB_INSTANCE_INFO INS ,
	            TB_HCHK_COLLECT_INFO COL,
	            TB_HCHK_THRD_LIST TH,
	            TB_MON_USER_BY_GROUP UG,
	            TB_MON_USER MU,
	            TB_SYS_CODE SC
	        WHERE ALERT.hchk_reg_seq = (SELECT MAX(hchk_reg_seq) FROM TB_HCHK_COLLECT_INFO WHERE reg_date = TO_CHAR(NOW(), 'YYYYMMDD'))
	        AND ALERT.INSTANCE_ID = INS.INSTANCE_ID
	        AND ALERT.INSTANCE_ID = COL.INSTANCE_ID
	        AND ALERT.REG_DATE = COL.REG_DATE 
	        AND ALERT.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
	        AND ALERT.HCHK_REG_SEQ = COL.HCHK_REG_SEQ
	        AND ALERT.HCHK_NAME = COL.HCHK_NAME
	        AND ALERT.INSTANCE_ID = TH.INSTANCE_ID
	        AND ALERT.HCHK_NAME = TH.HCHK_NAME
	        AND TH.NOTIFICATION_LEVEL > 0
	        AND STATE = 400
	        AND TH.USER_GROUP = UG.GROUP_ID
	        AND UG.USER_ID = MU.USER_ID
	        AND ALERT.hchk_name = SC.code_name
	        ORDER BY INSTANCE_ID;	       
		  ]]>
	</select>
	
	<insert id="TB_EXPORT_ALERT_I001" parameterType="hashmap">
		<![CDATA[
			INSERT INTO TB_ALERT_EXPORT_INFO 
			(
			    EXPORT_TYPE,
			    INSTANCE_ID,
			    SENDER,
			    RECIEVER,
				EXPORT_LEVEL,
			    MESSAGES,
			    ISSUCCESS,
			    ERROR,
			    USER_ID,
			    COLLECT_DT
			) VALUES
			(
				#{export_type},
				#{instance_id},
				#{sender},
				#{reciever},
				#{export_level},
				#{messages},
				#{issuccess},
				#{error},
				#{user_id},
				#{collect_dt}
			)
		  ]]>
	</insert>
	
	<update id="TB_EXPORT_ALERT_U001" parameterType="hashmap" >
	      UPDATE TB_HCHK_THRD_LIST
		     SET NOTIFICATION_LASTSENT = now() 
		   WHERE INSTANCE_ID = #{instance_id}
		     AND HCHK_NAME = #{hchk_name}
    </update>
    
    <update id="TB_CHECK_USER_EXPIRATION_U001" parameterType="hashmap" >
	<![CDATA[
		  UPDATE TB_MON_USER SET IS_LOCKED_TF = TRUE
 		   WHERE USER_ID in (
			 				  SELECT USER_ID 
			                    FROM TB_MON_USER 
			                   WHERE GREATEST(LAST_LOGIN_DT, LAST_LOGOUT_DT)::date < (NOW()-(SELECT lock_inact_period FROM tb_mon_user_policy) * INTERVAL '1 day')::date
			                     AND IS_ADMIN_TF = false
                 			)
     ]]>
    </update>

<!-- **************************************************************************************************************** -->
<!-- Delete partitions -->	
<!-- **************************************************************************************************************** -->
	
<!-- ********************************************************** -->
<!-- ReplCollect End -->
<!-- ********************************************************** -->
<!--	add to update ha_info by robin 201712  end -->
<!-- Check Virtual IP Start -->
	<select id="TB_INSTANCE_INFO_R004" parameterType="hashmap" resultType="hashmap"  >
		SELECT instance_id, server_ip, host_name, ha_group, virtual_ip, virtual_ip_stat, service_port, conn_db_name, conn_user_id, conn_user_pwd
		  FROM tb_instance_info
		 WHERE virtual_ip is not null
		   AND COLLECT_YN = 'Y'
           AND DELETE_YN = 'N'
	</select>	
	<select id="TB_INSTANCE_INFO_R005" parameterType="hashmap" resultType="hashmap"  >
		SELECT instance_id, server_ip, host_name, ha_group, virtual_ip2, service_port, conn_db_name, conn_user_id, conn_user_pwd
		  FROM tb_instance_info
		 WHERE virtual_ip2 is not null
		   AND COLLECT_YN = 'Y'
           AND DELETE_YN = 'N'
	</select>
	<select id="BT_CHECK_VIP_FUNCTION_000" parameterType="hashmap" resultType="hashmap"  >
			SELECT 1 EXISTFUNC
			  FROM pg_proc p
			  LEFT JOIN pg_namespace n ON p.pronamespace = n.oid
			  WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
			    AND	p.proname = 'checkvip'
	</select>
	<update id="BT_CHECK_VIP_FUNCTION_001" parameterType="hashmap">
		<![CDATA[
			/* EXPERDBMA_BT_CREATE_FUNCTION_001 24E9AB7301FF1966DA4FB30DC1538882*/
			DO $$
			DECLARE       
			    is_in_recovery BOOL;
			    is_plperu BOOL;
			BEGIN    
			    is_in_recovery := (SELECT PG_IS_IN_RECOVERY());       
			    IF is_in_recovery = FALSE THEN
			    	is_plperu := (SELECT true FROM pg_extension WHERE extname = 'plperlu');
				    IF is_plperu = FALSE THEN           
					    EXECUTE FORMAT('CREATE EXTENSION IF NOT EXISTS plperlu');
					END IF;
				    EXECUTE FORMAT('CREATE OR REPLACE FUNCTION CHECKVIP(CHARACTER VARYING) RETURNS text AS $BODY$
								    use warnings;
								    use strict;
									my $vip = $_[0];
									my $res;
									my $cmd = ''/usr/sbin/ip addr |grep '' . $vip . ''|awk \''{print $2}\''|awk -F\''/\'' \''{print $1}\''|tr -d \''\n\'''';
							$res = `$cmd`;
						    return($res);
						$BODY$ LANGUAGE plperlu;');     
			    END IF;     
			 END $$
		  ]]>	  
	</update>
	<select id="BT_CHECK_VIP_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT /* BT_CHECK_VIP_002 24e9ab7301ff1966da4fb30dc1538882 */
				CHECKVIP(#{virtual_ip2}) AS virtual_ip2; 
		  ]]>	  
	</select>
	<update id="TB_INSTANCE_INFO_U006" parameterType="hashmap" >
		UPDATE TB_INSTANCE_INFO 
		   SET reserved = #{reserved} 
		 WHERE instance_id = #{instance_id} ;
	</update>
	<update id="TB_INSTANCE_INFO_U007" parameterType="hashmap" >
		UPDATE TB_INSTANCE_INFO 
		   SET hchk_period_sec = #{hchk_period_sec} 
		 WHERE instance_id = #{instance_id} ;
	</update>
	<select id="EXPERDBMA_TB_CHECK_VIP2_CONF_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT HA_ROLE, VIRTUAL_IP2, RESERVED FROM TB_INSTANCE_INFO WHERE INSTANCE_ID = #{instance_id} ;
		 ]]>	
	</select>
<!-- Check Virtual IP ENd -->

<!-- ********************************************************** -->
<!-- ReplCollect End -->
<!-- ********************************************************** -->
	<update id="TB_SET_LOCK_TIMEOUT_U001" parameterType="hashmap" >
		<![CDATA[
			set lock_timeout = 20000;
		]]>
    </update>
    
    
<!-- ********************************************************** -->
<!-- HA Group Alert -->
<!-- ********************************************************** -->  
<select id="EXPERDBMA_BT_HCHK_HGCPUUTIL_001" parameterType="hashmap" resultType="hashmap">
	SELECT /* EXPERDBMA_BT_HCHK_HGCPUUTIL_001 */
			HA_GROUP INSTANCE_ID, AVG(CPUUTIL) HGCPUUTIL, MAX(COLLECT_GROUP) COLLECT_GROUP, MAX(COLLECT_REG_DATE) COLLECT_REG_DATE, MIN(COLLECT_REG_SEQ) COLLECT_REG_SEQ,  CURRENT_TIME AS REG_TIME
	  FROM
	  (
			SELECT   RCM.INSTANCE_ID,
			         CASE WHEN CPU.USER_UTIL_RATE + CPU.NICE_UTIL_RATE + CPU.SYS_UTIL_RATE + CPU.WAIT_UTIL_RATE > 100 THEN 100 ELSE CPU.USER_UTIL_RATE + CPU.NICE_UTIL_RATE + CPU.SYS_UTIL_RATE + CPU.WAIT_UTIL_RATE END AS CPUUTIL,
			         '3' AS COLLECT_GROUP,
			         CPU.REG_DATE AS COLLECT_REG_DATE,
			         CPU.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
			         CURRENT_TIME AS REG_TIME,
					 IST.HA_GROUP
			  FROM TB_RSC_COLLECT_INFO AS RCM,
			          TB_INSTANCE_INFO  AS IST,
			          TB_CPU_STAT_MASTER CPU
			WHERE CPU.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
			   AND CPU.REG_DATE = RCM.REG_DATE
			   AND CPU.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
			   AND CPU.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
			   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
				AND IST.COLLECT_YN = 'Y'             
	   AND IST.DELETE_YN='N'
	  ) HACPUUTIL
	GROUP BY HA_GROUP
</select>
	
	
<select id="EXPERDBMA_BT_HCHK_HGCPUWAIT_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMA_BT_HCHK_HGCPUWAIT_001 */
				HA_GROUP INSTANCE_ID, AVG(CPUWAIT) HGCPUWAIT, MAX(COLLECT_GROUP) COLLECT_GROUP, MAX(COLLECT_REG_DATE) COLLECT_REG_DATE, MIN(COLLECT_REG_SEQ) COLLECT_REG_SEQ,  CURRENT_TIME AS REG_TIME
		FROM (
				SELECT   RCM.INSTANCE_ID,
				         WAIT_UTIL_RATE AS CPUWAIT,
				         '3' AS COLLECT_GROUP,
				         CPU.REG_DATE AS COLLECT_REG_DATE,
				         CPU.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
				         CURRENT_TIME AS REG_TIME,
				         IST.HA_GROUP
				  FROM TB_RSC_COLLECT_INFO AS RCM,
				          TB_INSTANCE_INFO  AS IST,
				          TB_CPU_STAT_MASTER CPU
				WHERE CPU.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
				   AND CPU.REG_DATE = RCM.REG_DATE
				   AND CPU.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
				   AND CPU.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
				   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
					AND IST.COLLECT_YN = 'Y'             
				   AND IST.DELETE_YN='N'
		   ) HACPUWAIT
		GROUP BY HA_GROUP
</select>
	
<select id="EXPERDBMA_BT_HCHK_HAMEMUSAGE_001" parameterType="hashmap" resultType="hashmap">
		SELECT /* EXPERDBMA_BT_HCHK_HAMEMUSAGE_001 */
				HA_GROUP INSTANCE_ID, AVG(MEMUSAGE) HGMEMUSAGE, MAX(COLLECT_GROUP) COLLECT_GROUP, MAX(COLLECT_REG_DATE) COLLECT_REG_DATE, MIN(COLLECT_REG_SEQ) COLLECT_REG_SEQ,  CURRENT_TIME AS REG_TIME
		FROM (
				SELECT   RCM.INSTANCE_ID,
				         CASE WHEN MEM.MEM_TOTAL_KB != 0 THEN (((MEM.MEM_TOTAL_KB - (MEM.MEM_FREE_KB +MEM.MEM_BUFFERED_KB + MEM.MEM_CACHED_KB)) / MEM.MEM_TOTAL_KB ) * 100)::int ELSE MEM.MEM_TOTAL_KB END AS MEMUSAGE,
				         '3' AS COLLECT_GROUP,
				         MEM.REG_DATE AS COLLECT_REG_DATE,
				         MEM.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
				         CURRENT_TIME AS REG_TIME,
				         IST.HA_GROUP
				  FROM TB_RSC_COLLECT_INFO AS RCM,
				          TB_INSTANCE_INFO  AS IST,
				          TB_MEMORY_STAT MEM
				WHERE MEM.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
				   AND MEM.REG_DATE = RCM.REG_DATE
				   AND MEM.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
				   AND MEM.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
				   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
					AND IST.COLLECT_YN = 'Y'             
				   AND IST.DELETE_YN='N'
			) HAMEMUSAGE
		GROUP BY HA_GROUP
</select>
	
	
<select id="EXPERDBMA_BT_HCHK_HGSWAPUSAGE_001" parameterType="hashmap" resultType="hashmap">
SELECT /* EXPERDBMA_BT_HCHK_HGSWAPUSAGE_001 */
		HA_GROUP INSTANCE_ID, AVG(SWAPUSAGE) HGSWAPUSAGE, MAX(COLLECT_GROUP) COLLECT_GROUP, MAX(COLLECT_REG_DATE) COLLECT_REG_DATE, MIN(COLLECT_REG_SEQ) COLLECT_REG_SEQ,  CURRENT_TIME AS REG_TIME
FROM (
		SELECT RCM.INSTANCE_ID,
		         /*ROUND((MEM.SWP_USED_KB - MEM.SWP_CACHED_KB) / SWP_TOTAL_KB * 100, 2) AS SWAPUSAGE,*/
		         CASE WHEN SWP_TOTAL_KB=0 THEN 0 ELSE ROUND((MEM.SWP_USED_KB - MEM.SWP_CACHED_KB) / SWP_TOTAL_KB * 100, 2) END AS SWAPUSAGE,
		         '3' AS COLLECT_GROUP,
		         MEM.REG_DATE AS COLLECT_REG_DATE,
		         MEM.RSC_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
		         CURRENT_TIME AS REG_TIME, 	
				 IST.HA_GROUP
		  FROM TB_RSC_COLLECT_INFO AS RCM,
		          TB_INSTANCE_INFO  AS IST,
		          TB_MEMORY_STAT MEM
		WHERE MEM.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
		   AND MEM.REG_DATE = RCM.REG_DATE
		   AND MEM.RSC_REG_SEQ = (SELECT MAX(X.RSC_REG_SEQ) FROM TB_RSC_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
		   AND MEM.RSC_REG_SEQ = RCM.RSC_REG_SEQ  
		   AND IST.INSTANCE_ID = RCM.INSTANCE_ID   
			AND IST.COLLECT_YN = 'Y'             
		   AND IST.DELETE_YN='N'
) HASWAPUSAGE
GROUP BY HA_GROUP
	</select>
	
<select id="EXPERDBMA_BT_HCHK_HGCONNECTION_001" parameterType="hashmap" resultType="hashmap">
	<![CDATA[
	SELECT /* EXPERDBMA_BT_HCHK_HGCONNECTION_001 */
			HA_GROUP INSTANCE_ID, AVG(ACTIVECONNECTION) HGACTIVECONNECTION, MAX(COLLECT_GROUP) COLLECT_GROUP, MAX(COLLECT_REG_DATE) COLLECT_REG_DATE, MIN(COLLECT_REG_SEQ) COLLECT_REG_SEQ,  CURRENT_TIME AS REG_TIME
	  FROM (
			SELECT   ACM.INSTANCE_ID,
			         ROUND(SUM(1)::NUMERIC/MAX(IST.MAX_CONN_CNT) * 100, 2) AS ACTIVECONNECTION,
			         SUM(CASE WHEN STATE = 'idle in transaction' THEN 1 ELSE 0 END)  AS TRAXIDLECNT,
			         MAX(ELAPSED_TIME) AS LONGRUNSQL,
			         '2' AS COLLECT_GROUP,
			         BAK.REG_DATE AS COLLECT_REG_DATE,
			         BAK.ACTV_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
			         CURRENT_TIME AS REG_TIME,
			         IST.HA_GROUP
			 FROM TB_ACTV_COLLECT_INFO AS ACM,
			         TB_INSTANCE_INFO AS IST,
			         TB_BACKEND_RSC AS BAK
			WHERE BAK.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD')
			   AND BAK.REG_DATE = ACM.REG_DATE
			   AND BAK.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=IST.INSTANCE_ID )
			   AND BAK.ACTV_REG_SEQ = ACM.ACTV_REG_SEQ
			   AND IST.INSTANCE_ID = ACM.INSTANCE_ID
				AND IST.COLLECT_YN = 'Y'
			   AND IST.DELETE_YN='N'
			GROUP BY BAK.REG_DATE,BAK.ACTV_REG_SEQ,ACM.INSTANCE_ID,IST.HA_GROUP
		) HACONNECTION
	GROUP BY HA_GROUP
	]]>
</select>
<!-- HG Group Alert ENd -->
<!-- Check solution Start -->
	<select id="TB_INSTANCE_INFO_S002" parameterType="hashmap" resultType="hashmap">
			SELECT INSTANCE_ID, WITHSOLUTIONS, STATSOLUTIONS
			  FROM TB_INSTANCE_INFO
			 WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N' AND WITHSOLUTIONS is not null and WITHSOLUTIONS > 0
			 ORDER BY INSTANCE_ID
	</select>
	
	<select id="EXPERDBMA_BT_CHECK_READONLY_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT pg_is_in_recovery() ISRECOVERY;
		 ]]>	
	</select>
	<update id="EXPERDBMA_BT_CREATE_PLPERL_001" parameterType="hashmap">
		<![CDATA[
			/* EXPERDBMA_BT_CREATE_PLPERL_001 24E9AB7301FF1966DA4FB30DC1538882*/
				DO $$
				DECLARE       
				    is_in_recovery BOOL;
				BEGIN    
				    is_in_recovery := (SELECT PG_IS_IN_RECOVERY());       
				    IF is_in_recovery = FALSE THEN           
					    EXECUTE FORMAT('CREATE EXTENSION IF NOT EXISTS plperlu') ;     
				    END IF;       
				END $$
				]]>	
	</update>
		
	<update id="EXPERDBMA_BT_CREATE_FUNCTION_001" parameterType="hashmap">
		<![CDATA[
		/* EXPERDBMA_BT_CREATE_FUNCTION_001 24E9AB7301FF1966DA4FB30DC1538882*/
		DO $$
		DECLARE       
		    is_in_recovery BOOL;
		BEGIN    
		    is_in_recovery := (SELECT PG_IS_IN_RECOVERY());       
		    IF is_in_recovery = FALSE THEN           
			    EXECUTE FORMAT('CREATE EXTENSION IF NOT EXISTS plperlu') ;     
			    EXECUTE FORMAT('		CREATE OR REPLACE FUNCTION PSS() RETURNS text AS $BODY$
				    use warnings;
				    use strict;
					my $res;
					my $man = `ps -ef|grep eXperDB-Management-Agent|grep -v grep |wc -l`;
				    my $enc = `ps -ef|grep eXperDB-Encrypt-Agent|grep -v grep|wc -l`;
					if ($man > 0) {$man = 1}
					else {$man = 0}
					if ($enc > 0){ $enc = 2}
					else{$enc = 0	}
					$res = $enc + $man;
				    return($res);
				$BODY$ LANGUAGE plperlu;');     
		    END IF;       
		 END $$
		]]>	
	</update>
	
	<select id="EXPERDBMA_BT_CHECK_SOLUTION_001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		SELECT PSS()::int8 STATSOLUTIONS;
		]]>
	</select>
	
	<update id="TB_INSTANCE_INFO_U005" parameterType="hashmap" >
		<![CDATA[
		UPDATE TB_INSTANCE_INFO 
		   SET STATSOLUTIONS = #{statsolutions} 
		 WHERE instance_id = #{instance_id} ;
		]]>
	</update>

	<update id="TB_SNAPSHOT_INFO_C001" parameterType="hashmap">
		<![CDATA[
			DO $$
			DECLARE       
			    is_exists_fs BOOL;
			    instance_id TEXT;
			BEGIN
				instance_id = '${instance_id}';
			    is_exists_fs := (SELECT EXISTS(SELECT 1 FROM node_show() WHERE node_name = instance_id));       
			    IF is_exists_fs = FALSE THEN
			    	PERFORM NODE_NEW(instance_id::varchar, 'host=' || '${server_ip}' || ' port=' || '${service_port}' ||' dbname=' || '${conn_db_name}' || ' user=' || '${conn_user_id}' || ' password=' || '${conn_user_pwd}');
			    END IF;
			END $$
		  ]]>	  
	</update>
	<select id="TB_SNAPSHOT_INFO_S001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
		SELECT enabled FROM node_show() WHERE node_name = CAST(#{instance_id} AS VARCHAR);
		]]>
	</select>
	<update id="TB_SNAPSHOT_INFO_U001" parameterType="hashmap" >
		<![CDATA[
		SELECT /* TB_SNAPSHOT_INFO_U001 24E9AB7301FF1966DA4FB30DC1538882*/
		 		snapshot(CAST(#{instance_id} AS VARCHAR));
		]]>
	</update>
	
	<update id="TB_CREATE_PROFILE_001" parameterType="hashmap">
		<![CDATA[
        /* TB_CREATE_PROFILE_001 24E9AB7301FF1966DA4FB30DC1538882*/
         DO $$
         DECLARE
                 is_exist BOOL;
         BEGIN
                 is_exist := (SELECT EXISTS(SELECT 1 FROM PG_EXTENSION WHERE EXTNAME = 'pg_profile'));
                 IF is_exist = FALSE THEN
                         EXECUTE FORMAT('CREATE EXTENSION IF NOT EXISTS pg_profile cascade') ;
                 END IF;
                 PERFORM PG_RELOAD_CONF();
         EXCEPTION
                 WHEN others THEN
         END $$
				]]>	
	</update>
	
	<insert id="TB_INSERT_RECENT_PGSS_I001" parameterType="hashmap" >
		<![CDATA[	
		WITH UPSERT AS (
		UPDATE tb_pgss_reset
		   SET instance_id = #{instance_id},
		       COLLECT_DT = (select collect_dt from tb_pg_stat_statements where instance_id = #{instance_id} and reg_date = to_char(current_timestamp, 'YYYYMMDD') order by collect_dt desc limit 1)		  
		 WHERE INSTANCE_ID = #{instance_id}
		RETURNING *) 
		INSERT INTO tb_pgss_reset (INSTANCE_ID, COLLECT_DT)
		SELECT #{instance_id}, current_timestamp 
		 WHERE NOT EXISTS(SELECT 1 FROM UPSERT);
				]]>	
	</insert>
				
	<update id="PG_CREATE_FN_LONGSQL_FILTERING_COND" parameterType="hashmap">
		<![CDATA[
 		 	  CREATE OR REPLACE FUNCTION GET_LONGSQL_FILTERING_COND()
				  RETURNS TEXT AS 
				  $$
			  DECLARE    
			      VAR_INSTANCE_ID INT;
  			      VAR_COND_LEFT VARCHAR;
  			      VAR_COND_RIGHT VARCHAR;
  			      VAR_COND VARCHAR;
			      TMP_CONDTYPE VARCHAR;
			      TMP_STR VARCHAR;
			      VAR_RETURN VARCHAR;
			  BEGIN    
				  VAR_INSTANCE_ID = -1;
				  VAR_RETURN = '';
				  FOR VAR_INSTANCE_ID IN
	        		  SELECT INSTANCE_ID INSTANCEID FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN='N'	order by instance_id        		
			      loop
					  VAR_COND_LEFT := '''ZZ'' ';
					  VAR_COND_RIGHT := '''ZZ'' ';
			    	  FOR tmp_condtype, tmp_str IN
					      SELECT JSONB_ARRAY_ELEMENTS(RESERVED_STR::JSONB)->>'coltype' CONDTYPE,
					             JSONB_ARRAY_ELEMENTS(RESERVED_STR::JSONB)->>'typestr' STR FROM TB_HCHK_THRD_LIST THTL WHERE INSTANCE_ID = VAR_INSTANCE_ID AND HCHK_NAME = 'LONGRUNSQL' AND RESERVED_STR <> '' ORDER BY CONDTYPE
					  loop
						  if tmp_condtype = '1' then
							  VAR_COND_LEFT := VAR_COND_LEFT || ' ||BAK.USER_NAME';
							  VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || tmp_str || '''';
					      elseif tmp_condtype = '2' then 
							  VAR_COND_LEFT := concat(VAR_COND_LEFT, '||BAK.DB_NAME');
							  VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || tmp_str || '''';
					      elseif tmp_condtype = '3' then
							  VAR_COND_LEFT := concat(VAR_COND_LEFT, '||BAK.CLIENT_ADDR');
							  VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || tmp_str || '''';
					      end if;
					  end loop;
					  if VAR_COND_RIGHT <> '''ZZ'' ' then
					      VAR_COND_LEFT := concat(VAR_COND_LEFT, '||TAC.INSTANCE_ID');
					      VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || VAR_INSTANCE_ID || '''';
						  VAR_COND := ' AND ' || VAR_COND_LEFT || '<>' || VAR_COND_RIGHT;
					  else
						  VAR_COND := ' ';
					  end if;
				      VAR_RETURN := VAR_RETURN || VAR_COND;
   					  RAISE NOTICE 'VAR_INSTANCE_ID: %', VAR_INSTANCE_ID;
   					  RAISE NOTICE 'VAR_COND: %', VAR_COND;
   				      RAISE NOTICE 'VAR_RETURN: %', VAR_RETURN;
			      END LOOP;
			      return VAR_RETURN;
 			  END $$
 			  LANGUAGE 'plpgsql';
		]]>	
	</update>
	<select id="BT_SERVER_ENCODING_INFO_S001" parameterType="hashmap" resultType="hashmap">
		<![CDATA[
			SELECT current_setting('server_encoding') as server_encoding
		]]>
	</select>
<!-- Check solution End -->
</mapper>
