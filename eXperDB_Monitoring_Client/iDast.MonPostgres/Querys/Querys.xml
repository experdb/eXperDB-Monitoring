<?xml version="1.0" encoding="utf-8"?>
<ROWS>
  <ROW ID="CHECKPASSWORD" PARAMS="2">
    <DESC>Check User Password</DESC>
    <DATA>
      <![CDATA[
      SELECT COUNT(*) FROM TB_CONFIG WHERE ADMIN_USER_ID = '{0}' AND ADMIN_PASSWORD = '{1}'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="GETDATABASELIST" PARAMS="0">
    <DESC>Get Database List</DESC>
    <DATA>
      <![CDATA[
      SELECT DATNAME FROM PG_DATABASE
    ]]>
    </DATA>
  </ROW>
  <ROW ID="GETSCHEMALIST" PARAMS="0">
    <DESC>Get Database Schema List</DESC>
    <DATA>
      <![CDATA[
      SELECT NSPNAME FROM PG_NAMESPACE
    ]]>
    </DATA>
  </ROW>
  <ROW ID="UPDATECONFIG" PARAMS="6">
    <DESC>Server Batch Log Keep Days</DESC>
    <DATA>
      <![CDATA[
        UPDATE TB_CONFIG 
          SET LOG_KEEP_DAYS = {0} 
            , LAST_MOD_IP = '{1}' 
            , LAST_MOD_DT = NOW() 
            , DAILY_BATCH_START_TIME = '{2}'
            , HCHK_PERIOD_SEC = '{3}'
            , OBJT_PERIOD_SEC = '{4}'
            , STMT_PERIOD_SEC = '{5}'
            , TREPORT_KEEP_DAYS = {6} 
        WHERE ADMIN_USER_ID='ADMIN'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="UPDATEPASSWORD_OLD" PARAMS="2">
    <DESC>Update password</DESC>
    <DATA>
      <![CDATA[
        UPDATE TB_CONFIG 
          SET ADMIN_PASSWORD = '{1}'
        WHERE ADMIN_USER_ID='{0}'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="UPDATESERVERCONNINFO" PARAMS="3">
    <DESC>Server connection information</DESC>
    <DATA>
      <![CDATA[
        UPDATE TB_CONFIG 
          SET AGENT_IP = '{0}' 
            , AGENT_PORT = {1} 
            , LAST_MOD_IP = '{2}' 
            , LAST_MOD_DT = NOW() 
        WHERE ADMIN_USER_ID='ADMIN'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="UPDATEPASSWORD" PARAMS="2">
    <DESC>Update password</DESC>
    <DATA>
      <![CDATA[
        UPDATE TB_MON_USER
          SET USER_PASSWORD = '{1}'
          , SET_PW_DT = NOW()
        WHERE USER_ID='{0}'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTCONFIG" PARAMS="0">  
    <DESC>Server Batch Log Keep Days</DESC>
    <DATA>
      <![CDATA[
        SELECT COALESCE(LOG_KEEP_DAYS,-1) AS LOG_KEEP_DAYS
           ,COALESCE(TREPORT_KEEP_DAYS,-1) AS TREPORT_KEEP_DAYS
           ,DAILY_BATCH_START_TIME 
           ,AGENT_IP
           ,AGENT_PORT
           ,HCHK_PERIOD_SEC
           ,OBJT_PERIOD_SEC
           ,STMT_PERIOD_SEC
           ,VERSION
           ,20 TOPN
           ,10 RETENTION
        FROM TB_CONFIG 
        WHERE ADMIN_USER_ID='ADMIN'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTCONFIG_20201210_for_ssg" PARAMS="0">
    <DESC>Server Batch Log Keep Days</DESC>
    <DATA>
      <![CDATA[
        SELECT COALESCE(LOG_KEEP_DAYS,-1) AS LOG_KEEP_DAYS
           ,COALESCE(TREPORT_KEEP_DAYS,-1) AS TREPORT_KEEP_DAYS
           ,DAILY_BATCH_START_TIME 
           ,AGENT_IP
           ,AGENT_PORT
           ,HCHK_PERIOD_SEC
           ,OBJT_PERIOD_SEC
           ,STMT_PERIOD_SEC
           ,VERSION
           ,current_setting('pg_profile.topn') TOPN
           ,current_setting('pg_profile.retention') RETENTION
        FROM TB_CONFIG 
        WHERE ADMIN_USER_ID='ADMIN'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="NEXTVAL" PARAMS="1">
    <DESC>SEQUENCE NEXT</DESC>
    <DATA>
      <![CDATA[
      SELECT NEXTVAL('{0}')
    ]]>
    </DATA>
  </ROW>
  <ROW ID="CURRVAL" PARAMS="1">
    <DESC>SEQUENCE CURRENT</DESC>
    <DATA>
      <![CDATA[
      SELECT CURRVAL('{0}')
    ]]>
    </DATA>
  </ROW>
  <ROW ID="SETVAL" PARAMS="2">
    <DESC>SEQUENCE SET</DESC>
    <DATA>
      <![CDATA[
      SELECT SETVAL('{0}',{1})
    ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTGROUPNAME" PARAMS="2">
    <DESC>SELECTGROUPNAME</DESC>
    <DATA>
      <![CDATA[
      SELECT GROUP_NAME, CLOUD_GROUP FROM TB_GROUP_INFO WHERE GROUP_ID = {0} ORDER BY GROUP_ID
    ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTSERVERVERSION" PARAMS="2">
    <DESC>SELECTSERVERVERSION</DESC>
    <DATA>
      <![CDATA[
      SELECT VERSION FROM TB_CONFIG
    ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTSERVERLIST" PARAMS="12">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
      INSERT INTO TB_INSTANCE_INFO 
      (INSTANCE_ID
      ,SERVER_IP
      ,SERVICE_PORT
      ,DBMS_TYPE
      ,CONN_USER_ID
      ,CONN_USER_PWD
      ,COLLECT_YN
      ,COLLECT_PERIOD_SEC
      ,RTSTMT_PERIOD_SEC
      ,SNAP_PERIOD_MIN
      ,CONN_DB_NAME
      ,CONN_NAME
      ,LAST_MOD_IP
      ,LAST_MOD_DT
      ,CONN_SCHEMA_NAME
      ,DELETE_YN
      ,HA_ROLE
      ,HA_HOST
      ,HA_PORT
      ,HA_REPL_HOST)
      VALUES
      ('{0}'   
      ,'{1}'
      ,'{2}'
      ,'{3}'
      ,'{4}'
      ,'{5}'
      ,'{6}'
      ,'{7}'
      ,'{8}'
      ,'{9}'
      ,'{10}'
      ,'{11}'
      ,'{12}'
      ,NOW()
      ,'{13}'      
      ,'N'
      ,'{14}'
      ,'{15}'
      ,'{16}'
      ,'{17}')
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTSERVERLIST" PARAMS="0">
    <DESC>서버 목록을 가져온다.</DESC>
    <DATA>
      <![CDATA[ 
      SELECT
         INSTANCE_ID
        ,SERVER_IP
        ,SERVICE_PORT
        ,DBMS_TYPE
        ,CONN_USER_ID
        ,CONN_USER_PWD
        ,COLLECT_YN
        ,COLLECT_PERIOD_SEC
        ,CONN_DB_NAME
        ,CONN_NAME
        ,LAST_MOD_IP
        ,LAST_MOD_DT
        ,CONN_SCHEMA_NAME
        ,CASE WHEN HOST_NAME ISNULL THEN CONN_NAME ELSE COALESCE(HOST_NAME, '') END AS HOST_NAME
        ,HA_ROLE
        ,HA_HOST
        ,INSTANCE_UPTIME::TIMESTAMP(0) AS INSTANCE_UPTIME
      FROM TB_INSTANCE_INFO 
      WHERE DELETE_YN = 'N' AND COLLECT_YN = 'Y'
   ORDER BY INSTANCE_ID
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTMONLISTBYGROUP" PARAMS="0">
    <DESC>서버 목록을 가져온다.</DESC>
    <DATA>
      <![CDATA[ 
      SELECT
         A.INSTANCE_ID
        ,B.INSTANCE_SEQ
        ,SERVER_IP
        ,SERVICE_PORT
        ,DBMS_TYPE
        ,CONN_USER_ID
        ,CONN_USER_PWD
        ,COLLECT_YN
        ,B.GROUP_ID
        ,COLLECT_PERIOD_SEC
        ,CONN_DB_NAME
        ,CONN_NAME
        ,B.LAST_MOD_IP
        ,B.LAST_MOD_DT
        ,CONN_SCHEMA_NAME
        ,HOST_NAME
        ,INSTANCE_UPTIME::TIMESTAMP(0) AS INSTANCE_UPTIME
        ,HA_ROLE
        ,HA_HOST
        ,HA_PORT
        ,HA_GROUP
        ,SPLIT_PART(SPLIT_PART(PG_VERSION, ' ', 2), '.', 1)  || '.' || SPLIT_PART(SPLIT_PART(PG_VERSION, ' ', 2), '.', 2) AS PG_VERSION
      FROM TB_INSTANCE_INFO A JOIN TB_GROUP_INSTANCE_INFO B ON A.INSTANCE_ID = B.INSTANCE_ID
      WHERE DELETE_YN = 'N' AND COLLECT_YN = 'Y' 
      AND B.GROUP_ID = {0}
      ORDER BY B.INSTANCE_SEQ, A.INSTANCE_ID
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTSERVERLISTBYGROUP" PARAMS="0">
    <DESC>서버 목록을 가져온다.</DESC>
    <DATA>
      <![CDATA[ 
      SELECT
         INSTANCE_ID
        ,SERVER_IP
        ,SERVICE_PORT
        ,DBMS_TYPE
        ,CONN_USER_ID
        ,CONN_USER_PWD
        ,COLLECT_YN
        ,MON_GROUP
        ,COLLECT_PERIOD_SEC
        ,CONN_DB_NAME
        ,CONN_NAME
        ,LAST_MOD_IP
        ,LAST_MOD_DT
        ,CONN_SCHEMA_NAME
        ,HOST_NAME
        ,INSTANCE_UPTIME::TIMESTAMP(0) AS INSTANCE_UPTIME
        ,HA_ROLE
        ,HA_HOST
        ,HA_PORT
        ,HA_GROUP
        ,SPLIT_PART(SPLIT_PART(PG_VERSION, ' ', 2), '.', 1)  || '.' || SPLIT_PART(SPLIT_PART(PG_VERSION, ' ', 2), '.', 2) AS PG_VERSION
      FROM TB_INSTANCE_INFO 
      WHERE DELETE_YN = 'N' AND COLLECT_YN = 'Y'
   ORDER BY INSTANCE_ID
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
	<ROW ID="SELECTSERVERLISTADMIN" PARAMS="0">
		<DESC>서버 목록을 가져온다.</DESC>
		<DATA>
			<![CDATA[ 
      SELECT
         INSTANCE_ID
        ,SERVER_IP
        ,SERVICE_PORT
        ,DBMS_TYPE
        ,CONN_USER_ID
        ,CONN_USER_PWD
        ,COLLECT_YN
        ,COLLECT_PERIOD_SEC
        ,RTSTMT_PERIOD_SEC
        ,COALESCE(SNAP_PERIOD_MIN, 0) AS SNAP_PERIOD_MIN
        ,CONN_DB_NAME
        ,CONN_NAME
        ,LAST_MOD_IP
        ,LAST_MOD_DT
        ,CONN_SCHEMA_NAME
        ,HOST_NAME
        ,INSTANCE_UPTIME::TIMESTAMP(0) AS INSTANCE_UPTIME
        ,HA_ROLE
        ,HA_HOST
        ,HA_PORT
        ,HA_REPL_HOST
        ,VIRTUAL_IP
        ,VIRTUAL_IP2
      FROM TB_INSTANCE_INFO 
      WHERE DELETE_YN = 'N' 
   ORDER BY INSTANCE_ID
    ]]>
		</DATA>
		<COMMENTS />
	</ROW>
  <ROW ID="UPDATESERVERLIST" PARAMS="20">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
      UPDATE TB_INSTANCE_INFO 
      SET SERVER_IP = '{1}' 
        ,SERVICE_PORT = '{2}' 
        ,DBMS_TYPE = '{3}' 
        ,CONN_USER_ID = '{4}' 
        ,CONN_USER_PWD = '{5}'
        ,COLLECT_YN = '{6}' 
        ,COLLECT_PERIOD_SEC = '{7}' 
        ,RTSTMT_PERIOD_SEC = '{8}' 
        ,SNAP_PERIOD_MIN = '{9}' 
        ,CONN_DB_NAME = '{10}' 
        ,CONN_NAME = '{11}' 
        ,LAST_MOD_IP = '{12}' 
        ,LAST_MOD_DT = NOW()
        ,CONN_SCHEMA_NAME = '{13}'
        ,DELETE_YN='N'
        ,HA_ROLE = '{14}'
        ,HA_HOST = '{15}'
        ,HA_PORT = '{16}'
        ,HA_REPL_HOST = '{17}'
        ,VIRTUAL_IP = CASE WHEN LENGTH('{18}') = 0 THEN NULL ELSE '{18}' END
        ,VIRTUAL_IP2 = CASE WHEN LENGTH('{19}') = 0 THEN NULL ELSE '{19}' END
        ,HCHK_PERIOD_SEC = '{20}' 
      WHERE INSTANCE_ID = {0}
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="DELETESERVERLIST" PARAMS="12">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
      UPDATE TB_INSTANCE_INFO 
      SET  DELETE_YN ='Y'
        ,LAST_MOD_IP = '{1}' 
        ,LAST_MOD_DT = NOW()
      WHERE INSTANCE_ID = {0}
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="UPDATEMONGROUP" PARAMS="12">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
      UPDATE TB_INSTANCE_INFO 
      SET MON_GROUP = {1} 
        ,LAST_MOD_IP = '{2}' 
        ,LAST_MOD_DT = NOW()
      WHERE INSTANCE_ID = {0}
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="RESETCLOUDGROUP" PARAMS="2">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
	        UPDATE TB_GROUP_INFO SET CLOUD_GROUP = FALSE, LAST_MOD_IP = '{1}', LAST_MOD_DT = NOW();
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="UPDATEGROUP" PARAMS="4">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
        UPDATE TB_GROUP_INFO SET GROUP_NAME = '{1}', CLOUD_GROUP = {2}, LAST_MOD_IP = '{3}', LAST_MOD_DT = NOW() WHERE GROUP_ID = {0};
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="DELETEMONLIST" PARAMS="1">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
      DELETE FROM TB_GROUP_INSTANCE_INFO WHERE GROUP_ID = {0}
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="INSERTMONLIST" PARAMS="3">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
      INSERT INTO TB_GROUP_INSTANCE_INFO (GROUP_ID, INSTANCE_SEQ, INSTANCE_ID, LAST_MOD_IP) VALUES ({0}, {1}, {2},'{3}')
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTCPUMEMINFO" PARAMS="0">
    <DESC>PT_03_03_001 (cpu/mem정보)</DESC>
    <DATA>
      <![CDATA[
        SELECT /* SELECTCPUMEMINFO */ A.INSTANCE_ID
        , C.COLLECT_DT AS REG_DATE
        , CASE WHEN C.USER_UTIL_RATE + C.NICE_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE > 100 THEN 100 ELSE C.USER_UTIL_RATE + C.NICE_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE END AS CPU_MAIN                                          --PT_03_03_001, PT_04_02_001(AVG)
        , 0 as CPU_LOGICAL_ID                                                                                                                --PT_04_02_001
        , 0 AS CORE_CPU_RATE
        --, (SELECT SUM(PROC_CPU_UTIL) FROM TB_BACKEND_RSC RSC WHERE RSC.REG_DATE = B.REG_DATE AND RSC.RSC_REG_SEQ = B.RSC_REG_SEQ) AS PGSQL_UTIL_RATE   --PT_04_05_001(CPU_PG)
        , C.WAIT_UTIL_RATE                                                                                                                --PT_04_05_001(CPU_WAIT)
        , CASE WHEN E.MEM_TOTAL_KB != 0 THEN (((E.MEM_TOTAL_KB - (E.MEM_FREE_KB +E.MEM_BUFFERED_KB + E.MEM_CACHED_KB)) / E.MEM_TOTAL_KB ) * 100)::int ELSE E.MEM_TOTAL_KB END AS MEM_USED_RATE       --PT_03_03_001, PT_04_02_001(MEM_AVG)
        , CASE WHEN E.SWP_TOTAL_KB != 0 THEN (((E.SWP_TOTAL_KB - (E.SWP_FREE_KB + E.SWP_CACHED_KB)) / E.SWP_TOTAL_KB) * 100)::int ELSE E.SWP_TOTAL_KB END AS SWP_USED_RATE                         --PT_03_03_001(MEM SWAP_RATE), PT_04_05_001(PG_MEMORY)
        , (E.MEM_TOTAL_KB / 1024)::int AS MEM_TOTAL_MB                                                                                    --PT_04_05_001(TOTAL MEM)
        , (E.MEM_USED_KB / 1024)::int AS MEM_USED_MB                                                                                      --PT_04_05_001(USED MEM)
        , (E.MEM_FREE_KB / 1024)::int AS MEM_FREE_MB                                                                                      --PT_04_05_001(FREE MEM)
        , (E.SHM_KB / 1024)::int  AS SHM_MB                                                                                               --PT_04_05_001(SHARED MEM)
        , (E.MEM_BUFFERED_KB / 1024)::int AS MEM_BUFFERED_MB                                                                              --PT_04_05_001(BUFFERS MEM)
        , (E.MEM_CACHED_KB / 1024)::int AS MEM_CACHED_MB                                                                                  --PT_04_05_001(CACHED MEM)
        , (E.SWP_TOTAL_KB / 1024)::int AS SWP_TOTAL_MB                                                                                    --PT_04_05_001(SWAP_TOTAL MEM)
        , (E.SWP_USED_KB / 1024)::int AS SWP_USED_MB                                                                                      --PT_04_05_001(SWAP_USED MEM)
        , (E.SWP_FREE_KB / 1024)::int AS SWP_FREE_MB                                                                                      --PT_04_05_001(SWAP_FREE MEM)
		    , (E.SWP_CACHED_KB / 1024)::int AS SWP_CACHED_MB                                                                                      --PT_04_05_001(SWAP_CACHED MEM)  
        , (((E.MEM_TOTAL_KB - (E.MEM_FREE_KB )) / E.MEM_TOTAL_KB ) * 100) AS BUFFER_RATE                                           --PT_03_03_001, PT_04_02_001(MEM_AVG)
        , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
        , A.HA_GROUP
        , CASE WHEN {1}=0 THEN TO_CHAR(A.INSTANCE_ID, '00')||A.HOST_NAME ELSE TO_CHAR(A.INSTANCE_ID, '00')||A.CONN_NAME END AS SORTED_HOST_NAME
        FROM TB_INSTANCE_INFO A
             , (SELECT MAX(REG_DATE) AS REG_DATE, MAX(REG_TIME) AS REG_TIME, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID 
                 FROM TB_RSC_COLLECT_INFO 
                WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') 
                  AND RSC_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) * 2 + 1 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM RSC_REG_SEQ)
                GROUP BY INSTANCE_ID) B
             --, TB_CPU_STAT_MASTER C, TB_MEMORY_STAT E
             , TB_CPU_STAT_MASTER C, TB_MEMORY_STAT E
        WHERE A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N'  
          AND A.INSTANCE_ID IN ({0})
          AND B.REG_DATE = C.REG_DATE
          AND C.REG_DATE = E.REG_DATE
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
          AND C.RSC_REG_SEQ = E.RSC_REG_SEQ
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTCPUMEMINFO_20201026" PARAMS="0">
    <DESC>PT_03_03_001 (cpu/mem정보)</DESC>
    <DATA>
      <![CDATA[
        SELECT /* SELECTCPUMEMINFO */ A.INSTANCE_ID
        , C.COLLECT_DT AS REG_DATE
        , CASE WHEN C.USER_UTIL_RATE + C.NICE_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE > 100 THEN 100 ELSE C.USER_UTIL_RATE + C.NICE_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE END AS CPU_MAIN                                          --PT_03_03_001, PT_04_02_001(AVG)
        , 0 as CPU_LOGICAL_ID                                                                                                                --PT_04_02_001
        , 0 AS CORE_CPU_RATE
        --, D.CPU_LOGICAL_ID                                                                                                                --PT_04_02_001
        --, CASE WHEN D.USER_UTIL_RATE + D.NICE_UTIL_RATE + D.SYS_UTIL_RATE + D.WAIT_UTIL_RATE > 100 THEN 100 ELSE D.USER_UTIL_RATE + D.NICE_UTIL_RATE + D.SYS_UTIL_RATE + D.WAIT_UTIL_RATE END AS CORE_CPU_RATE                                     --PT_04_02_001
        --, (SELECT SUM(PROC_CPU_UTIL) FROM TB_BACKEND_RSC RSC WHERE RSC.REG_DATE = B.REG_DATE AND RSC.RSC_REG_SEQ = B.RSC_REG_SEQ) AS PGSQL_UTIL_RATE   --PT_04_05_001(CPU_PG)
        , C.WAIT_UTIL_RATE                                                                                                                --PT_04_05_001(CPU_WAIT)
        , CASE WHEN E.MEM_TOTAL_KB != 0 THEN (((E.MEM_TOTAL_KB - (E.MEM_FREE_KB +E.MEM_BUFFERED_KB + E.MEM_CACHED_KB)) / E.MEM_TOTAL_KB ) * 100)::int ELSE E.MEM_TOTAL_KB END AS MEM_USED_RATE       --PT_03_03_001, PT_04_02_001(MEM_AVG)
        , CASE WHEN E.SWP_TOTAL_KB != 0 THEN (((E.SWP_TOTAL_KB - (E.SWP_FREE_KB + E.SWP_CACHED_KB)) / E.SWP_TOTAL_KB) * 100)::int ELSE E.SWP_TOTAL_KB END AS SWP_USED_RATE                         --PT_03_03_001(MEM SWAP_RATE), PT_04_05_001(PG_MEMORY)
        , (E.MEM_TOTAL_KB / 1024)::int AS MEM_TOTAL_MB                                                                                    --PT_04_05_001(TOTAL MEM)
        , (E.MEM_USED_KB / 1024)::int AS MEM_USED_MB                                                                                      --PT_04_05_001(USED MEM)
        , (E.MEM_FREE_KB / 1024)::int AS MEM_FREE_MB                                                                                      --PT_04_05_001(FREE MEM)
        , (E.SHM_KB / 1024)::int  AS SHM_MB                                                                                               --PT_04_05_001(SHARED MEM)
        , (E.MEM_BUFFERED_KB / 1024)::int AS MEM_BUFFERED_MB                                                                              --PT_04_05_001(BUFFERS MEM)
        , (E.MEM_CACHED_KB / 1024)::int AS MEM_CACHED_MB                                                                                  --PT_04_05_001(CACHED MEM)
        , (E.SWP_TOTAL_KB / 1024)::int AS SWP_TOTAL_MB                                                                                    --PT_04_05_001(SWAP_TOTAL MEM)
        , (E.SWP_USED_KB / 1024)::int AS SWP_USED_MB                                                                                      --PT_04_05_001(SWAP_USED MEM)
        , (E.SWP_FREE_KB / 1024)::int AS SWP_FREE_MB                                                                                      --PT_04_05_001(SWAP_FREE MEM)
		    , (E.SWP_CACHED_KB / 1024)::int AS SWP_CACHED_MB                                                                                      --PT_04_05_001(SWAP_CACHED MEM)  
        , (((E.MEM_TOTAL_KB - (E.MEM_FREE_KB )) / E.MEM_TOTAL_KB ) * 100) AS BUFFER_RATE                                           --PT_03_03_001, PT_04_02_001(MEM_AVG)
        , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
        , A.HA_GROUP
        , CASE WHEN {1}=0 THEN TO_CHAR(A.INSTANCE_ID, '00')||A.HOST_NAME ELSE TO_CHAR(A.INSTANCE_ID, '00')||A.CONN_NAME END AS SORTED_HOST_NAME
        FROM TB_INSTANCE_INFO A
             , (SELECT MAX(REG_DATE) AS REG_DATE, MAX(REG_TIME) AS REG_TIME, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID 
                 FROM TB_RSC_COLLECT_INFO 
                WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') 
                  AND RSC_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) * 2 + 1 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM RSC_REG_SEQ)
                GROUP BY INSTANCE_ID) B
             , TB_CPU_STAT_MASTER C, TB_CPU_STAT_DETAIL D, TB_MEMORY_STAT E
        WHERE A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N'  
          AND A.INSTANCE_ID IN ({0})
          AND B.REG_DATE = C.REG_DATE
          AND C.REG_DATE = D.REG_DATE
          AND D.REG_DATE = E.REG_DATE        
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
          AND C.RSC_REG_SEQ = D.RSC_REG_SEQ
          AND D.RSC_REG_SEQ = E.RSC_REG_SEQ
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTCPUMEMINFOPREV" PARAMS="0">
    <DESC>PT_03_03_001 (cpu/mem정보)</DESC>
    <DATA>
      <![CDATA[
WITH COL AS (
        SELECT B.REG_DATE, B.RSC_REG_SEQ, B.INSTANCE_ID
        FROM TB_INSTANCE_INFO A
        , TB_RSC_COLLECT_INFO B
        WHERE A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N'  
          AND A.INSTANCE_ID IN ({0})
          AND B.REG_DATE=TO_CHAR(NOW(),'YYYYMMDD')
          AND A.INSTANCE_ID = B.INSTANCE_ID
          --AND C.COLLECT_DT > now() - interval '3 minute'
         AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > now() - interval '3 minute'
        )
        SELECT /* SELECTCPUMEMINFOPREV */ A.INSTANCE_ID        
        , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM C.COLLECT_DT) / {2} )) * {2} ) AT TIME ZONE 'UTC' AS COLLECT_DATE
        , CASE WHEN MAX(C.USER_UTIL_RATE + C.NICE_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE) > 100 THEN 100 ELSE MAX(C.USER_UTIL_RATE + C.NICE_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE) END AS CPU_MAIN
        , MAX(C.WAIT_UTIL_RATE) AS WAIT_UTIL_RATE                                                                                                                --PT_04_05_001(CPU_WAIT)
        , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
        , CASE WHEN MAX(E.MEM_TOTAL_KB) != 0 THEN (MAX((E.MEM_TOTAL_KB - (E.MEM_FREE_KB +E.MEM_BUFFERED_KB + E.MEM_CACHED_KB)) / E.MEM_TOTAL_KB ) * 100)::int ELSE MAX(E.MEM_TOTAL_KB) END AS MEM_USED_RATE
        FROM TB_INSTANCE_INFO A
        , COL B LEFT OUTER JOIN TB_CPU_STAT_MASTER C
          ON B.REG_DATE = C.REG_DATE
         AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
          JOIN TB_MEMORY_STAT E
          ON B.REG_DATE = E.REG_DATE
         AND B.RSC_REG_SEQ = E.RSC_REG_SEQ
        WHERE A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N'  
          AND A.INSTANCE_ID IN ({0})
          AND A.INSTANCE_ID = B.INSTANCE_ID
         GROUP BY COLLECT_DATE, A.INSTANCE_ID 
        ORDER BY COLLECT_DATE, INSTANCE_ID;
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTCPUMEMINFOPREV_OLD" PARAMS="0">
    <DESC>PT_03_03_001 (cpu/mem정보)</DESC>
    <DATA>
      <![CDATA[
        SELECT /* SELECTCPUMEMINFOPREV */ A.INSTANCE_ID
        , C.COLLECT_DT AS REG_DATE
        , CASE WHEN C.USER_UTIL_RATE + C.NICE_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE > 100 THEN 100 ELSE C.USER_UTIL_RATE + C.NICE_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE END AS CPU_MAIN                                          --PT_03_03_001, PT_04_02_001(AVG)
        , C.WAIT_UTIL_RATE                                                                                                                --PT_04_05_001(CPU_WAIT)
        , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
        , CASE WHEN E.MEM_TOTAL_KB != 0 THEN (((E.MEM_TOTAL_KB - (E.MEM_FREE_KB +E.MEM_BUFFERED_KB + E.MEM_CACHED_KB)) / E.MEM_TOTAL_KB ) * 100)::int ELSE E.MEM_TOTAL_KB END AS MEM_USED_RATE        
        FROM TB_INSTANCE_INFO A
        , TB_RSC_COLLECT_INFO B LEFT OUTER JOIN TB_CPU_STAT_MASTER C
          ON B.REG_DATE = C.REG_DATE
         AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
          JOIN TB_MEMORY_STAT E
          ON B.REG_DATE = E.REG_DATE
         AND B.RSC_REG_SEQ = E.RSC_REG_SEQ
        WHERE A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N'  
          AND A.INSTANCE_ID IN ({0})
          AND B.REG_DATE=TO_CHAR(NOW(),'YYYYMMDD')
          AND B.REG_DATE = C.REG_DATE
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND C.COLLECT_DT > now() - interval '3 minute'
          ORDER BY C.COLLECT_DT
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTLOCKINFO" PARAMS="0">
    <DESC>PT_05_02_001 (Lock Info)</DESC>
    <DATA>
      <![CDATA[       
        SELECT /* SELECTLOCKINFO */ A.INSTANCE_ID
	        ,C.COLLECT_DT AS REG_DATE
	        ,DB_NAME          
           ,BLOCKING_USER    
           ,BLOCKING_PID     
           --,BLOCKING_QUERY   
           ,(SELECT query FROM TB_QUERY_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND INSTANCE_ID IN ({0}) AND QUERYID = BLOCKING_QUERY LIMIT 1) BLOCKING_QUERY
           ,BLOCKED_USER     
           ,BLOCKED_PID      
           --,BLOCKED_QUERY
           ,(SELECT query FROM TB_QUERY_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND INSTANCE_ID IN ({0}) AND QUERYID = BLOCKED_QUERY LIMIT 1) BLOCKED_QUERY
           ,BLOCKED_DURATION 
           ,LOCK_MODE        
           ,QUERY_START      
           ,XACT_START     
           ,ORDER_NO
           ,C.ACTV_REG_SEQ
        FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B, TB_CURRENT_LOCK C
        WHERE B.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
          AND B.ACTV_REG_SEQ = (SELECT MAX(ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND INSTANCE_ID = A.INSTANCE_ID  )
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND A.INSTANCE_ID IN ({0})
          AND B.REG_DATE = C.REG_DATE
          AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
          AND A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N'
       ORDER BY ORDER_NO; 
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTLOCKINFOACCUM" PARAMS="0">
    <DESC>PT_05_02_001 (Lock Info)</DESC>
    <DATA>
      <![CDATA[       
         SELECT /* SELECTLOCKINFOACCUM */ 
           --A.INSTANCE_ID
	         MAX(C.COLLECT_DT) AS REG_DATE
	        ,DB_NAME          
           ,BLOCKING_USER    
           ,BLOCKING_PID     
           --,BLOCKING_QUERY
           ,(SELECT query FROM TB_QUERY_INFO WHERE REG_DATE {1} AND INSTANCE_ID IN ({0}) AND QUERYID = BLOCKING_QUERY LIMIT 1) BLOCKING_QUERY
           ,BLOCKED_USER     
           ,BLOCKED_PID      
           --,BLOCKED_QUERY
           ,(SELECT query FROM TB_QUERY_INFO WHERE REG_DATE {1} AND INSTANCE_ID IN ({0}) AND QUERYID = BLOCKED_QUERY LIMIT 1) BLOCKED_QUERY
           ,MAX(BLOCKED_DURATION) AS BLOCKED_DURATION
           ,LOCK_MODE        
           ,QUERY_START      
           ,XACT_START     
           --,ORDER_NO
           ,MAX(C.ACTV_REG_SEQ) AS ACTV_REG_SEQ
        FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B, TB_CURRENT_LOCK C
        WHERE B.REG_DATE {1}
          AND B.REG_TIME {2}
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND A.INSTANCE_ID IN ({0})
          AND B.REG_DATE = C.REG_DATE
          AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
          AND A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N'
       --GROUP BY A.INSTANCE_ID, DB_NAME, BLOCKING_USER, XACT_START, blocking_pid, BLOCKING_QUERY, BLOCKED_USER, blocked_pid, BLOCKED_QUERY, LOCK_MODE, QUERY_START, ORDER_NO
       --ORDER BY XACT_START, ORDER_NO LIMIT 1000;
       --GROUP BY A.INSTANCE_ID, B.REG_DATE, B.REG_TIME, DB_NAME, BLOCKING_USER, XACT_START, blocking_pid, BLOCKING_QUERY, BLOCKED_USER, blocked_pid, BLOCKED_QUERY, LOCK_MODE, QUERY_START, ORDER_NO
       --ORDER BY B.REG_DATE, B.REG_TIME, ORDER_NO, XACT_START  LIMIT 1000;       
       GROUP BY A.INSTANCE_ID, B.REG_DATE, DB_NAME, BLOCKING_USER, XACT_START, blocking_pid, BLOCKING_QUERY, BLOCKED_USER, blocked_pid, BLOCKED_QUERY, LOCK_MODE, QUERY_START, ORDER_NO
       --ORDER BY B.REG_DATE, ORDER_NO, XACT_START  LIMIT 1000;
       ORDER BY B.REG_DATE, DB_NAME, blocking_pid, ORDER_NO, XACT_START  
       LIMIT 3000;
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTLOCKCURRENT" PARAMS="1">
    <DESC>PT_05_02_002 (Lock Info)</DESC>
    <DATA>
      <![CDATA[       
      SELECT /* SELECTLOCKCURRENT */ 
         B.INSTANCE_ID,
         C.COLLECT_DT,
         SUM(CASE WHEN C.ACTV_REG_SEQ IS NOT NULL then 1 ELSE 0 END) AS LOCK_TOTAL,
         SUM(CASE WHEN BLOCKED_PID IS NOT NULL then 1 ELSE 0 END) AS LOCK_WAIT
      FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B, TB_CURRENT_LOCK C
      WHERE B.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
        AND B.ACTV_REG_SEQ = (SELECT MAX(ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND INSTANCE_ID = A.INSTANCE_ID  )
        AND A.INSTANCE_ID = B.INSTANCE_ID
        AND A.INSTANCE_ID IN ({0})
        AND B.REG_DATE = C.REG_DATE
        AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
        AND A.COLLECT_YN = 'Y'
        AND A.DELETE_YN = 'N'
      GROUP BY B.INSTANCE_ID, C.ACTV_REG_SEQ, C.COLLECT_DT
      ORDER BY B.INSTANCE_ID, C.ACTV_REG_SEQ;
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTLOCKACCUM" PARAMS="1">
    <DESC>PT_05_02_003 (Lock Info)</DESC>
    <DATA>
      <![CDATA[       
      SELECT /* SELECTLOCKACCUM */ 
         B.INSTANCE_ID,
         TO_CHAR(NOW(),'YYYY-MM-DD') || ' ' || B.REG_TIME AS COLLECT_DT,
         SUM(CASE WHEN C.ACTV_REG_SEQ IS NOT NULL then 1 ELSE 0 END) AS LOCK_TOTAL,
         SUM(CASE WHEN BLOCKED_PID IS NOT NULL then 1 ELSE 0 END) AS LOCK_WAIT
      FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B LEFT OUTER JOIN TB_CURRENT_LOCK C on B.REG_DATE = C.REG_DATE AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
      WHERE B.REG_DATE {1}
        --AND B.REG_TIME {2}
        AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME {2}
        AND A.INSTANCE_ID = B.INSTANCE_ID
        AND A.INSTANCE_ID IN ({0})
        AND A.COLLECT_YN = 'Y'
        AND A.DELETE_YN = 'N'
      GROUP BY B.INSTANCE_ID, C.ACTV_REG_SEQ, B.REG_TIME
      ORDER BY B.INSTANCE_ID, COLLECT_DT, C.ACTV_REG_SEQ;
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
    <ROW ID="SELECTLOCKACCUMTIMELINE" PARAMS="1">
    <DESC>PT_05_02_003 (Lock Info)</DESC>
    <DATA>
      <![CDATA[       
        SELECT /* SELECTLOCKACCUMTIMELINE */
		      INSTANCE_ID 
		      , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {4} )) * {4}) AT TIME ZONE 'UTC' AS COLLECT_DATE
		      , MAX(LOCK_TOTAL) LOCK_TOTAL
		      , MAX(LOCK_WAIT) LOCK_WAIT
	        FROM ( 
		            SELECT /* SELECTLOCKACCUMTIMELINE */ 
		               B.INSTANCE_ID,
		               (B.REG_DATE::date + B.REG_TIME) AS COLLECT_DT,
		               SUM(CASE WHEN C.ACTV_REG_SEQ IS NOT NULL then 1 ELSE 0 END) AS LOCK_TOTAL,
		               SUM(CASE WHEN BLOCKED_PID IS NOT NULL then 1 ELSE 0 END) AS LOCK_WAIT
		            FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B LEFT OUTER JOIN TB_CURRENT_LOCK C on B.REG_DATE = C.REG_DATE AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
		            WHERE B.REG_DATE {1}
		              --AND (B.REG_DATE::date + B.REG_TIME) BETWEEN {2} AND {3}
                  AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME BETWEEN {2} AND {3}
		              AND A.INSTANCE_ID = B.INSTANCE_ID
		              AND A.INSTANCE_ID IN ({0})
		              AND A.COLLECT_YN = 'Y'
		              AND A.DELETE_YN = 'N'
		            GROUP BY B.INSTANCE_ID, C.ACTV_REG_SEQ, B.REG_DATE, B.REG_TIME
		            ORDER BY B.INSTANCE_ID, COLLECT_DT, C.ACTV_REG_SEQ
		         ) AS LOCK
	       GROUP BY COLLECT_DATE, INSTANCE_ID
         ORDER BY COLLECT_DATE, INSTANCE_ID;
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTREPLICATION" PARAMS="2">
    <DESC>PT_05_02_004 (Replication)</DESC>
    <DATA>
      <![CDATA[       
         SELECT /* SELECTREPLICATION */ 
             B.INSTANCE_ID,
             B.COLLECT_DT,
             B.REPLAY_LAG,
             (B.REPLAY_LAG_SIZE / 1024 / 1024) AS REPLAY_LAG_SIZE
          FROM TB_INSTANCE_INFO A, TB_REPLICATION_LAG_INFO B
          WHERE B.REG_DATE {1}
            AND B.COLLECT_DT >= (now() - interval '3 minute')
            AND A.INSTANCE_ID = B.INSTANCE_ID
            AND A.INSTANCE_ID IN ({0})
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
            AND B.REPL_REG_SEQ > (SELECT (LAST_VALUE - (SELECT COUNT(*) * 200 /*3 minute = 180 sec */ FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM REPL_REG_SEQ)
          ORDER BY B.INSTANCE_ID, B.REPL_REG_SEQ;
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>

  
  <ROW ID="SELECTREPLICATIONCURR" PARAMS="3">
    <DESC>PT_05_02_004 (Replication)</DESC>
    <DATA>
      <![CDATA[       
    		WITH MAXS AS (
		      SELECT INSTANCE_ID, MAX(REPL_REG_SEQ) REPL_REG_SEQ, MAX(COLLECT_DT) COLLECT_DT  FROM TB_REPLICATION_INFO 
		       WHERE REG_DATE = TO_CHAR(NOW(),'YYYYMMDD')
		         AND INSTANCE_ID IN ({0})
		         AND COLLECT_DT >= (now() - (({2}/500)::varchar)::INTERVAL) 
		       GROUP BY INSTANCE_ID
		    ),
		    MAXR AS
		    (
		      SELECT /* SELECTREPLICATIONCURR */ 
                   B.INSTANCE_ID,
                   C.REPL_INSTANCE_ID,
                   B.COLLECT_DT COLLECT_DT,
                   C.REPLAY_LAG REPLAY_LAG,
                   B.REPL_REG_SEQ REPL_REG_SEQ,
                   --C.REPL_REG_SEQ,
                   (C.REPLAY_LAG_SIZE / 1024 / 1024) AS REPLAY_LAG_SIZE
            FROM TB_INSTANCE_INFO A, MAXS B JOIN TB_REPLICATION_LAG_INFO C 
          								          ON B.INSTANCE_ID = C.INSTANCE_ID  
          								         AND B.REPL_REG_SEQ = C.REPL_REG_SEQ
           WHERE REG_DATE = TO_CHAR(NOW(),'YYYYMMDD')
             AND A.INSTANCE_ID = B.INSTANCE_ID
             AND A.COLLECT_YN = 'Y'
             AND A.DELETE_YN = 'N'
           ORDER BY B.INSTANCE_ID, REPL_REG_SEQ
        )
        SELECT A.INSTANCE_ID INSTANCE_ID,
             A.COLLECT_DT COLLECT_DT,
             B.REPLAY_LAG REPLAY_LAG,
             A.REPL_REG_SEQ REPL_REG_SEQ,
             B.REPLAY_LAG_SIZE
         FROM MAXS A LEFT OUTER JOIN MAXR B
           ON A.INSTANCE_ID = B.REPL_INSTANCE_ID
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  
  <ROW ID="SELECTREPLICATIONMASTER_OLD" PARAMS="2">
    <DESC>PT_05_02_004 (SELECTREPLICATIONMASTER)</DESC>
    <DATA>
      <![CDATA[       
          SELECT  INS.INSTANCE_ID, 
                  CASE WHEN {1}=0 THEN INS.HOST_NAME ELSE INS.CONN_NAME END AS SHOWNM, 
                  INS.SERVICE_PORT PORT
            FROM  TB_INSTANCE_INFO INS, TB_REPLICATION_INFO REPL
           WHERE  INS.INSTANCE_ID = REPL.INSTANCE_ID
             AND  INS.HA_GROUP = (SELECT HA_GROUP FROM TB_INSTANCE_INFO WHERE INSTANCE_ID = {0})
             AND  INS.INSTANCE_ID <> {0}
             AND  REPL.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
             AND  REPL.REPL_REG_SEQ = (SELECT MAX(A.REPL_REG_SEQ) MAX_REG_SEQ 
				                                 FROM TB_REPLICATION_INFO A 
				                                WHERE A.REG_DATE    = TO_CHAR(NOW(), 'YYYYMMDD')
				                                  AND A.INSTANCE_ID = INS.INSTANCE_ID)
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTREPLICATIONMASTER" PARAMS="2">
    <DESC>PT_05_02_004 (SELECTREPLICATIONMASTER)</DESC>
    <DATA>
      <![CDATA[       
      WITH SLAVES AS
	      (SELECT R.INSTANCE_ID FROM TB_REPLICATION_INFO R, TB_INSTANCE_INFO I
		      WHERE R.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
           AND R.INSTANCE_ID  = I.INSTANCE_ID 
		       AND R.ha_group = {0}
		       AND R.ha_role = 'S'
           AND I.COLLECT_YN = 'Y'
		       AND I.DELETE_YN = 'N'
		       GROUP BY R.INSTANCE_ID)
	      SELECT INS.INSTANCE_ID, 
                 CASE WHEN {1}=0 THEN INS.HOST_NAME ELSE INS.CONN_NAME END AS SHOWNM, 
                 INS.SERVICE_PORT PORT
            FROM TB_INSTANCE_INFO INS
           WHERE INS.INSTANCE_ID IN (SELECT * FROM SLAVES)
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTREPLICATIONSTANDBY" PARAMS="2">
    <DESC>PT_05_02_004 (SELECTREPLICATIONSTANDBY)</DESC>
    <DATA>
      <![CDATA[       
          SELECT  INS.INSTANCE_ID, 
                  CASE WHEN {1}=0 THEN INS.HOST_NAME ELSE INS.CONN_NAME END AS SHOWNM, 
                  INS.SERVICE_PORT PORT
            FROM  TB_INSTANCE_INFO INS
           WHERE  INS.INSTANCE_ID = {0}
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTWAITEVENT" PARAMS="2">
    <DESC>PT_05_02_004 (SELECTWAITEVENT)</DESC>
    <DATA>
      <![CDATA[       
         SELECT COLLECT_DT, CODE_NAME, SUM(CASE WHEN STATE <> 'idle' THEN 1 ELSE 0 END ) ECOUNT
	          FROM TB_BACKEND_RSC T, TB_ACTV_COLLECT_INFO A, TB_SYS_CODE D 
	         WHERE A.INSTANCE_ID = {0}
	          AND TO_DATE_IMM(A.REG_DATE, 'yyyymmdd') + A.REG_TIME > (CURRENT_TIMESTAMP-('{1}m')::INTERVAL)
	          AND A.REG_DATE BETWEEN TO_CHAR(CURRENT_TIMESTAMP - INTERVAL '1 day', 'YYYYMMDD') AND TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD')
	          AND A.REG_DATE = T.REG_DATE
            AND A.ACTV_REG_SEQ = T.ACTV_REG_SEQ
            AND T.WAIT_EVENT = D.CODE 
	         GROUP BY COLLECT_DT, WAIT_EVENT, CODE_NAME
	         ORDER BY COLLECT_DT desc, WAIT_EVENT, ECOUNT desc
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTCHECKPOINT" PARAMS="2">
    <DESC>PT_05_02_005 (Checkpoint)</DESC>
    <DATA>
      <![CDATA[       
        SELECT /* SELECTCHECKPOINT */
             C.INSTANCE_ID,
             C.COLLECT_DT,
             C.CHECKPOINTS_TIMED_DELTA,
             C.CHECKPOINTS_REQ_DELTA,
             C.REPL_REG_SEQ,
             C.CHECKPOINTS_TIMED_TIME_DELTA CHECKPOINTS_TIMED_TIME_DELTA,
             C.CHECKPOINTS_REQ_TIME_DELTA CHECKPOINTS_REQ_TIME_DELTA
          FROM TB_INSTANCE_INFO A 
              JOIN TB_REPLICATION_INFO B 
		            ON A.INSTANCE_ID = B.INSTANCE_ID 
		           AND A.INSTANCE_ID IN ({0})
		           AND A.COLLECT_YN = 'Y' 
		           AND A.DELETE_YN = 'N'
              JOIN TB_CHECKPOINT_INFO C 
                ON B.REPL_REG_SEQ = C.REPL_REG_SEQ 
               AND B.INSTANCE_ID = C.INSTANCE_ID 
               AND B.REG_DATE  = C.REG_DATE
          WHERE B.REG_DATE {1}         
            AND B.COLLECT_DT >= (now() - interval '60 minute')
            AND A.INSTANCE_ID = C.INSTANCE_ID
            AND A.INSTANCE_ID = B.INSTANCE_ID   
            AND B.REPL_REG_SEQ > (SELECT (LAST_VALUE - (SELECT COUNT(*) * 3600 /*60 minute = 3600 sec */ FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM REPL_REG_SEQ)
        ORDER BY C.REPL_REG_SEQ
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
    <ROW ID="SELECTCHECKPOINTLATEST" PARAMS="1">
    <DESC>PT_05_02_005 (Checkpoint)</DESC>
    <DATA>
      <![CDATA[
        WITH REPLSEQ AS (
        	 SELECT reg_date, MAX(REPL_REG_SEQ) REPL_REG_SEQ FROM TB_CHECKPOINT_INFO WHERE INSTANCE_ID IN ({0}) AND REG_DATE {1} GROUP BY REG_DATE, INSTANCE_ID
        )
        SELECT /* SELECTCHECKPOINTLATEST */
             C.INSTANCE_ID,
             C.COLLECT_DT,
             C.CHECKPOINTS_TIMED_DELTA,
             C.CHECKPOINTS_REQ_DELTA,
             C.REPL_REG_SEQ,
             C.CHECKPOINTS_TIMED_TIME_DELTA CHECKPOINTS_TIMED_TIME_DELTA,
             C.CHECKPOINTS_REQ_TIME_DELTA CHECKPOINTS_REQ_TIME_DELTA
          FROM TB_INSTANCE_INFO A 
              JOIN TB_REPLICATION_INFO B 
		        ON A.INSTANCE_ID = B.INSTANCE_ID
              JOIN REPLSEQ D
                on D.REG_DATE = B.REG_DATE
               and D.REPL_REG_SEQ = B.REPL_REG_SEQ
              JOIN TB_CHECKPOINT_INFO C 
                ON B.REPL_REG_SEQ = C.REPL_REG_SEQ 
               AND B.INSTANCE_ID = C.INSTANCE_ID 
               AND B.REG_DATE  = C.REG_DATE
          WHERE B.COLLECT_DT >= (now() - interval '120 minute')
            AND A.COLLECT_YN = 'Y' 
		    AND A.DELETE_YN = 'N'               
        ORDER BY C.REPL_REG_SEQ
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTDISKINFO_202102" PARAMS="2">
    <DESC>PT_03_04_001(인스턴스별 DISK IO/USAGE 정보)</DESC>
    <DATA>
      <![CDATA[
          WITH TMP_MAX_SEQ AS 
          (
             SELECT MAX(REG_DATE) AS REG_DATE, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME 
               FROM TB_RSC_COLLECT_INFO 
              WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') 
                AND RSC_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) + 10 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM RSC_REG_SEQ)
              GROUP BY INSTANCE_ID
          )
          SELECT /* SELECTDISKINFO */ A.INSTANCE_ID
            , C.COLLECT_DT AS REG_DATE
            , C.DISK_NAME                                                                  --PT_03_04_001
            , (C.READ_BUSY_RATE + C.WRITE_BUSY_RATE) AS BUSY_RATE                          --PT_03_04_001, PT_04_03_001(DISK IO BUSY)
            --, C.CURRENT_READ_KB/DELTA_TIME AS READ_KB_PER_SEC                              --PT_04_03_001(DISK IO READ_KB)
            --, C.CURRENT_WRITE_KB/DELTA_TIME AS WRITE_KB_PER_SEC                            --PT_04_03_001(DISK IO WRITE_KB)
            , CASE WHEN DELTA_TIME = 0 THEN 0 ELSE C.CURRENT_READ_KB/DELTA_TIME END AS READ_KB_PER_SEC     --PT_04_03_001(DISK IO READ_KB)
            , CASE WHEN DELTA_TIME = 0 THEN 0 ELSE C.CURRENT_WRITE_KB/DELTA_TIME END AS WRITE_KB_PER_SEC                            --PT_04_03_001(DISK IO WRITE_KB)
            , '-' AS DEVICE_NAME                                                           --PT_03_05_001(DISK USAGE)
            , 0 AS TOTAL_KB                                                                --PT_03_05_001(DISK USAGE TOTAL)
            , 0 AS DISK_USAGE_PER                                                          --PT_03_05_001(DISK USAGE PER)
            --, A.CONN_NAME 
            , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
          FROM TB_INSTANCE_INFO A
          --, (SELECT MAX(REG_DATE) AS REG_DATE, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME FROM TB_RSC_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') GROUP BY INSTANCE_ID) B
          , TMP_MAX_SEQ B
          , TB_DISK_IO C
          WHERE B.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
            AND A.INSTANCE_ID = B.INSTANCE_ID
            AND B.REG_DATE = C.REG_DATE
            AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
            AND A.INSTANCE_ID IN ({0})
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
          UNION ALL
          SELECT A.INSTANCE_ID
            , D.COLLECT_DT AS REG_DATE
            , D.DEVICE_NAME AS DISK_NAME                                                            --PT_03_04_001
            , 0 AS BUSY_RATE                                                              --PT_03_04_001, PT_04_03_001(DISK IO BUSY)
            , 0 AS CURRENT_READ_KB                                                        --PT_04_03_001(DISK IO READ_KB)
            , 0 AS CURRENT_WRITE_KB                                                       --PT_04_03_001(DISK IO WRITE_KB)
            , D.MOUNT_POINT_DIR                                                           --PT_03_05_001(DISK USAGE)
            , D.TOTAL_KB                                                                  --PT_03_05_001(DISK USAGE TOTAL)
            --, ROUND((((D.TOTAL_KB-D.avail_kb)/D.TOTAL_KB) * 100),2) AS DISK_USAGE_PER     --PT_03_05_001(DISK USAGE PER)
            , CASE WHEN D.TOTAL_KB = 0 THEN 1 ELSE ROUND((((D.TOTAL_KB-D.avail_kb)/(D.TOTAL_KB)) * 100),2) END AS DISK_USAGE_PER 
            --, A.CONN_NAME 
            ,CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
          FROM TB_INSTANCE_INFO A
          --, (SELECT MAX(REG_DATE) AS REG_DATE, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME FROM TB_RSC_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') GROUP BY INSTANCE_ID) B          
          , TMP_MAX_SEQ B
          , TB_DISK_USAGE D
          WHERE A.INSTANCE_ID = B.INSTANCE_ID
            AND B.REG_DATE = D.REG_DATE
            AND B.RSC_REG_SEQ = D.RSC_REG_SEQ
            AND A.INSTANCE_ID IN ({0})
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
          --ORDER BY A.INSTANCE_ID, C.READ_BUSY_RATE + C.WRITE_BUSY_RATE DESC;          
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTDISKINFO" PARAMS="2">
    <DESC>PT_03_04_001(인스턴스별 DISK IO/USAGE 정보)</DESC>
    <DATA>
      <![CDATA[
          WITH TMP_MAX_SEQ AS 
          (
             SELECT MAX(REG_DATE) AS REG_DATE, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME 
               FROM TB_RSC_COLLECT_INFO 
              WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') 
                AND RSC_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) + 10 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM RSC_REG_SEQ)
              GROUP BY INSTANCE_ID
          )
          SELECT /* SELECTDISKINFO */ A.INSTANCE_ID
            , C.COLLECT_DT AS REG_DATE
            , C.DISK_NAME                                                                  --PT_03_04_001
            , (C.READ_BUSY_RATE + C.WRITE_BUSY_RATE) AS BUSY_RATE                          --PT_03_04_001, PT_04_03_001(DISK IO BUSY)
            --, C.CURRENT_READ_KB/DELTA_TIME AS READ_KB_PER_SEC                              --PT_04_03_001(DISK IO READ_KB)
            --, C.CURRENT_WRITE_KB/DELTA_TIME AS WRITE_KB_PER_SEC                            --PT_04_03_001(DISK IO WRITE_KB)
            , CASE WHEN DELTA_TIME = 0 THEN 0 ELSE C.CURRENT_READ_KB/DELTA_TIME END AS READ_KB_PER_SEC     --PT_04_03_001(DISK IO READ_KB)
            , CASE WHEN DELTA_TIME = 0 THEN 0 ELSE C.CURRENT_WRITE_KB/DELTA_TIME END AS WRITE_KB_PER_SEC                            --PT_04_03_001(DISK IO WRITE_KB)
            , '-' AS DEVICE_NAME                                                           --PT_03_05_001(DISK USAGE)
            , 0 AS TOTAL_KB                                                                --PT_03_05_001(DISK USAGE TOTAL)
            , 0 AS DISK_USAGE_PER                                                          --PT_03_05_001(DISK USAGE PER)
            --, A.CONN_NAME 
            , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
            , 0 HCHK_VALUE
          FROM TB_INSTANCE_INFO A
          --, (SELECT MAX(REG_DATE) AS REG_DATE, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME FROM TB_RSC_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') GROUP BY INSTANCE_ID) B
          , TMP_MAX_SEQ B
          , TB_DISK_IO C
          WHERE B.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
            AND A.INSTANCE_ID = B.INSTANCE_ID
            AND B.REG_DATE = C.REG_DATE
            AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
            AND A.INSTANCE_ID IN ({0})
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
          UNION ALL
          SELECT A.INSTANCE_ID
            , D.COLLECT_DT AS REG_DATE
            , D.DEVICE_NAME AS DISK_NAME                                                            --PT_03_04_001
            , 0 AS BUSY_RATE                                                              --PT_03_04_001, PT_04_03_001(DISK IO BUSY)
            , 0 AS CURRENT_READ_KB                                                        --PT_04_03_001(DISK IO READ_KB)
            , 0 AS CURRENT_WRITE_KB                                                       --PT_04_03_001(DISK IO WRITE_KB)
            , D.MOUNT_POINT_DIR                                                           --PT_03_05_001(DISK USAGE)
            , D.TOTAL_KB                                                                  --PT_03_05_001(DISK USAGE TOTAL)
            --, ROUND((((D.TOTAL_KB-D.avail_kb)/D.TOTAL_KB) * 100),2) AS DISK_USAGE_PER     --PT_03_05_001(DISK USAGE PER)
            , CASE WHEN D.TOTAL_KB = 0 THEN 1 ELSE ROUND((((D.TOTAL_KB-D.avail_kb)/(D.TOTAL_KB)) * 100),2) END AS DISK_USAGE_PER 
            --, A.CONN_NAME 
            ,CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
            ,CASE WHEN (CASE WHEN D.TOTAL_KB = 0 THEN 1 ELSE ROUND((((D.TOTAL_KB-D.avail_kb)/(D.TOTAL_KB)) * 100),2) END) >= H.CRITICAL_THRESHOLD THEN 300
                  WHEN (CASE WHEN D.TOTAL_KB = 0 THEN 1 ELSE ROUND((((D.TOTAL_KB-D.avail_kb)/(D.TOTAL_KB)) * 100),2) END) >= H.WARNING_THRESHOLD THEN 200
                  ELSE 100 END HCHK_VALUE
          FROM TB_INSTANCE_INFO A
          --, (SELECT MAX(REG_DATE) AS REG_DATE, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME FROM TB_RSC_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') GROUP BY INSTANCE_ID) B          
          , TMP_MAX_SEQ B
          , TB_DISK_USAGE D
          , TB_HCHK_THRD_LIST H
          WHERE A.INSTANCE_ID = B.INSTANCE_ID
            AND A.INSTANCE_ID = H.INSTANCE_ID
            AND H.HCHK_NAME = 'DISKUSAGE'
            AND B.REG_DATE = D.REG_DATE
            AND B.RSC_REG_SEQ = D.RSC_REG_SEQ
            AND A.INSTANCE_ID IN ({0})
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
          --ORDER BY A.INSTANCE_ID, C.READ_BUSY_RATE + C.WRITE_BUSY_RATE DESC;          
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTDISKUSAGE" PARAMS="2">
    <DESC>PT_03_04_001(인스턴스별 DISK USAGE 정보)</DESC>
    <DATA>
      <![CDATA[
          SELECT A.INSTANCE_ID
            , D.COLLECT_DT AS REG_DATE
            , D.DEVICE_NAME AS DISK_NAME                                                            --PT_03_04_001
            , D.MOUNT_POINT_DIR                                                           --PT_03_05_001(DISK USAGE)
            , D.TOTAL_KB                                                                  --PT_03_05_001(DISK USAGE TOTAL)
            , ROUND((((D.TOTAL_KB-D.AVAIL_KB)/D.TOTAL_KB) * 100),2) AS DISK_USAGE_PER     --PT_03_05_001(DISK USAGE PER)
            , D.AVAIL_KB
          FROM TB_INSTANCE_INFO A
          , (SELECT MAX(REG_DATE) AS REG_DATE, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME FROM TB_RSC_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') GROUP BY INSTANCE_ID) B          
          , TB_DISK_USAGE D
          WHERE A.INSTANCE_ID = B.INSTANCE_ID
            AND B.REG_DATE = D.REG_DATE
            AND B.RSC_REG_SEQ = D.RSC_REG_SEQ
            AND A.INSTANCE_ID IN ({0})
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
          --ORDER BY A.INSTANCE_ID, C.READ_BUSY_RATE + C.WRITE_BUSY_RATE DESC;          
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>

  <ROW ID="SELECTLONGSQLFILTERINGCOND" PARAMS="0">
    <DESC>PT_10_00_002(SQL RESPONSE SELECTLONGSQLFILTERINGCOND)</DESC>
    <DATA>
      <![CDATA[
      SELECT GET_LONGSQL_FILTERING_COND() as COND;
     ]]>
  </DATA>
  </ROW>
  
  <ROW ID="SELECTSQLRESPTIME" PARAMS="0">
    <DESC>PT_04_10_001(SQL RESPONSE TIME)</DESC>
    <DATA>
      <![CDATA[
       SELECT	/* SELECTSQLRESPTIME */ A.INSTANCE_ID
        	        , MAX(BAK.COLLECT_DT) AS REG_DATE
        	        , MAX(CASE WHEN BAK.ELAPSED_TIME < 0 THEN 0 ELSE BAK.ELAPSED_TIME END) AS MAX_SQL_ELAPSED_SEC
        	        , AVG(CASE WHEN BAK.ELAPSED_TIME < 0 THEN 0 ELSE BAK.ELAPSED_TIME END) AS AVG_SQL_ELAPSED_SEC
          FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO TAC, TB_BACKEND_RSC BAK
         WHERE TAC.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
           AND TAC.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=A.INSTANCE_ID )
           AND A.INSTANCE_ID = TAC.INSTANCE_ID       
           --AND A.INSTANCE_ID IN ({0})
           AND A.COLLECT_YN = 'Y'
           AND BAK.USER_NAME IS NOT NULL
           AND A.DELETE_YN = 'N'
           AND TAC.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ
           AND TAC.REG_DATE = BAK.REG_DATE
           {1}
           GROUP BY A.INSTANCE_ID ;
     ]]>
    </DATA>
  </ROW>


  <ROW ID="SELECTSQLRESPTIME_OLD" PARAMS="0">
    <DESC>PT_04_10_001(SQL RESPONSE TIME)</DESC>
    <DATA>
      <![CDATA[
       SELECT	/* SELECTSQLRESPTIME */ A.INSTANCE_ID
        	        , MAX(BAK.COLLECT_DT) AS REG_DATE
        	        , MAX(CASE WHEN BAK.ELAPSED_TIME < 0 THEN 0 ELSE BAK.ELAPSED_TIME END) AS MAX_SQL_ELAPSED_SEC
        	        , AVG(CASE WHEN BAK.ELAPSED_TIME < 0 THEN 0 ELSE BAK.ELAPSED_TIME END) AS AVG_SQL_ELAPSED_SEC
          FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO TAC, TB_BACKEND_RSC BAK
         WHERE TAC.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
           AND TAC.ACTV_REG_SEQ = (SELECT MAX(X.ACTV_REG_SEQ) FROM TB_ACTV_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=A.INSTANCE_ID )
           AND A.INSTANCE_ID = TAC.INSTANCE_ID       
           --AND A.INSTANCE_ID IN ({0})
           AND A.COLLECT_YN = 'Y'
           AND BAK.USER_NAME IS NOT NULL
           AND A.DELETE_YN = 'N'
           AND TAC.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ
           AND TAC.REG_DATE = BAK.REG_DATE
           GROUP BY A.INSTANCE_ID ;
     ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTSQLRESPTIMEPREV" PARAMS="0">
    <DESC>PT_04_10_001(SQL RESPONSE TIME)</DESC>
    <DATA>
      <![CDATA[
       SELECT	/* SELECTSQLRESPTIMEPREV*/ A.INSTANCE_ID
        	        , BAK.COLLECT_DT AS REG_DATE
        	        , MAX(CASE WHEN BAK.ELAPSED_TIME < 0 THEN 0 ELSE BAK.ELAPSED_TIME END) AS MAX_SQL_ELAPSED_SEC
        	        , AVG(CASE WHEN BAK.ELAPSED_TIME < 0 THEN 0 ELSE BAK.ELAPSED_TIME END) AS AVG_SQL_ELAPSED_SEC
          FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO TAC, TB_BACKEND_RSC BAK
         WHERE TAC.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
           AND A.INSTANCE_ID IN ({0})
           AND A.INSTANCE_ID = TAC.INSTANCE_ID       
           AND A.COLLECT_YN = 'Y'
           AND A.DELETE_YN = 'N'
           AND TAC.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ
           AND TAC.REG_DATE = BAK.REG_DATE
           AND BAK.USER_NAME IS NOT NULL
           --AND BAK.COLLECT_DT > {1}
           AND TO_DATE_IMM(TAC.REG_DATE, 'yyyymmdd') + TAC.REG_TIME > {1}
           {2}
           GROUP BY A.INSTANCE_ID, BAK.COLLECT_DT
           ORDER BY A.INSTANCE_ID, BAK.COLLECT_DT
     ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTDBINFO" PARAMS="0">
    <DESC>PT_05_03_001(DB INFO)</DESC>
    <DATA>
      <![CDATA[
           SELECT	/* SELECTDBINFO */ A.INSTANCE_ID
	          , C.DB_NAME AS DB                                      --PT_05_03_001(DB INFO : DB) 
	          , C.DB_SIZE_KB AS SIZE                                  --PT_05_03_001(DB INFO : SIZE) 
	          , C.TABLE_CNT AS "TABLE COUNT"                                    --PT_05_03_001(DB INFO : TABLE CNT) 
	          , C.INDEX_CNT AS "INDEX COUNT"                                    --PT_05_03_001(DB INFO : INDEX CNT) 
	          , C.AGG_HEAP_BLKS_READ_KB AS "DISK READ"  --PT_05_03_001(DB INFO : DISK READ(KB)) 
	          , C.AGG_HEAP_BLKS_HIT_KB AS "BUFFER READ" --PT_05_03_001(DB INFO : BUFFER READ(KB)) 
	          , C.buffer_hit_ratio AS "HIT RATIO"              --PT_05_03_001(DB INFO : HIT RATIO) 
          FROM TB_INSTANCE_INFO A
          	, (SELECT MAX(REG_DATE) AS REG_DATE, MAX(ACTV_REG_SEQ) AS ACTV_REG_SEQ, INSTANCE_ID FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') GROUP BY INSTANCE_ID) B
          	, TB_ACCESS_INFO C
          WHERE A.INSTANCE_ID = B.INSTANCE_ID
          AND B.REG_DATE = C.REG_DATE
          AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
          AND A.INSTANCE_ID IN ({0})
          AND A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N';  
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTUSERINFO" PARAMS="0">
    <DESC>PT_05_03_001(USER INFO)</DESC>
    <DATA>
      <![CDATA[
      SELECT INSTANCE_ID, COLLECT_DT, USER_NAME 
        FROM TB_USER_INFO 
       WHERE COLLECT_DT = (SELECT MAX(COLLECT_DT) COLLECT_DT 
					                   FROM TB_USER_INFO 
                            WHERE INSTANCE_ID IN ({0})
      )
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTTBSPACEINFO" PARAMS="0">
    <DESC>PT_05_04_001(TABLESPACE INFO)</DESC>
    <DATA>
      <![CDATA[
          SELECT /* SELECTTBSPACEINFO */ A.INSTANCE_ID
	          , C.TABLESPACE_NAME AS TABLESPACE
	          , C.SIZE_KB AS SIZE
	          , C.LOCATION
	          , C.total_disk_kb AS "DISK SIZE"
	          , CASE WHEN C.total_disk_kb = 0 THEN 0 
			          ELSE   (C.total_disk_kb - C.aval_disk_kb) / C.total_disk_kb  END AS "DISK USED"
          FROM TB_INSTANCE_INFO A
          	, (SELECT MAX(REG_DATE) AS REG_DATE, MAX(OBJT_REG_SEQ) AS OBJT_REG_SEQ, INSTANCE_ID FROM TB_OBJT_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') GROUP BY INSTANCE_ID) B
          	, TB_TABLESPACE_INFO C
          WHERE A.INSTANCE_ID = B.INSTANCE_ID
          AND B.REG_DATE = C.REG_DATE
          AND B.OBJT_REG_SEQ = C.OBJT_REG_SEQ
          AND A.INSTANCE_ID IN ({0})
          AND A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N';  
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTTBINFO" PARAMS="0">
    <DESC>PT_05_05_001(TABLE INFO)   </DESC>
    <DATA>
      <![CDATA[
 						SELECT /* SELECTTBINFO */	A.INSTANCE_ID
	            , C.DB_NAME AS DB                         --PT_05_05_001(TABLE INFO : DB), PT_05_06_001(INDEX_INFO : DB)
	            , C.TABLE_NAME AS TABLE                       --PT_05_05_001(TABLE INFO : TABLE), PT_05_06_001(INDEX_INFO : TABLE)
	            , ROUND(C.table_size_kb / 1024, 0) AS SIZE                    --PT_05_05_001(TABLE INFO : TABLE SIZE KB)
	            , ROUND(C.tot_index_size_kb / 1024, 0) AS "INDEX SIZE"                --PT_05_05_001(TABLE INFO : TOTAL INDEX SIZE KB)
	            , C.INDEX_CNT AS "INDEX CNT"                        --PT_05_05_001(TABLE INFO : INDEX COUNT)
	            , C.TOAST_YN AS IS_TOAST              --PT_05_05_001(TABLE INFO : IS TOAST YESNO)
	            , C.agg_seq_scan_cnt AS "SEQ SCAN COUNT"      --PT_05_05_001(TABLE INFO : SEQ SCAN COUNT)
	            , C.agg_index_scan_cnt AS "INDEX SCAN COUNT"  --PT_05_05_001(TABLE INFO : INDEX SCAN COUNT)
	            , C.LIVE_TUPLE_CNT AS "LIVE TUPLES"                    --PT_05_05_001(TABLE INFO : LIVE_TUPLE_COUNT)
	            , C.DEAD_TUPLE_CNT AS "DEAD TUPLES"                    --PT_05_05_001(TABLE INFO : DEAD_TUPLE_COUNT)
              , CASE WHEN (C.LIVE_TUPLE_CNT + C.DEAD_TUPLE_CNT) > 0 THEN ROUND(C.DEAD_TUPLE_CNT / (C.LIVE_TUPLE_CNT + C.DEAD_TUPLE_CNT) ,2) ELSE 0 END AS "DEAD TUPLE RATE"        
	            , CASE WHEN C.last_vacuum::DATE = '10000101'::DATE THEN NULL ELSE C.last_vacuum END AS "LAST VACUUM"                      --PT_05_05_001(TABLE INFO : LAST VACUUM DAYS)
              , ROUND(C.bloat_size_kb / 1024, 0) AS BLOAT_SIZE
				      , CASE WHEN C.table_size_kb > 0 THEN round(C.bloat_size_kb/C.table_size_kb,2) ELSE 0 END  AS BLOAT_RATIO
				      , CASE WHEN C.table_size_kb/1024 > 1000
				             THEN (CASE WHEN C.bloat_size_kb/C.table_size_kb * 100 > 25 THEN 1 ELSE 0 END)   
				             WHEN C.table_size_kb/1024 > 20 
				             THEN CASE WHEN round(C.bloat_size_kb/C.table_size_kb * 100,2) > 50 THEN 1 ELSE 0 END   
				        ELSE 0 END AS bloat_table
              , RELAGE
            FROM (SELECT INSTANCE_ID FROM TB_INSTANCE_INFO WHERE DELETE_YN='N' AND COLLECT_YN='Y' AND INSTANCE_ID IN ({0})) A,
               (SELECT MAX(REG_DATE) AS REG_DATE, MAX(OBJT_REG_SEQ) AS OBJT_REG_SEQ, INSTANCE_ID FROM TB_OBJT_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') GROUP BY INSTANCE_ID) B,
               TB_TABLE_INFO C
            WHERE B.REG_DATE = C.REG_DATE
               AND B.OBJT_REG_SEQ = C.OBJT_REG_SEQ
               AND A.INSTANCE_ID = B.INSTANCE_ID
            --ORDER BY A.INSTANCE_ID, C.DB_NAME, C.TABLE_NAME;

      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTINDEXINFO" PARAMS="0">
    <DESC>PT_05_06_001(INDEX INFO)   </DESC>
    <DATA>
      <![CDATA[
            SELECT /* SELECTINDEXINFO */ A.INSTANCE_ID
	            , C.DB_NAME AS DB
	            , C.INDEX_NAME AS INDEX
              , C.TABLE_NAME AS TABLE
	            , ROUND(C.INDEX_SIZE_KB / 1024, 0) AS SIZE
	            , C.AGG_INDEX_SCAN_CNT AS "INDEX SCAN COUNT"
	            , C.AGG_INDEX_SCAN_FETCH_TUPLES AS "INDEX FETCHED TUPLES"
	            , D.AGG_SEQ_SCAN_CNT AS "UPDATED TUPLES"
	            , D.AGG_SEQ_TUPLES AS "DELETED TUPLES"
	            , D.LIVE_TUPLE_CNT AS "LIVE TUPLES"
              , D.DEAD_TUPLE_CNT AS "DEAD TUPLES"
              , CASE WHEN (D.LIVE_TUPLE_CNT + D.DEAD_TUPLE_CNT) > 0 THEN ROUND(100 * D.DEAD_TUPLE_CNT / (D.LIVE_TUPLE_CNT + D.DEAD_TUPLE_CNT) ,2) ELSE 0 END AS DEAD_TUPLE_RATE		          
           FROM (SELECT INSTANCE_ID FROM TB_INSTANCE_INFO WHERE DELETE_YN='N' AND COLLECT_YN='Y' AND INSTANCE_ID IN ({0})) A,
                (SELECT MAX(REG_DATE) AS REG_DATE, MAX(OBJT_REG_SEQ) AS OBJT_REG_SEQ, INSTANCE_ID FROM TB_OBJT_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') GROUP BY INSTANCE_ID) B,
                TB_INDEX_INFO C,
                TB_TABLE_INFO D
            WHERE B.REG_DATE = C.REG_DATE
               AND B.OBJT_REG_SEQ = C.OBJT_REG_SEQ
               AND B.REG_DATE = D.REG_DATE
               AND B.OBJT_REG_SEQ = D.OBJT_REG_SEQ
               AND C.DB_NAME = D.DB_NAME
               AND C.SCHEMA_NAME = D.SCHEMA_NAME
               AND C.TABLE_NAME = D.TABLE_NAME
               AND A.INSTANCE_ID = B.INSTANCE_ID
            --ORDER BY A.INSTANCE_ID, C.DB_NAME, C.TABLE_NAME;
             
            
      ]]>
    </DATA>
  </ROW>



  <ROW ID="SELECTBACKEND" PARAMS="0">
    <DESC>PT_04_09_001(OBJECT 정보)</DESC>
    <DATA>
      <![CDATA[
       SELECT /* SELECTBACKEND */ BACKEND.* 
        FROM 
          (SELECT  A.INSTANCE_ID
          , E.COLLECT_DT AS REG_DATE
          , ROW_NUMBER() OVER (PARTITION BY A.INSTANCE_ID ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL  DESC) AS RNUM
          , E.DB_NAME                                     --PT_04_04_001(RESRCUTILPERBACK : DB)
		  , COALESCE(E.USER_NAME, '') AS USER_NAME
		  , E.CLIENT_ADDR
		  , E.CLIENT_APP
      --, CASE WHEN (E.SQL <>'<IDLE>') THEN 'Active' ELSE 'Idle' END AS "STATE"
      , CASE WHEN (E.STATE = 'active') THEN 'active' ELSE 'idle' END AS "STATE"
          , E.PROCESS_ID                                  --PT_04_04_001(RESRCUTILPERBACK : PID)
          , E.CURRENT_PROC_READ_KB                        --PT_03_06_001(BACKEND PROCS : MEM USEAGE READ KB)
          , E.CURRENT_PROC_WRITE_KB                       --PT_04_04_001(RESRCUTILPERBACK : MEM USAGE WRITE KB)
          , ROUND(E.PROC_CPU_UTIL / 100,2) AS "CPU_USAGE"          --PT_03_06_001(BACKEND PROCS : CPU_USAGE PER), PT_04_04_001(RESRCUTILPERBACK : CPU_USAGE PER)
          , E.QUERY_START AS "START_TIME"                 --PT_03_06_001(BACKEND PROCS : QUERY_START)
          --, CASE WHEN (E.SQL <>'<IDLE>' AND  E.ELAPSED_TIME >= 0 ) THEN E.ELAPSED_TIME ELSE '0' END AS "ELAPSED_TIME"              --PT_03_06_001(BACKEND PROCS : ) 
          , CASE WHEN (E.STATE = 'active' AND  E.ELAPSED_TIME >= 0 ) THEN E.ELAPSED_TIME ELSE '0' END AS "ELAPSED_TIME"              --PT_03_06_001(BACKEND PROCS : ) 
          , E.SQL AS SQL                                  --PT_03_06_001(BACKEND PROCS : SQL), PT_04_04_001(RESRCUTILPERBACK : SQL)
		      , E.ELAPSED_TIME
          --, A.CONN_NAME
          , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
          , E.CURRENT_PROC_READ_KB + E.CURRENT_PROC_WRITE_KB AS "MEM_USAGE_KB"
          , B.ACTV_REG_SEQ
          , CD.CODE_NAME AS WAIT_EVENT
         FROM TB_INSTANCE_INFO A,
              (SELECT MAX(REG_DATE) AS REG_DATE, MAX(ACTV_REG_SEQ) AS ACTV_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME 
                 FROM TB_ACTV_COLLECT_INFO 
                WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
                  AND ACTV_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) * 3  FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM ACTV_REG_SEQ)
                GROUP BY INSTANCE_ID) B, TB_BACKEND_RSC E, TB_SYS_CODE CD
          WHERE B.REG_DATE = E.REG_DATE
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ
          AND A.INSTANCE_ID IN ({0})
          AND A.COLLECT_YN = 'Y' 
          AND A.DELETE_YN = 'N'
          AND E.SQL != 'BACKGROUND PROC'
          --AND E.SQL NOT LIKE 'SELECT /* EXPERDBMA%'
          AND E.SQL IS NOT NULL
          AND E.WAIT_EVENT = CD.CODE
          ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL DESC)  BACKEND
        WHERE BACKEND.RNUM <= 100   
		  AND ELAPSED_TIME >= 0;     
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTBACKENDEXT_DEPRECATED_202006_FOR_PGACTSTATEMENT" PARAMS="0">
    <DESC>PT_04_09_001(OBJECT 정보)</DESC>
    <DATA>
      <![CDATA[
       SELECT /* SELECTBACKEND */ BACKEND.* , CASE WHEN (BACKEND.SQL1 = '') THEN Q.QUERY ELSE BACKEND.SQL1 END AS SQL		   
        FROM 
          (SELECT  A.INSTANCE_ID
          , E.COLLECT_DT AS REG_DATE
          , ROW_NUMBER() OVER (PARTITION BY A.INSTANCE_ID ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL  DESC) AS RNUM
          , E.DB_NAME                                     --PT_04_04_001(RESRCUTILPERBACK : DB)
		  , COALESCE(E.USER_NAME, '') AS USER_NAME
		  , E.CLIENT_ADDR
		  , E.CLIENT_APP
      	  , CASE WHEN (E.STATE = 'active') THEN 'active' ELSE 'idle' END AS "STATE"
          , E.PROCESS_ID                                  --PT_04_04_001(RESRCUTILPERBACK : PID)
          , E.CURRENT_PROC_READ_KB                        --PT_03_06_001(BACKEND PROCS : MEM USEAGE READ KB)
          , E.CURRENT_PROC_WRITE_KB                       --PT_04_04_001(RESRCUTILPERBACK : MEM USAGE WRITE KB)
          , ROUND(E.PROC_CPU_UTIL / 100,2) AS "CPU_USAGE"          --PT_03_06_001(BACKEND PROCS : CPU_USAGE PER), PT_04_04_001(RESRCUTILPERBACK : CPU_USAGE PER)
          , E.QUERY_START AS "START_TIME"                 --PT_03_06_001(BACKEND PROCS : QUERY_START)
          , CASE WHEN (E.STATE = 'active' AND  E.ELAPSED_TIME >= 0 ) THEN E.ELAPSED_TIME ELSE '0' END AS "ELAPSED_TIME"              --PT_03_06_001(BACKEND PROCS : ) 
          , E.SQL AS SQL1                                  --PT_03_06_001(BACKEND PROCS : SQL), PT_04_04_001(RESRCUTILPERBACK : SQL)
          , E.ELAPSED_TIME
          , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
          , E.CURRENT_PROC_READ_KB + E.CURRENT_PROC_WRITE_KB AS "MEM_USAGE_KB"
          , B.ACTV_REG_SEQ
          , CD.CODE_NAME AS WAIT_EVENT
          , E.QUERYID
         FROM TB_INSTANCE_INFO A,
              (SELECT MAX(REG_DATE) AS REG_DATE, MAX(ACTV_REG_SEQ) AS ACTV_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME 
                 FROM TB_ACTV_COLLECT_INFO 
                WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
                  AND ACTV_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) * 3 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM ACTV_REG_SEQ)
                GROUP BY INSTANCE_ID) B, TB_BACKEND_RSC E, TB_SYS_CODE CD
          WHERE B.REG_DATE = E.REG_DATE
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ
          AND A.INSTANCE_ID IN ({0})
          AND A.COLLECT_YN = 'Y' 
          AND A.DELETE_YN = 'N'
          AND E.SQL != 'BACKGROUND PROC'
          AND E.SQL IS NOT NULL
          AND COALESCE(E.WAIT_EVENT, 200) = CD.CODE
          ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL DESC)  BACKEND, TB_PGSS_QUERY_INFO Q
        WHERE BACKEND.RNUM <= 100   
          AND Q.INSTANCE_ID = BACKEND.INSTANCE_ID
          AND Q.QUERYID = BACKEND.QUERYID 
		  AND ELAPSED_TIME >= 0;     
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTBACKENDEXT" PARAMS="0">
    <DESC>PT_04_09_001(OBJECT 정보)</DESC>
    <DATA>
      <![CDATA[
/* SELECTBACKEND */
WITH PGSTA AS (SELECT INSTANCE_ID FROM TB_INSTANCE_INFO WHERE instance_id IN ({0}) AND (EXTENSIONS & 4) = 0),
	 PGACT AS (SELECT INSTANCE_ID FROM TB_INSTANCE_INFO WHERE instance_id IN ({0}) AND (EXTENSIONS & 4) > 0)
	   SELECT BACKEND.* , CASE WHEN (BACKEND.SQL1 = '') THEN Q.QUERY ELSE BACKEND.SQL1 END AS SQL		   
        FROM 
          (SELECT  A.INSTANCE_ID
          , E.COLLECT_DT AS REG_DATE
          , ROW_NUMBER() OVER (PARTITION BY A.INSTANCE_ID ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL  DESC) AS RNUM
          , E.DB_NAME                                     --PT_04_04_001(RESRCUTILPERBACK : DB)
		      , COALESCE(E.USER_NAME, '') AS USER_NAME
		      , E.CLIENT_ADDR
		      , E.CLIENT_APP
      	  --, CASE WHEN (E.STATE = 'active') THEN 'active' ELSE 'idle' END AS "STATE"
          , E.STATE
          , E.PROCESS_ID                                  --PT_04_04_001(RESRCUTILPERBACK : PID)
          , E.CURRENT_PROC_READ_KB                        --PT_03_06_001(BACKEND PROCS : MEM USEAGE READ KB)
          , E.CURRENT_PROC_WRITE_KB                       --PT_04_04_001(RESRCUTILPERBACK : MEM USAGE WRITE KB)
          , ROUND(E.PROC_CPU_UTIL / 100,2) AS "CPU_USAGE"          --PT_03_06_001(BACKEND PROCS : CPU_USAGE PER), PT_04_04_001(RESRCUTILPERBACK : CPU_USAGE PER)
          , E.QUERY_START AS "START_TIME"                 --PT_03_06_001(BACKEND PROCS : QUERY_START)
          , CASE WHEN (E.STATE = 'active' AND  E.ELAPSED_TIME >= 0 ) THEN E.ELAPSED_TIME ELSE '0' END AS "ELAPSED_TIME"              --PT_03_06_001(BACKEND PROCS : ) 
          , E.SQL AS SQL1                                  --PT_03_06_001(BACKEND PROCS : SQL), PT_04_04_001(RESRCUTILPERBACK : SQL)
          , E.ELAPSED_TIME
          , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
          , E.CURRENT_PROC_READ_KB + E.CURRENT_PROC_WRITE_KB AS "MEM_USAGE_KB"
          , B.ACTV_REG_SEQ
          , CD.CODE_NAME AS WAIT_EVENT
          , E.QUERYID
         FROM TB_INSTANCE_INFO A,
              (SELECT MAX(REG_DATE) AS REG_DATE, MAX(ACTV_REG_SEQ) AS ACTV_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME 
                 FROM TB_ACTV_COLLECT_INFO 
                WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
                  AND ACTV_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) * 3 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM ACTV_REG_SEQ)
                GROUP BY INSTANCE_ID) B, TB_BACKEND_RSC E, TB_SYS_CODE CD
          WHERE B.REG_DATE = E.REG_DATE
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ
          AND A.INSTANCE_ID IN (SELECT INSTANCE_ID FROM PGSTA)
          AND A.COLLECT_YN = 'Y' 
          AND A.DELETE_YN = 'N'
          AND E.SQL != 'BACKGROUND PROC'
          AND E.SQL IS NOT NULL
          AND COALESCE(E.WAIT_EVENT, 299) = CD.CODE
          --ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL DESC)  BACKEND, (SELECT DISTINCT QUERYID, QUERY FROM TB_QUERY_INFO) Q --(SELECT DISTINCT instance_id, QUERYID, QUERY FROM TB_QUERY_INFO) Q  --TB_QUERY_INFO Q
          ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL DESC)  BACKEND, (SELECT DISTINCT QUERYID, QUERY FROM TB_QUERY_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')) Q
        WHERE BACKEND.RNUM <= 1000   
          --AND Q.INSTANCE_ID = BACKEND.INSTANCE_ID
          AND Q.QUERYID = BACKEND.QUERYID 
		  AND ELAPSED_TIME >= 0  
UNION
       SELECT /* SELECTBACKEND */ BACKEND.* , CASE WHEN (BACKEND.SQL1 = '') THEN Q.QUERY ELSE BACKEND.SQL1 END AS SQL		   
        FROM 
          (SELECT  A.INSTANCE_ID
          , E.COLLECT_DT AS REG_DATE
          , ROW_NUMBER() OVER (PARTITION BY A.INSTANCE_ID ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL  DESC) AS RNUM
          , E.DB_NAME                                     --PT_04_04_001(RESRCUTILPERBACK : DB)
		      , COALESCE(E.USER_NAME, '') AS USER_NAME
		      , E.CLIENT_ADDR
		      , E.CLIENT_APP
      	  , E.STATE
          , E.PROCESS_ID                                  --PT_04_04_001(RESRCUTILPERBACK : PID)
          , E.CURRENT_PROC_READ_KB                        --PT_03_06_001(BACKEND PROCS : MEM USEAGE READ KB)
          , E.CURRENT_PROC_WRITE_KB                       --PT_04_04_001(RESRCUTILPERBACK : MEM USAGE WRITE KB)
          , ROUND(E.PROC_CPU_UTIL / 100,2) AS "CPU_USAGE"          --PT_03_06_001(BACKEND PROCS : CPU_USAGE PER), PT_04_04_001(RESRCUTILPERBACK : CPU_USAGE PER)
          , E.QUERY_START AS "START_TIME"                 --PT_03_06_001(BACKEND PROCS : QUERY_START)
          , CASE WHEN (E.STATE = 'active' AND  E.ELAPSED_TIME >= 0 ) THEN E.ELAPSED_TIME ELSE '0' END AS "ELAPSED_TIME"              --PT_03_06_001(BACKEND PROCS : ) 
          , E.SQL AS SQL1                                  --PT_03_06_001(BACKEND PROCS : SQL), PT_04_04_001(RESRCUTILPERBACK : SQL)
          , E.ELAPSED_TIME
          , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
          , E.CURRENT_PROC_READ_KB + E.CURRENT_PROC_WRITE_KB AS "MEM_USAGE_KB"
          , B.ACTV_REG_SEQ
          , CD.CODE_NAME AS WAIT_EVENT
          , E.QUERYID
         FROM TB_INSTANCE_INFO A,
              (SELECT MAX(REG_DATE) AS REG_DATE, MAX(ACTV_REG_SEQ) AS ACTV_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME 
                 FROM TB_ACTV_COLLECT_INFO 
                WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
                  AND ACTV_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) * 3 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM ACTV_REG_SEQ)
                GROUP BY INSTANCE_ID) B, TB_BACKEND_RSC E, TB_SYS_CODE CD
          WHERE B.REG_DATE = E.REG_DATE
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ
          AND A.INSTANCE_ID IN (SELECT INSTANCE_ID FROM PGACT)
          AND A.COLLECT_YN = 'Y' 
          AND A.DELETE_YN = 'N'
          AND E.SQL != 'BACKGROUND PROC'
          AND E.SQL IS NOT NULL
          AND COALESCE(E.WAIT_EVENT, 299) = CD.CODE
          ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL DESC)  BACKEND, TB_PGSS_QUERY_INFO Q
        WHERE BACKEND.RNUM <= 1000   
          AND Q.INSTANCE_ID = BACKEND.INSTANCE_ID
          AND Q.QUERYID = BACKEND.QUERYID 
		  AND ELAPSED_TIME >= 0
    ORDER BY INSTANCE_ID, RNUM;  
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTPHYSICALIO" PARAMS="0">
    <DESC>PT_04_07_001(PHYSICAL IO : PHY_READ, PHY_WRITE)</DESC>
    <DATA>
      <![CDATA[
          SELECT /* SELECTPHYSICALIO */ A.INSTANCE_ID
            , E.COLLECT_DT AS "REG_DATE"
            , DISK_NAME
 	          , READ_BUSY_RATE AS "PHY_READ"          --PT_04_07_001(PHYSICAL IO : PHY_READ)
	          , WRITE_BUSY_RATE AS "PHY_WRITE"        --PT_04_07_001(PHYSICAL IO : PHY_WRITE)
            , MOUNTPOINT
          FROM TB_INSTANCE_INFO A,
          	(SELECT MAX(REG_DATE) AS REG_DATE, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME 
               FROM TB_RSC_COLLECT_INFO 
              WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') 
                AND RSC_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) + 1 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM RSC_REG_SEQ)
              GROUP BY INSTANCE_ID) B,
          	TB_DISK_IO E
          WHERE B.REG_DATE = E.REG_DATE
          AND B.RSC_REG_SEQ = E.RSC_REG_SEQ
          AND B.INSTANCE_ID = A.INSTANCE_ID
          AND A.INSTANCE_ID IN ({0})
          AND A.COLLECT_YN = 'Y' 
          AND A.DELETE_YN = 'N'
          ORDER BY A.INSTANCE_ID, B.RSC_REG_SEQ
      ]]>
    </DATA>
  </ROW>
    <ROW ID="SELECTPHYSICALIOBEFORE" PARAMS="0">
    <DESC>PT_04_07_001(PHYSICAL IO : PHY_READ, PHY_WRITE)</DESC>
    <DATA>
      <![CDATA[
          SELECT /* SELECTPHYSICALIOBEFORE */ A.INSTANCE_ID
            , E.COLLECT_DT AS "REG_DATE"
            , DISK_NAME
 	          , READ_BUSY_RATE AS "PHY_READ"          --PT_04_07_001(PHYSICAL IO : PHY_READ)
	          , WRITE_BUSY_RATE AS "PHY_WRITE"        --PT_04_07_001(PHYSICAL IO : PHY_WRITE)
          FROM TB_INSTANCE_INFO A,
          	TB_RSC_COLLECT_INFO B,
          	TB_DISK_IO E
          WHERE B.REG_DATE = E.REG_DATE
          AND B.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
          AND B.RSC_REG_SEQ = E.RSC_REG_SEQ
          AND B.INSTANCE_ID = A.INSTANCE_ID
          AND A.INSTANCE_ID IN ({0})
          --AND E.COLLECT_DT > now() - interval '3 minute'
          AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > now() - interval '3 minute'
          AND A.COLLECT_YN = 'Y' 
          AND A.DELETE_YN = 'N'  
          ORDER BY A.INSTANCE_ID, B.RSC_REG_SEQ
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTPHYSICALIODETAIL" PARAMS="0">
    <DESC>PT_04_07_001(PHYSICAL IO : PHY_READ, PHY_WRITE)</DESC>
    <DATA>
      <![CDATA[
          SELECT /* SELECTPHYSICALIODETAIL */ A.INSTANCE_ID
            , E.COLLECT_DT AS COLLECT_DT
            , DISK_NAME
 	          , READ_BUSY_RATE AS "PHY_READ"          --PT_04_07_001(PHYSICAL IO : PHY_READ)
	          , WRITE_BUSY_RATE AS "PHY_WRITE"        --PT_04_07_001(PHYSICAL IO : PHY_WRITE)
            , (READ_BUSY_RATE + WRITE_BUSY_RATE) AS PHY_IO
          FROM TB_INSTANCE_INFO A,
          	TB_RSC_COLLECT_INFO B,
          	TB_DISK_IO E
          WHERE B.REG_DATE = E.REG_DATE
          -- AND B.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
          AND B.REG_DATE {1}
          AND B.RSC_REG_SEQ = E.RSC_REG_SEQ
          AND B.INSTANCE_ID = A.INSTANCE_ID
          AND A.INSTANCE_ID IN ({0})
          --AND E.COLLECT_DT BETWEEN {2} AND {3}
          AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME BETWEEN {2} AND {3}
          AND A.COLLECT_YN = 'Y' 
          AND A.DELETE_YN = 'N'  
          ORDER BY A.INSTANCE_ID, B.RSC_REG_SEQ
      ]]>
    </DATA>
  </ROW>

  <ROW ID="UPDATEHEALTHLIMITED " PARAMS="8">
    <DESC>헬스체크 임계정보</DESC>
    <DATA>
      <![CDATA[
     UPDATE TB_HCHK_THRD_LIST
     SET 
        WARNING_THRESHOLD= {2}
       , CRITICAL_THRESHOLD= {3}
       , FIXED_THRESHOLD = '{4}'
       , LAST_MOD_IP='{5}'
       , RETENTION_TIME={6}
       , RESERVED_STR='{7}'
       , LAST_MOD_DT= NOW()
      WHERE 
          INSTANCE_ID = {0}
      AND HCHK_NAME = '{1}'
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>

  <ROW ID="UPDATEHEALTHLIMITEDEXT " PARAMS="7">
    <DESC>헬스체크 임계정보</DESC>
    <DATA>
      <![CDATA[
     UPDATE TB_HCHK_THRD_LIST
     SET 
        user_group= {1}
       , notification_cycle= {2}
       , notification_level = {3}
       , business_name = '{4}'
       , LAST_MOD_IP='{5}'
       , LAST_MOD_DT= NOW()
      WHERE 
          INSTANCE_ID = {0}
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>



  <ROW ID="INSERTHEALTHLIMITED " PARAMS="8">
    <DESC>헬스체크 임계정보</DESC>
    <DATA>
      <![CDATA[
     INSERT INTO TB_HCHK_THRD_LIST
     ( INSTANCE_ID
     , HCHK_NAME
     , UNIT
     , WARNING_THRESHOLD
     , CRITICAL_THRESHOLD
     , FIXED_THRESHOLD
     , LAST_MOD_IP
     , LAST_MOD_DT)
     VALUES 
     ( '{0}'   
      ,'{1}'
      ,'{2}'
      ,'{3}'
      ,'{4}'
      ,'{5}'
      , {6}
      ,'{7}'
      , NOW()
      )  
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>



  <ROW ID="SELECTHEALTHLIMITED " PARAMS="1">
    <DESC>헬스체크 임계정보</DESC>
    <DATA>
      <![CDATA[
      SELECT HCHK_NAME
      , IS_HIGHER
      , WARNING_THRESHOLD
      , CRITICAL_THRESHOLD
      , FIXED_THRESHOLD
      , COALESCE(RETENTION_TIME,0) RETENTION_TIME
      , COALESCE(USER_GROUP,0) USER_GROUP
      , COALESCE(NOTIFICATION_LEVEL,0) NOTIFICATION_LEVEL
      , COALESCE(NOTIFICATION_CYCLE,0) NOTIFICATION_CYCLE
      , COALESCE(BUSINESS_NAME,'') BUSINESS_NAME
      , COALESCE(RESERVED_STR,'') RESERVED_STR
      FROM TB_HCHK_THRD_LIST THR
      WHERE THR.INSTANCE_ID = {0}
      ORDER BY HCHK_NAME
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>

  <ROW ID="EXISTSSERVER" PARAMS="2">
    <DESC>기존에 DB 가 있는지 확인</DESC>
    <DATA>
      <![CDATA[
        SELECT INSTANCE_ID
        FROM TB_INSTANCE_INFO
        WHERE SERVER_IP ='{0}'
          AND SERVICE_PORT = '{1}'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTHEALTHLIMITEDLIST" PARAMS="2">
    <DESC>기존에 DB 가 있는지 확인</DESC>
    <DATA>
      <![CDATA[
      INSERT INTO TB_HCHK_THRD_LIST
        ( INSTANCE_ID 
          ,HCHK_NAME 
          ,UNIT 
          ,IS_HIGHER
          ,WARNING_THRESHOLD 
          ,CRITICAL_THRESHOLD 
          ,FIXED_THRESHOLD 
          ,LAST_MOD_IP 
          ,LAST_MOD_DT )
        ( SELECT {0} 
          , HCHK_NAME 
          , UNIT 
          , IS_HIGHER          
          , WARNING_THRESHOLD 
          , CRITICAL_THRESHOLD 
          , FIXED_THRESHOLD 
          , '{1}' 
          , NOW()
          FROM TB_HCHK_THRD_LIST
          WHERE INSTANCE_ID = -1
            AND HCHK_NAME NOT IN ( SELECT HCHK_NAME FROM TB_HCHK_THRD_LIST WHERE INSTANCE_ID = {0}) 
        )
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTHEALTH" PARAMS="2">
    <DESC>health Check</DESC>
    <DATA>
      <![CDATA[
    WITH  TEMP_MAX_SEQ AS ( 
	      SELECT A.INSTANCE_ID, MAX(A.REPL_REG_SEQ) MAX_REG_SEQ, ha_role 
	      FROM   TB_REPLICATION_INFO A 
	      WHERE  A.REG_DATE    = TO_CHAR(NOW(), 'YYYYMMDD')
        AND REPL_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) * 2 + 5 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM REPL_REG_SEQ)
	      GROUP BY A.INSTANCE_ID, ha_role
    )
     SELECT C.INSTANCE_ID                --PT_03_01_001
      --, A.CONN_NAME
      , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
      --, ((B.REG_DATE)::TIMESTAMP(0) + B.REG_TIME)::TIMESTAMP(0) AS REG_DATE 
      --, NOW() AS REG_DATE 
      , COLLECT_REG_DATE AS REG_DATE 
      , B.COLLECT_REG_SEQ AS REG_SEQ      
      , A.SERVER_IP AS SERVER_IP          --PT_03_08_001(ip)
      , A.SERVICE_PORT AS SERVICE_PORT    --PT_03_08_001(port)
      , A.VIRTUAL_IP   
      , A.VIRTUAL_IP2
      , A.RESERVED -- to check the status of virtual_ip2
      , C.HCHK_NAME AS HCHK_NAME    
      , CASE WHEN B.VALUE IS NULL THEN 0 ELSE ROUND(B.VALUE,2) END AS VALUE
      , C.UNIT AS UNIT
      , A.HA_ROLE AS HA_ROLE
      , A.HA_HOST AS HA_HOST              
      , A.HA_PORT AS HA_PORT
      , D.HA_ROLE AS HA_ROLE_S
      , (CASE /* FIXED_THRESHOLD ='0' CRITICAL -> 300 WARNING -> 200 NORMAL -> 100 */
             WHEN (B.VALUE >= CRITICAL_THRESHOLD AND IS_HIGHER ='0' AND FIXED_THRESHOLD ='0') THEN 300 
             WHEN (B.VALUE >  WARNING_THRESHOLD  AND B.VALUE < CRITICAL_THRESHOLD AND IS_HIGHER ='0' AND FIXED_THRESHOLD ='0') THEN 200
             WHEN (B.VALUE <= WARNING_THRESHOLD  AND IS_HIGHER ='0' AND FIXED_THRESHOLD ='0') THEN 100 
             WHEN (B.VALUE >  WARNING_THRESHOLD  AND IS_HIGHER ='1' AND FIXED_THRESHOLD ='0') THEN 100 
             WHEN (B.VALUE >= CRITICAL_THRESHOLD AND B.VALUE < WARNING_THRESHOLD  AND IS_HIGHER ='1' AND FIXED_THRESHOLD ='0') THEN 200
             WHEN (B.VALUE <  CRITICAL_THRESHOLD AND IS_HIGHER ='1' AND FIXED_THRESHOLD ='0') THEN 300 
      /* FIXED_THRESHOLD ='1' CRITICAL -> 300 WARNING -> 200 NORMAL -> 100 */
             WHEN (B.VALUE >  WARNING_THRESHOLD  AND IS_HIGHER ='0' AND FIXED_THRESHOLD ='1') THEN 200 
             WHEN (B.VALUE <= WARNING_THRESHOLD  AND IS_HIGHER ='0' AND FIXED_THRESHOLD ='1') THEN 100 
             WHEN (B.VALUE >  WARNING_THRESHOLD  AND IS_HIGHER ='1' AND FIXED_THRESHOLD ='1') THEN 100 
             WHEN (B.VALUE <= WARNING_THRESHOLD  AND IS_HIGHER ='1' AND FIXED_THRESHOLD ='1') THEN 200 
      /* FIXED_THRESHOLD ='2' CRITICAL -> 300 WARNING -> 200 NORMAL -> 100 */
             WHEN (B.VALUE >= CRITICAL_THRESHOLD AND IS_HIGHER ='0' AND FIXED_THRESHOLD ='2') THEN 300 
             WHEN (B.VALUE <  CRITICAL_THRESHOLD AND IS_HIGHER ='0' AND FIXED_THRESHOLD ='2') THEN 100 
             WHEN (B.VALUE >= CRITICAL_THRESHOLD AND IS_HIGHER ='1' AND FIXED_THRESHOLD ='2') THEN 100 
             WHEN (B.VALUE <  CRITICAL_THRESHOLD AND IS_HIGHER ='1' AND FIXED_THRESHOLD ='2') THEN 300 
      /* FIXED_THRESHOLD ='3' NORMAL -> 100 */
             WHEN (FIXED_THRESHOLD ='9') THEN 100                    
      /* DATA-NULL(LOCKCNT, TRAXIDLECNT) = NORMAL : 100 */
             WHEN B.VALUE IS NULL THEN 100
             ELSE 999      
         END) HCHK_VALUE
     ,   CASE WHEN C.hchk_name = 'REPLICATION_SLOT' 
       		   THEN (CASE WHEN collect_group = '5' AND B.VALUE = 1 THEN -1 
       		   		 ELSE (SELECT count(1) FROM TB_REPLICATION_SLOTS 
       		   		  	   WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') 
       		   		    	 AND REPL_REG_SEQ = (SELECT MAX(REPL_REG_SEQ) FROM TB_REPLICATION_INFO WHERE INSTANCE_ID = C.INSTANCE_ID AND REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')))
       		   		      END) 
       		    WHEN C.hchk_name = 'WALCNT' 
       		    THEN (SELECT wal_count FROM TB_WAL_INFO
       		   		     WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') 
       		   		       AND REPL_REG_SEQ = (SELECT MAX(REPL_REG_SEQ) FROM TB_WAL_INFO WHERE INSTANCE_ID = C.INSTANCE_ID AND REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD'))) 
       		   ELSE 0 END SUB_VALUE 
               , '' AS COMMENTS
               , NOW() AS COLLECT_TIME
      FROM TB_INSTANCE_INFO A, TB_HCHK_COLLECT_INFO B
      RIGHT OUTER JOIN TB_HCHK_THRD_LIST  C  
	                ON B.INSTANCE_ID = C.INSTANCE_ID
                  AND B.HCHK_NAME = C.HCHK_NAME
                  AND B.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
                  --AND B.HCHK_REG_SEQ = (SELECT DISTINCT(MAX(X.HCHK_REG_SEQ)) FROM TB_HCHK_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') GROUP BY X.INSTANCE_ID)
		              AND B.HCHK_REG_SEQ = (SELECT MAX(X.HCHK_REG_SEQ) FROM TB_HCHK_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD'))
      		 , TEMP_MAX_SEQ D
      WHERE A.COLLECT_YN = 'Y' 
      AND A.DELETE_YN = 'N'      
      AND A.INSTANCE_ID = C.INSTANCE_ID
      AND A.INSTANCE_ID = D.INSTANCE_ID
      AND a.INSTANCE_ID IN ({0})
      AND C.HCHK_NAME NOT LIKE 'HG%'
      AND C.HCHK_NAME <> 'SOLUTIONSTATUS'
      ORDER BY A.INSTANCE_ID; 
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTOBJECT" PARAMS="3">
    <DESC>Object Information</DESC>
    <DATA>
      <![CDATA[
        WITH TAC AS (         
            SELECT max(ACTV_REG_SEQ) ACTV_REG_SEQ, INSTANCE_ID, REG_DATE 
              FROM TB_ACTV_COLLECT_INFO 
             WHERE REG_DATE = TO_CHAR(NOW(),'YYYYMMDD') 
			   AND TO_DATE_IMM(REG_DATE, 'yyyymmdd') + REG_TIME > now() - interval '10 minute' 
             GROUP BY REG_DATE, INSTANCE_ID 
        ),
		    TAI AS (
			    SELECT TAII.*, TAC.INSTANCE_ID FROM TB_ACCESS_INFO TAII JOIN TAC ON TAII.REG_DATE = TAC.REG_DATE AND  TAII.ACTV_REG_SEQ = TAC.ACTV_REG_SEQ
			           WHERE TAII.REG_DATE = TO_CHAR(NOW(),'YYYYMMDD')
		    )
	      SELECT /* SELECTOBJECT */ IST.INSTANCE_ID
	          , MAX(TAI.COLLECT_DT) AS COLLECT_DT
              , CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END AS HOST_NAME
            , ROUND(SUM(TAI.CURRENT_SEQ_READ_TUPLES)/(AVG(DELTA_TIME)), 2)::Integer AS SEQ_SCAN_TUPLES_PER_SEC    --PT_04_09_001(Object : SEQ_SCAN_CNT)
            , ROUND(SUM(TAI.CURRENT_IDX_FETCH_TUPLES)/(AVG(DELTA_TIME)), 2)::Integer AS INDEX_SCAN_TUPLES_PER_SEC     --PT_04_09_001(Object : INDEX_SCAN_CNT)
            , ROUND(SUM(TAI.CURRENT_INSERT_TUPLES)/(AVG(DELTA_TIME)), 2)::Integer AS INSERT_TUPLES_PER_SEC          --PT_04_09_001(Object : INSERT_TUPLES)
            , ROUND(SUM(TAI.CURRENT_UPDATE_TUPLES)/(AVG(DELTA_TIME)), 2)::Integer AS UPDATE_TUPLES_PER_SEC          --PT_04_09_001(Object : UPDATE_TUPLES)
            , ROUND(SUM(TAI.CURRENT_DELETE_TUPLES)/(AVG(DELTA_TIME)), 2)::Integer AS DELETE_TUPLES_PER_SEC          --PT_04_09_001(Object : DELETE_TUPLES)
            , ROUND((SUM(TAI.CURRENT_SEQ_READ_TUPLES) + SUM(TAI.CURRENT_IDX_FETCH_TUPLES) - SUM(TAI.CURRENT_UPDATE_TUPLES) - SUM(TAI.CURRENT_DELETE_TUPLES)) / (AVG(DELTA_TIME)), 2)::Integer AS SELECT_TUPLES_PER_SEC  --PT_04_09_001(Object : READ_TUPLES)
            , ROUND(SUM(TAI.CURRENT_PHY_READ)/(AVG(DELTA_TIME)), 2)::Integer AS PHY_READ_PER_SEC
            , ROUND(SUM(TAI.CURRENT_COMMIT)/(AVG(DELTA_TIME)), 2)::Integer AS COMMIT_TUPLES_PER_SEC                 --PT_04_09_001(Object : COMMIT)
            , ROUND(SUM(TAI.CURRENT_ROLLBACK)/(AVG(DELTA_TIME)), 2)::Integer AS ROLLBACK_TUPLES_PER_SEC             --PT_04_09_001(Object : ROLLBACK)
            , IST.HA_GROUP
            , CASE WHEN {1}=0 THEN TO_CHAR(IST.INSTANCE_ID, '00')||IST.HOST_NAME ELSE TO_CHAR(IST.INSTANCE_ID, '00')||IST.CONN_NAME END AS SORTED_HOST_NAME
              FROM TB_INSTANCE_INFO IST,TAI
              WHERE IST.INSTANCE_ID IN ({0})
              AND IST.INSTANCE_ID = TAI.INSTANCE_ID
              AND IST.COLLECT_YN = 'Y'
              AND IST.DELETE_YN = 'N'
            GROUP BY IST.INSTANCE_ID,  CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END
            ORDER BY IST.INSTANCE_ID,  CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTOBJECT_OLD2" PARAMS="3">
    <DESC>Object Information</DESC>
    <DATA>
      <![CDATA[
        WITH TAC AS (         
            SELECT max(ACTV_REG_SEQ) ACTV_REG_SEQ, INSTANCE_ID, REG_DATE FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE = TO_CHAR(NOW(),'YYYYMMDD') GROUP BY REG_DATE, INSTANCE_ID 
		    ),
		    TAI AS (
			    SELECT TAII.*, TAC.INSTANCE_ID FROM TB_ACCESS_INFO TAII JOIN TAC ON TAII.REG_DATE = TAC.REG_DATE AND  TAII.ACTV_REG_SEQ = TAC.ACTV_REG_SEQ
			           WHERE TAII.REG_DATE = TO_CHAR(NOW(),'YYYYMMDD')
		    )
	      SELECT /* SELECTOBJECT */ IST.INSTANCE_ID
	          , MAX(TAI.COLLECT_DT) AS COLLECT_DT
              , CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END AS HOST_NAME
            , ROUND(SUM(TAI.CURRENT_SEQ_READ_TUPLES)/({2}/1000), 2) AS SEQ_SCAN_TUPLES_PER_SEC    --PT_04_09_001(Object : SEQ_SCAN_CNT)
            , ROUND(SUM(TAI.CURRENT_IDX_FETCH_TUPLES)/({2}/1000), 2) AS INDEX_SCAN_TUPLES_PER_SEC     --PT_04_09_001(Object : INDEX_SCAN_CNT)
            , ROUND(SUM(TAI.CURRENT_INSERT_TUPLES)/({2}/1000), 2) AS INSERT_TUPLES_PER_SEC          --PT_04_09_001(Object : INSERT_TUPLES)
            , ROUND(SUM(TAI.CURRENT_UPDATE_TUPLES)/({2}/1000), 2) AS UPDATE_TUPLES_PER_SEC          --PT_04_09_001(Object : UPDATE_TUPLES)
            , ROUND(SUM(TAI.CURRENT_DELETE_TUPLES)/({2}/1000), 2) AS DELETE_TUPLES_PER_SEC          --PT_04_09_001(Object : DELETE_TUPLES)
            , ROUND((SUM(TAI.CURRENT_SEQ_READ_TUPLES) + SUM(TAI.CURRENT_IDX_FETCH_TUPLES) - SUM(TAI.CURRENT_UPDATE_TUPLES) - SUM(TAI.CURRENT_DELETE_TUPLES)) / ({2}/1000), 2) AS SELECT_TUPLES_PER_SEC  --PT_04_09_001(Object : READ_TUPLES)
            , ROUND(SUM(TAI.CURRENT_PHY_READ)/({2}/1000), 2) AS PHY_READ_PER_SEC
            , ROUND(SUM(TAI.CURRENT_COMMIT)/({2}/1000), 2) AS COMMIT_TUPLES_PER_SEC                 --PT_04_09_001(Object : COMMIT)
            , ROUND(SUM(TAI.CURRENT_ROLLBACK)/({2}/1000), 2) AS ROLLBACK_TUPLES_PER_SEC             --PT_04_09_001(Object : ROLLBACK)
              FROM TB_INSTANCE_INFO IST,TAI
              WHERE IST.INSTANCE_ID IN ({0})
              AND IST.INSTANCE_ID = TAI.INSTANCE_ID
              AND IST.COLLECT_YN = 'Y'
              AND IST.DELETE_YN = 'N'
            GROUP BY IST.INSTANCE_ID,  CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END
            ORDER BY IST.INSTANCE_ID,  CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTOBJECT_OLD" PARAMS="0">
    <DESC>Object Information</DESC>
    <DATA>
      <![CDATA[
        SELECT /* SELECTOBJECT */ IST.INSTANCE_ID
        , MAX(ACS.COLLECT_DT) AS COLLECT_DT
        --, IST.CONN_NAME
        ,  CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END AS HOST_NAME
        , ROUND(SUM(ACS.CURRENT_SEQ_READ_TUPLES)/AVG(DELTA_TIME), 2) AS SEQ_SCAN_TUPLES_PER_SEC    --PT_04_09_001(Object : SEQ_SCAN_CNT)
        , ROUND(SUM(ACS.CURRENT_IDX_FETCH_TUPLES)/AVG(DELTA_TIME), 2) AS INDEX_SCAN_TUPLES_PER_SEC     --PT_04_09_001(Object : INDEX_SCAN_CNT)
        , ROUND(SUM(ACS.CURRENT_INSERT_TUPLES)/AVG(DELTA_TIME), 2) AS INSERT_TUPLES_PER_SEC          --PT_04_09_001(Object : INSERT_TUPLES)
        , ROUND(SUM(ACS.CURRENT_UPDATE_TUPLES)/AVG(DELTA_TIME), 2) AS UPDATE_TUPLES_PER_SEC          --PT_04_09_001(Object : UPDATE_TUPLES)
        , ROUND(SUM(ACS.CURRENT_DELETE_TUPLES)/AVG(DELTA_TIME), 2) AS DELETE_TUPLES_PER_SEC          --PT_04_09_001(Object : DELETE_TUPLES)
        , ROUND((SUM(ACS.CURRENT_SEQ_READ_TUPLES) + SUM(ACS.CURRENT_IDX_FETCH_TUPLES) - SUM(ACS.CURRENT_UPDATE_TUPLES) - SUM(ACS.CURRENT_DELETE_TUPLES)) / AVG(DELTA_TIME), 2) AS SELECT_TUPLES_PER_SEC  --PT_04_09_001(Object : READ_TUPLES)
        , ROUND(SUM(ACS.CURRENT_COMMIT)/AVG(DELTA_TIME), 2) AS COMMIT_TUPLES_PER_SEC                 --PT_04_09_001(Object : COMMIT)
        , ROUND(SUM(ACS.CURRENT_ROLLBACK)/AVG(DELTA_TIME), 2) AS ROLLBACK_TUPLES_PER_SEC             --PT_04_09_001(Object : ROLLBACK)
        FROM TB_INSTANCE_INFO IST, 
             TB_ACCESS_INFO ACS
        WHERE ACS.REG_DATE = TO_CHAR(NOW(),'YYYYMMDD')
        AND IST.INSTANCE_ID IN ({0})
        AND ACS.ACTV_REG_SEQ = (SELECT MAX(ACTV_REG_SEQ) AS ACTV_REG_SEQ FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') AND INSTANCE_ID = IST.INSTANCE_ID)
        AND IST.COLLECT_YN = 'Y'
        AND IST.DELETE_YN = 'N'
        --GROUP BY IST.INSTANCE_ID , IST.CONN_NAME
        GROUP BY IST.INSTANCE_ID ,  CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END
      ]]>
    </DATA>
  </ROW>
    <ROW ID="SELECTOBJECTPREV" PARAMS="0">
    <DESC>Object Information</DESC>
    <DATA>
      <![CDATA[
      SELECT INSTANCE_ID,
      		 TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {5} )) * {5} ) AT TIME ZONE 'UTC' AS COLLECT_DATE
      	 , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {5} )) * {5} ) AT TIME ZONE 'UTC' AS COLLECT_DT
		     , MAX(HOST_NAME) AS HOST_NAME
		     , AVG(SEQ_SCAN_TUPLES_PER_SEC) AS SEQ_SCAN_TUPLES_PER_SEC
		     , AVG(INDEX_SCAN_TUPLES_PER_SEC) AS INDEX_SCAN_TUPLES_PER_SEC
		     , AVG(INSERT_TUPLES_PER_SEC) AS INSERT_TUPLES_PER_SEC
		     , AVG(UPDATE_TUPLES_PER_SEC) AS UPDATE_TUPLES_PER_SEC
		     , AVG(DELETE_TUPLES_PER_SEC) AS DELETE_TUPLES_PER_SEC
		     , AVG(SELECT_TUPLES_PER_SEC) AS SELECT_TUPLES_PER_SEC
		     , AVG(PHY_READ_PER_SEC) AS PHY_READ_PER_SEC
		     , AVG(COMMIT_TUPLES_PER_SEC) AS COMMIT_TUPLES_PER_SEC
		     , AVG(ROLLBACK_TUPLES_PER_SEC) AS ROLLBACK_TUPLES_PER_SEC
		     , (AVG(COMMIT_TUPLES_PER_SEC)+AVG(ROLLBACK_TUPLES_PER_SEC)) AS TRANSACTION_TUPLES_PER_SEC
		FROM (
			      SELECT /* SELECTOBJECTPREV */ IST.INSTANCE_ID
			      , MAX(ACS.COLLECT_DT) AS COLLECT_DT
			      , CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END AS HOST_NAME
			      , ROUND(SUM(ACS.CURRENT_SEQ_READ_TUPLES)/AVG(DELTA_TIME), 2) AS SEQ_SCAN_TUPLES_PER_SEC    --PT_04_09_001(Object : SEQ_SCAN_CNT)
			      , ROUND(SUM(ACS.CURRENT_IDX_FETCH_TUPLES)/AVG(DELTA_TIME), 2) AS INDEX_SCAN_TUPLES_PER_SEC     --PT_04_09_001(Object : INDEX_SCAN_CNT)
			      , ROUND(SUM(ACS.CURRENT_INSERT_TUPLES)/AVG(DELTA_TIME), 2) AS INSERT_TUPLES_PER_SEC          --PT_04_09_001(Object : INSERT_TUPLES)
			      , ROUND(SUM(ACS.CURRENT_UPDATE_TUPLES)/AVG(DELTA_TIME), 2) AS UPDATE_TUPLES_PER_SEC          --PT_04_09_001(Object : UPDATE_TUPLES)
			      , ROUND(SUM(ACS.CURRENT_DELETE_TUPLES)/AVG(DELTA_TIME), 2) AS DELETE_TUPLES_PER_SEC          --PT_04_09_001(Object : DELETE_TUPLES)
			      , ROUND((SUM(ACS.CURRENT_SEQ_READ_TUPLES) + SUM(ACS.CURRENT_IDX_FETCH_TUPLES) - SUM(ACS.CURRENT_UPDATE_TUPLES) - SUM(ACS.CURRENT_DELETE_TUPLES)) / AVG(DELTA_TIME), 2) AS SELECT_TUPLES_PER_SEC  --PT_04_09_001(Object : READ_TUPLES)
            , ROUND(SUM(ACS.CURRENT_PHY_READ)/AVG(DELTA_TIME), 2) AS PHY_READ_PER_SEC
			      , ROUND(SUM(ACS.CURRENT_COMMIT)/AVG(DELTA_TIME), 2) AS COMMIT_TUPLES_PER_SEC                 --PT_04_09_001(Object : COMMIT)
			      , ROUND(SUM(ACS.CURRENT_ROLLBACK)/AVG(DELTA_TIME), 2) AS ROLLBACK_TUPLES_PER_SEC             --PT_04_09_001(Object : ROLLBACK)
			      FROM TB_INSTANCE_INFO IST, 
			           TB_ACCESS_INFO ACS,
			           TB_ACTV_COLLECT_INFO COL
			      WHERE ACS.REG_DATE {2}
			      AND ACS.REG_DATE=COL.REG_DATE
			      AND IST.INSTANCE_ID IN ({0})
			      AND COL.INSTANCE_ID = IST.INSTANCE_ID
			      AND COL.ACTV_REG_SEQ = ACS.ACTV_REG_SEQ
			      AND IST.COLLECT_YN = 'Y'
			      AND IST.DELETE_YN = 'N'
			      --AND ACS.COLLECT_DT BETWEEN {3} AND {4}
            AND TO_DATE_IMM(COL.REG_DATE, 'yyyymmdd') + COL.REG_TIME BETWEEN  {3} AND {4}
			      GROUP BY IST.INSTANCE_ID, COL.ACTV_REG_SEQ
			      ORDER BY COLLECT_DT, IST.INSTANCE_ID
		      ) AA
       GROUP BY COLLECT_DATE, INSTANCE_ID
       ORDER BY COLLECT_DATE, INSTANCE_ID
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTDETAILOBJECT" PARAMS="0">
    <DESC>Object Information</DESC>
    <DATA>
      <![CDATA[
--      SELECT /* SELECTDETAILOBJECT */ IST.INSTANCE_ID
--      , MAX(ACS.COLLECT_DT) AS COLLECT_DT
--      , CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END AS HOST_NAME
--      , ROUND(SUM(ACS.CURRENT_SEQ_READ_TUPLES)/AVG(DELTA_TIME), 2) AS SEQ_SCAN_TUPLES_PER_SEC    --PT_04_09_001(Object : SEQ_SCAN_CNT)
--      , ROUND(SUM(ACS.CURRENT_IDX_FETCH_TUPLES)/AVG(DELTA_TIME), 2) AS INDEX_SCAN_TUPLES_PER_SEC     --PT_04_09_001(Object : INDEX_SCAN_CNT)
--      , ROUND(SUM(ACS.CURRENT_INSERT_TUPLES)/AVG(DELTA_TIME), 2) AS INSERT_TUPLES_PER_SEC          --PT_04_09_001(Object : INSERT_TUPLES)
--      , ROUND(SUM(ACS.CURRENT_UPDATE_TUPLES)/AVG(DELTA_TIME), 2) AS UPDATE_TUPLES_PER_SEC          --PT_04_09_001(Object : UPDATE_TUPLES)
--      , ROUND(SUM(ACS.CURRENT_DELETE_TUPLES)/AVG(DELTA_TIME), 2) AS DELETE_TUPLES_PER_SEC          --PT_04_09_001(Object : DELETE_TUPLES)
--      , ROUND((SUM(ACS.CURRENT_SEQ_READ_TUPLES) + SUM(ACS.CURRENT_IDX_FETCH_TUPLES) - SUM(ACS.CURRENT_UPDATE_TUPLES) - SUM(ACS.CURRENT_DELETE_TUPLES)) / AVG(DELTA_TIME), 2) AS SELECT_TUPLES_PER_SEC  --PT_04_09_001(Object : READ_TUPLES)
--      , ROUND(SUM(ACS.CURRENT_COMMIT)/AVG(DELTA_TIME), 2) AS COMMIT_TUPLES_PER_SEC                 --PT_04_09_001(Object : COMMIT)
--      , ROUND(SUM(ACS.CURRENT_ROLLBACK)/AVG(DELTA_TIME), 2) AS ROLLBACK_TUPLES_PER_SEC             --PT_04_09_001(Object : ROLLBACK)
--      , ROUND(SUM(ACS.CURRENT_PHY_READ)/AVG(DELTA_TIME), 2) AS PHY_READ_PER_SEC
--      FROM TB_INSTANCE_INFO IST, 
--           TB_ACCESS_INFO ACS,
--           TB_ACTV_COLLECT_INFO COL
--      WHERE ACS.REG_DATE {2}
--      AND ACS.REG_DATE=COL.REG_DATE
--      AND IST.INSTANCE_ID IN ({0})
--      AND COL.INSTANCE_ID = IST.INSTANCE_ID
--      AND COL.ACTV_REG_SEQ = ACS.ACTV_REG_SEQ
--      AND IST.COLLECT_YN = 'Y'
--      AND IST.DELETE_YN = 'N'
--      AND ACS.COLLECT_DT BETWEEN {3} AND {4}
--      GROUP BY IST.INSTANCE_ID, COL.ACTV_REG_SEQ
--      ORDER BY COLLECT_DT, IST.INSTANCE_ID
  SELECT /* SELECTDETAILOBJECT */ INSTANCE_ID 
			  , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {5} )) * {5}) AT TIME ZONE 'UTC' AS COLLECT_DATE
		      , HOST_NAME AS HOST_NAME
		      , AVG(SEQ_SCAN_TUPLES_PER_SEC) AS SEQ_SCAN_TUPLES_PER_SEC    --PT_04_09_001(Object : SEQ_SCAN_CNT)
		      , AVG(INDEX_SCAN_TUPLES_PER_SEC) AS INDEX_SCAN_TUPLES_PER_SEC     --PT_04_09_001(Object : INDEX_SCAN_CNT)
		      , AVG(INSERT_TUPLES_PER_SEC) AS INSERT_TUPLES_PER_SEC          --PT_04_09_001(Object : INSERT_TUPLES)
		      , AVG(UPDATE_TUPLES_PER_SEC) AS UPDATE_TUPLES_PER_SEC          --PT_04_09_001(Object : UPDATE_TUPLES)
		      , AVG(DELETE_TUPLES_PER_SEC) AS DELETE_TUPLES_PER_SEC          --PT_04_09_001(Object : DELETE_TUPLES)
		      , AVG(SELECT_TUPLES_PER_SEC) AS SELECT_TUPLES_PER_SEC  --PT_04_09_001(Object : READ_TUPLES)
		      , AVG(COMMIT_TUPLES_PER_SEC) AS COMMIT_TUPLES_PER_SEC                 --PT_04_09_001(Object : COMMIT)
		      , AVG(ROLLBACK_TUPLES_PER_SEC) AS ROLLBACK_TUPLES_PER_SEC             --PT_04_09_001(Object : ROLLBACK)
		      , AVG(PHY_READ_PER_SEC) AS PHY_READ_PER_SEC
          , (MAX(COMMIT_TUPLES_PER_SEC)+MAX(ROLLBACK_TUPLES_PER_SEC)) AS TRANSACTION_TUPLES_PER_SEC
          , AVG(SELECT_TUPLES_PER_SEC) AS CALLS
	 FROM (
		     SELECT /* SELECTDETAILOBJECT */ IST.INSTANCE_ID
		      , MAX(ACS.COLLECT_DT) AS COLLECT_DT
		      , CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END AS HOST_NAME
		      , ROUND(SUM(ACS.CURRENT_SEQ_READ_TUPLES)/AVG(DELTA_TIME), 2) AS SEQ_SCAN_TUPLES_PER_SEC    --PT_04_09_001(Object : SEQ_SCAN_CNT)
		      , ROUND(SUM(ACS.CURRENT_IDX_FETCH_TUPLES)/AVG(DELTA_TIME), 2) AS INDEX_SCAN_TUPLES_PER_SEC     --PT_04_09_001(Object : INDEX_SCAN_CNT)
		      , ROUND(SUM(ACS.CURRENT_INSERT_TUPLES)/AVG(DELTA_TIME), 2) AS INSERT_TUPLES_PER_SEC          --PT_04_09_001(Object : INSERT_TUPLES)
		      , ROUND(SUM(ACS.CURRENT_UPDATE_TUPLES)/AVG(DELTA_TIME), 2) AS UPDATE_TUPLES_PER_SEC          --PT_04_09_001(Object : UPDATE_TUPLES)
		      , ROUND(SUM(ACS.CURRENT_DELETE_TUPLES)/AVG(DELTA_TIME), 2) AS DELETE_TUPLES_PER_SEC          --PT_04_09_001(Object : DELETE_TUPLES)
		      , ROUND((SUM(ACS.CURRENT_SEQ_READ_TUPLES) + SUM(ACS.CURRENT_IDX_FETCH_TUPLES) - SUM(ACS.CURRENT_UPDATE_TUPLES) - SUM(ACS.CURRENT_DELETE_TUPLES)) / AVG(DELTA_TIME), 2) AS SELECT_TUPLES_PER_SEC  --PT_04_09_001(Object : READ_TUPLES)
		      , ROUND(SUM(ACS.CURRENT_COMMIT)/AVG(DELTA_TIME), 2) AS COMMIT_TUPLES_PER_SEC                 --PT_04_09_001(Object : COMMIT)
		      , ROUND(SUM(ACS.CURRENT_ROLLBACK)/AVG(DELTA_TIME), 2) AS ROLLBACK_TUPLES_PER_SEC             --PT_04_09_001(Object : ROLLBACK)
		      , ROUND(SUM(ACS.CURRENT_PHY_READ)/AVG(DELTA_TIME), 2) AS PHY_READ_PER_SEC
		      FROM TB_INSTANCE_INFO IST, 
		           TB_ACCESS_INFO ACS,
		           TB_ACTV_COLLECT_INFO COL
		      WHERE COL.REG_DATE {2}
		      AND ACS.REG_DATE=COL.REG_DATE
		      AND IST.INSTANCE_ID IN ({0})
		      AND COL.INSTANCE_ID = IST.INSTANCE_ID
		      AND COL.ACTV_REG_SEQ = ACS.ACTV_REG_SEQ
		      AND IST.COLLECT_YN = 'Y'
		      AND IST.DELETE_YN = 'N'
		      --AND ACS.COLLECT_DT BETWEEN {3} AND {4}
          AND TO_DATE_IMM(COL.REG_DATE, 'yyyymmdd') + COL.REG_TIME BETWEEN {3} AND {4}
		      GROUP BY IST.INSTANCE_ID, COL.ACTV_REG_SEQ
		      ORDER BY COLLECT_DT, IST.INSTANCE_ID
		   ) AS OI
	GROUP BY COLLECT_DATE, INSTANCE_ID, HOST_NAME
	ORDER BY COLLECT_DATE, INSTANCE_ID
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTDETAILCALLS" PARAMS="5">
    <DESC>Object Information</DESC>
    <DATA>
      <![CDATA[
	  SELECT /* SELECTDETAILCALLS */ INSTANCE_ID
  	    ,TO_TIMESTAMP(FLOOR((EXTRACT('EPOCH' FROM COLLECT_DT) / {4} )) * {4}) AT TIME ZONE 'UTC' AS COLLECT_DATE
        ,SUM(SUM_CALLS) CALLS
  	    FROM (
	   	  SELECT IST.INSTANCE_ID,
			     COLLECT_DT,
			     SUM(CALLS) SUM_CALLS,
			     CASE WHEN {1}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END AS HOST_NAME		   
		    FROM TB_INSTANCE_INFO IST, 
		  	     TB_REALTIME_STATEMENTS  RT	  	   
	  	   WHERE IST.INSTANCE_ID IN ({0})
		     AND RT.INSTANCE_ID = IST.INSTANCE_ID
		     AND COLLECT_DT BETWEEN {2} AND {3}
		   GROUP BY IST.INSTANCE_ID, COLLECT_DT
	   ) AS CT
	   GROUP BY COLLECT_DATE, INSTANCE_ID, HOST_NAME
	   ORDER BY COLLECT_DATE, INSTANCE_ID
      ]]>
    </DATA>
  </ROW>  
  
  <ROW ID="SELECTSESSIONINFO" PARAMS="0">
    <DESC>SESSEIONINFO</DESC>
    <DATA>
      <![CDATA[
         SELECT /* SELECTSESSIONINFO */ 
             INSTANCE_ID
             , MAX(BAK.COLLECT_DT) AS COLLECT_DT
	           --, ROUND(SUM(CASE WHEN (BAK.SQL <> '<IDLE>') THEN 1 ELSE 0 END)::numeric / MAX(IST.MAX_CONN_CNT) * 100, 2) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
	           --, ROUND((COUNT(BAK.SQL)::numeric / MAX(IST.MAX_CONN_CNT)) * 100,2) AS TOT_BACKEND_CNT 
	           --, ROUND(SUM(CASE WHEN (BAK.SQL <> '<IDLE>') THEN 1 ELSE 0 END)::numeric) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
	           , ROUND(SUM(CASE WHEN (BAK.STATE = 'active') THEN 1 ELSE 0 END)::numeric)::integer AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
	           , ROUND(COUNT(BAK.STATE)::numeric)::integer AS TOT_BACKEND_CNT  
	         , IST.HA_ROLE
	         , IST.HA_GROUP
         FROM TB_INSTANCE_INFO IST
             , TB_BACKEND_RSC BAK
         WHERE BAK.REG_DATE=TO_CHAR(NOW(),'YYYYMMDD')
         AND IST.INSTANCE_ID IN ({0})
	       AND BAK.ACTV_REG_SEQ = (SELECT MAX(ACTV_REG_SEQ) AS ACTV_REG_SEQ FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') AND INSTANCE_ID=IST.INSTANCE_ID)
	       AND IST.COLLECT_YN = 'Y'
	       AND IST.DELETE_YN = 'N'
	       GROUP BY IST.INSTANCE_ID;
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTSESSIONINFOPREV" PARAMS="0">
    <DESC>SESSEIONINFO</DESC>
    <DATA>
      <![CDATA[         
      SELECT /* SELECTSESSIONINFOPREV */ 
            INSTANCE_ID, 
      		  TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {2} )) * {2} ) AT TIME ZONE 'UTC' AS COLLECT_DATE,
      		  MAX(CUR_ACTV_BACKEND_CNT) AS CUR_ACTV_BACKEND_CNT,
      		  MAX(TOT_BACKEND_CNT) AS TOT_BACKEND_CNT
        FROM (
	            WITH COL AS (
        			SELECT B.INSTANCE_ID,
        				   B.REG_DATE,
		                   B.ACTV_REG_SEQ,
		                   B.REG_DATE::DATE + B.REG_TIME AS COLLECT_DT
		               FROM TB_INSTANCE_INFO I
		                   , TB_ACTV_COLLECT_INFO B
		               WHERE B.REG_DATE {1}
		                 AND I.INSTANCE_ID IN ({0})
			             AND B.INSTANCE_ID=I.INSTANCE_ID
                    	 AND TO_DATE_IMM(B.REG_DATE, 'yyyymmdd') + B.REG_TIME > now() - interval '3 minute'
		                 AND I.COLLECT_YN = 'Y'
		                 AND I.DELETE_YN = 'N'
        			)
		            SELECT /* SELECTSESSIONINFOPREV */ 
		                   IST.INSTANCE_ID,
		                   COL.COLLECT_DT AS COLLECT_DT
		                   --, BAK.COLLECT_DT AS COLLECT_DT
			               --, ROUND(SUM(CASE WHEN (BAK.SQL <> '<IDLE>') THEN 1 ELSE 0 END)::NUMERIC) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
			               , ROUND(SUM(CASE WHEN (BAK.STATE = 'active') THEN 1 ELSE 0 END)::NUMERIC) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
			               , ROUND(COUNT(BAK.STATE)::NUMERIC) AS TOT_BACKEND_CNT 
		               FROM TB_INSTANCE_INFO IST
		                   , COL LEFT OUTER JOIN TB_BACKEND_RSC BAK 
		                   ON COL.REG_DATE  = BAK.REG_DATE
		                   AND COL.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ
		               WHERE IST.INSTANCE_ID IN ({0})
			             AND COL.INSTANCE_ID=IST.INSTANCE_ID
		                 AND IST.COLLECT_YN = 'Y'
		                 AND IST.DELETE_YN = 'N'
		             GROUP BY COL.REG_DATE, COL.COLLECT_DT, IST.INSTANCE_ID
		             ORDER BY COL.COLLECT_DT,IST.INSTANCE_ID
	  		     ) AA
	     GROUP BY COLLECT_DATE, INSTANCE_ID
	     ORDER BY COLLECT_DATE, INSTANCE_ID
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTSESSIONINFOPREV_OLD" PARAMS="0">
    <DESC>SESSEIONINFO</DESC>
    <DATA>
      <![CDATA[         
      SELECT /* SELECTSESSIONINFOPREV */ 
            INSTANCE_ID, 
      		  TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {2} )) * {2} ) AT TIME ZONE 'UTC' AS COLLECT_DATE,
      		  MAX(CUR_ACTV_BACKEND_CNT) AS CUR_ACTV_BACKEND_CNT,
      		  MAX(TOT_BACKEND_CNT) AS TOT_BACKEND_CNT
        FROM (
		            SELECT /* SELECTSESSIONINFOPREV */ 
		                   IST.INSTANCE_ID,
		                   COL.REG_DATE::DATE + COL.REG_TIME AS COLLECT_DT
		                   --, BAK.COLLECT_DT AS COLLECT_DT
			               --, ROUND(SUM(CASE WHEN (BAK.SQL <> '<IDLE>') THEN 1 ELSE 0 END)::NUMERIC) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
			               , ROUND(SUM(CASE WHEN (BAK.STATE = 'active') THEN 1 ELSE 0 END)::NUMERIC) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
			               , ROUND(COUNT(BAK.STATE)::NUMERIC) AS TOT_BACKEND_CNT 
		               FROM TB_INSTANCE_INFO IST
		                   , TB_ACTV_COLLECT_INFO COL LEFT OUTER JOIN TB_BACKEND_RSC BAK 
		                   ON COL.REG_DATE  = BAK.REG_DATE
		                   AND COL.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ
		               WHERE COL.REG_DATE {1}
		                 AND IST.INSTANCE_ID IN ({0})
			               AND COL.INSTANCE_ID=IST.INSTANCE_ID
		                 --AND COL.REG_TIME {2}
                     AND TO_DATE_IMM(COL.REG_DATE, 'yyyymmdd') + COL.REG_TIME > now() - interval '3 minute'
		                 AND IST.COLLECT_YN = 'Y'
		                 AND IST.DELETE_YN = 'N'
		             GROUP BY COL.REG_DATE, COL.REG_TIME, IST.INSTANCE_ID
		             ORDER BY COL.REG_TIME,IST.INSTANCE_ID
	  		     ) AA
	     GROUP BY COLLECT_DATE, INSTANCE_ID
	     ORDER BY COLLECT_DATE, INSTANCE_ID
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTDETAILSESSIONINFO" PARAMS="0">
    <DESC>SESSEIONINFO</DESC>
    <DATA>
      <![CDATA[         
--     SELECT /* SELECTSESSIONINFOPREV */ 
--            IST.INSTANCE_ID,
--            TO_CHAR(COL.REG_DATE::DATE, 'YYYY-MM-DD') ||' ' || COL.REG_TIME AS COLLECT_DT
--          --, BAK.COLLECT_DT AS COLLECT_DT
--         --, ROUND(SUM(CASE WHEN (BAK.SQL <> '<IDLE>') THEN 1 ELSE 0 END)::NUMERIC) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
--         , ROUND(SUM(CASE WHEN (BAK.STATE = 'active') THEN 1 ELSE 0 END)::NUMERIC) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
--         , ROUND(COUNT(BAK.STATE)::NUMERIC) AS TOT_BACKEND_CNT 
--        FROM TB_INSTANCE_INFO IST
--            , TB_ACTV_COLLECT_INFO COL LEFT OUTER JOIN TB_BACKEND_RSC BAK 
--            ON COL.REG_DATE  = BAK.REG_DATE
--            AND COL.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ
--        WHERE COL.REG_DATE {1}
--          AND IST.INSTANCE_ID IN ({0})
--         AND COL.INSTANCE_ID=IST.INSTANCE_ID
--          AND COL.REG_TIME {2}
--          AND IST.COLLECT_YN = 'Y'
--          AND IST.DELETE_YN = 'N'
--      GROUP BY COL.REG_DATE, COL.REG_TIME, IST.INSTANCE_ID
--      ORDER BY COL.REG_TIME,IST.INSTANCE_ID;

	  SELECT /* SELECTSESSIONINFOPREV */
        INSTANCE_ID, 
	  		TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {3} )) * {3}) AT TIME ZONE 'UTC' AS COLLECT_DATE,
	  		MAX(CUR_ACTV_BACKEND_CNT) AS CUR_ACTV_BACKEND_CNT,
	  		MAX(TOT_BACKEND_CNT) AS TOT_BACKEND_CNT
	  FROM (
		      SELECT /* SELECTSESSIONINFOPREV */ 
		             IST.INSTANCE_ID,
		             COL.REG_DATE::DATE + COL.REG_TIME AS COLLECT_DT
		           --, BAK.COLLECT_DT AS COLLECT_DT
			         --, ROUND(SUM(CASE WHEN (BAK.SQL <> '<IDLE>') THEN 1 ELSE 0 END)::NUMERIC) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
			         , ROUND(SUM(CASE WHEN (BAK.STATE = 'active') THEN 1 ELSE 0 END)::NUMERIC) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
			         , ROUND(COUNT(BAK.STATE)::NUMERIC) AS TOT_BACKEND_CNT 
		         FROM TB_INSTANCE_INFO IST
		             , TB_ACTV_COLLECT_INFO COL LEFT OUTER JOIN TB_BACKEND_RSC BAK 
		             ON COL.REG_DATE  = BAK.REG_DATE
		             AND COL.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ
		         WHERE COL.REG_DATE {1}
		           AND IST.INSTANCE_ID IN ({0})
			         AND COL.INSTANCE_ID=IST.INSTANCE_ID
		           --AND COL.REG_TIME {2}
               AND TO_DATE_IMM(COL.REG_DATE, 'yyyymmdd') + COL.REG_TIME {2}
		           AND IST.COLLECT_YN = 'Y'
		           AND IST.DELETE_YN = 'N'
		       GROUP BY COL.REG_DATE, COL.REG_TIME, IST.INSTANCE_ID
		       ORDER BY COL.REG_TIME,IST.INSTANCE_ID
			) AS SESSIONINFO
	 GROUP BY COLLECT_DATE, INSTANCE_ID	
	 ORDER BY COLLECT_DATE, INSTANCE_ID	
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTSESSIONINFOPREV_BAK" PARAMS="0">
    <DESC>SESSEIONINFO</DESC>
    <DATA>
      <![CDATA[         
    	SELECT /* SELECTSESSIONINFOPREV */ 
             IST.INSTANCE_ID
             , BAK.COLLECT_DT AS COLLECT_DT
	           --, ROUND(SUM(CASE WHEN (BAK.SQL <> '<IDLE>') THEN 1 ELSE 0 END)::numeric / MAX(IST.MAX_CONN_CNT) * 100, 2) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
	           --, ROUND((COUNT(BAK.SQL)::numeric / MAX(IST.MAX_CONN_CNT)) * 100,2) AS TOT_BACKEND_CNT 
	           --, ROUND(SUM(CASE WHEN (BAK.SQL <> '<IDLE>') THEN 1 ELSE 0 END)::numeric) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
	           , ROUND(SUM(CASE WHEN (BAK.STATE = 'active') THEN 1 ELSE 0 END)::numeric) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
	           , ROUND(COUNT(BAK.SQL)::numeric) AS TOT_BACKEND_CNT 
         FROM TB_INSTANCE_INFO IST
             , TB_BACKEND_RSC BAK
             , TB_ACTV_COLLECT_INFO COL
         WHERE BAK.REG_DATE {1}
         AND BAK.REG_DATE=COL.REG_DATE
	       AND BAK.ACTV_REG_SEQ=COL.ACTV_REG_SEQ
         AND IST.INSTANCE_ID IN ({0})
	       AND COL.INSTANCE_ID=IST.INSTANCE_ID
         AND COL.REG_TIME {2} 
         AND IST.COLLECT_YN = 'Y'
         AND IST.DELETE_YN = 'N'
       GROUP BY IST.INSTANCE_ID,BAK.COLLECT_DT
       ORDER BY BAK.COLLECT_DT,IST.INSTANCE_ID
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTSESSIONSTATSINFO" PARAMS="0">
    <DESC>SELECTSESSIONSTATSINFO</DESC>
    <DATA>
      <![CDATA[
	      SELECT /* SELECTSESSIONSTATSINFO */ 
		      A.INSTANCE_ID
		      , A.COLLECT_DT
		      , ROUND(A.ACTIVE_SESSION_CNT / IST.MAX_CONN_CNT * 100) AS ACTIVE_SESSION
		      , ROUND(A.IDLE_SESSION_CNT / IST.MAX_CONN_CNT * 100) AS IDLE_SESSION
	      FROM TB_INSTANCE_INFO IST JOIN TB_SESSION_STATS A on IST.INSTANCE_ID = A.INSTANCE_ID
	      WHERE A.REG_DATE=TO_CHAR(NOW(),'YYYYMMDD')
	      AND IST.INSTANCE_ID IN ({0})
	      AND IST.COLLECT_YN = 'Y'
	      AND IST.DELETE_YN = 'N'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTSESSIONTOPINFO" PARAMS="0">
    <DESC>SELECTSESSIONTOPINFO</DESC>
    <DATA>
      <![CDATA[
      SELECT /* SELECTSESSIONTOPINFO */
		      INSTANCE_ID, COLLECT_DT, TOT_BACKEND_CNT, CLIENT_ADDR
        FROM (
	           SELECT /* SELECTSESSIONTOPINFO */ 
                  2 SEQ,
                   INSTANCE_ID
                   , MAX(BAK.COLLECT_DT) AS COLLECT_DT
	               , ROUND(SUM(CASE WHEN (BAK.STATE = 'active') THEN 1 ELSE 0 END)::numeric) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
	               , ROUND(COUNT(BAK.STATE)::numeric) AS TOT_BACKEND_CNT
	               , COALESCE(BAK.CLIENT_ADDR, 'Local') CLIENT_ADDR
               FROM TB_INSTANCE_INFO IST
                   , TB_BACKEND_RSC BAK
               WHERE BAK.REG_DATE=TO_CHAR(NOW(),'YYYYMMDD')
               AND IST.INSTANCE_ID = {0}
	             AND BAK.ACTV_REG_SEQ = (SELECT MAX(ACTV_REG_SEQ) AS ACTV_REG_SEQ FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') AND INSTANCE_ID=IST.INSTANCE_ID)
	             GROUP BY INSTANCE_ID, BAK.CLIENT_ADDR
		      UNION
               SELECT 
                  1 SEQ,
                   INSTANCE_ID
                   , MAX(BAK.COLLECT_DT) AS COLLECT_DT
	               , ROUND(SUM(CASE WHEN (BAK.STATE = 'active') THEN 1 ELSE 0 END)::numeric) AS CUR_ACTV_BACKEND_CNT --PT_04_06_001(SESSION INFO : CURRENT_ACTIVE_BACKEND_CNT)
	               , ROUND(COUNT(BAK.STATE)::numeric) AS TOT_BACKEND_CNT
	               , 'Total' AS CLIENT_ADDR
               FROM TB_INSTANCE_INFO IST
                   , TB_BACKEND_RSC BAK
               WHERE BAK.REG_DATE=TO_CHAR(NOW(),'YYYYMMDD')
               AND IST.INSTANCE_ID = {0}
	             AND BAK.ACTV_REG_SEQ = (SELECT MAX(ACTV_REG_SEQ) AS ACTV_REG_SEQ FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') AND INSTANCE_ID=IST.INSTANCE_ID)
	             GROUP BY INSTANCE_ID
	             ORDER BY TOT_BACKEND_CNT DESC, CLIENT_ADDR
	          ) AS STAT
	      ORDER BY SEQ
      ]]>
    </DATA>
  </ROW>
  <ROW ID="AGENTSVRSTATE" PARAMS="0">
    <DESC>AGENTSVRSTATE</DESC>
    <DATA>
      <![CDATA[
     SELECT NOW(),CASE WHEN AGE(NOW(),REG_DATE::DATE+REG_TIME::TIME) < '6 MIN' THEN 1 ELSE 0 END AS STATUS 
      FROM TB_RSC_COLLECT_INFO 
     WHERE (REG_DATE, RSC_REG_SEQ) IN (SELECT REG_DATE, RSC_REG_SEQ FROM TB_CPU_STAT_MASTER WHERE COLLECT_DT = (SELECT MAX(COLLECT_DT) FROM TB_CPU_STAT_MASTER))
      ]]>
    </DATA>
  </ROW>
   
  
    <ROW ID="SELECTREPORTCPU" PARAMS="4">
      <DESC>SELECTREPORTCPU</DESC>
      <DATA>
        <![CDATA[
        --Report (cpu info info)         
        SELECT /* SELECTREPORTCPU */ 
	         A.INSTANCE_ID
          , CASE WHEN {4}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
	        , MAX(C.COLLECT_DT) AS COLLECT_DT
          , ROUND(AVG(C.USER_UTIL_RATE)/100,4) AS USER_UTIL_RATE
          , ROUND(AVG(C.NICE_UTIL_RATE)/100,4) AS NICE_UTIL_RATE
          , ROUND(AVG(C.SYS_UTIL_RATE)/100,4) AS SYS_UTIL_RATE
          , ROUND(AVG(C.WAIT_UTIL_RATE)/100,4) AS WAIT_UTIL_RATE  
          , ROUND(AVG(C.IDLE_UTIL_RATE)/100,4) AS IDLE_UTIL_RATE      
        FROM TB_INSTANCE_INFO A
          , TB_RSC_COLLECT_INFO B
          , TB_CPU_STAT_MASTER C
        WHERE A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N'     
          AND A.INSTANCE_ID ={0}
          AND B.REG_DATE = C.REG_DATE
          AND B.REG_DATE {1}   -- Dynamic('IN' or '=' )
 	        AND C.COLLECT_DT BETWEEN '{2}' AND '{3}'
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND C.RSC_REG_SEQ = B.RSC_REG_SEQ
          GROUP BY A.INSTANCE_ID
          ORDER BY A.INSTANCE_ID, B.RSC_REG_SEQ DESC;
      ]]>
      </DATA>
    </ROW>
      <ROW ID="SELECTREPORTCPUCHART" PARAMS="4">
        <DESC>SELECTREPORTCPUCHART</DESC>
        <DATA>
          <![CDATA[
        --Report (cpu info chart)         
 --       SELECT /* SELECTREPORTCPUCHART */ 
 --         A.INSTANCE_ID
 --         , C.COLLECT_DT COLLECT_DT
 --         , CASE WHEN C.USER_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE + C.NICE_UTIL_RATE > 100 THEN 100.00 ELSE ROUND((C.USER_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE + C.NICE_UTIL_RATE),2) END AS USED_UTIL_RATE
 --         , ROUND((C.WAIT_UTIL_RATE),2) AS WAIT_UTIL_RATE                                           
 --       FROM TB_INSTANCE_INFO A
 --         , TB_RSC_COLLECT_INFO B
 --         , TB_CPU_STAT_MASTER C
 --       WHERE A.COLLECT_YN = 'Y'
 --         AND A.DELETE_YN = 'N'     
 --         AND A.INSTANCE_ID = {0}
 --         AND B.REG_DATE = C.REG_DATE
 --         AND B.REG_DATE {1}   -- Dynamic('IN' or '=' )
 --         AND C.COLLECT_DT BETWEEN '{2}' AND '{3}'
 --         AND A.INSTANCE_ID = B.INSTANCE_ID
 --         AND C.RSC_REG_SEQ = B.RSC_REG_SEQ
 --         ORDER BY A.INSTANCE_ID, B.RSC_REG_SEQ ASC;   
       SELECT /* SELECTREPORTCPUCHART */ 
	        A.INSTANCE_ID
	        , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM C.COLLECT_DT) / {4} )) * {4}) AT TIME ZONE 'UTC' AS COLLECT_DATE
          , CASE WHEN MAX(C.USER_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE + C.NICE_UTIL_RATE) > 100 THEN 100.00 ELSE ROUND((MAX(C.USER_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE + C.NICE_UTIL_RATE)),2) END AS USED_UTIL_RATE
          , ROUND((MAX(C.WAIT_UTIL_RATE)),2) AS WAIT_UTIL_RATE                                       
        FROM TB_INSTANCE_INFO A
          , TB_RSC_COLLECT_INFO B
          , TB_CPU_STAT_MASTER C
        WHERE A.COLLECT_YN = 'Y'
          AND A.DELETE_YN = 'N'     
          AND A.INSTANCE_ID = {0}
          AND B.REG_DATE = C.REG_DATE
          AND B.REG_DATE {1}   -- Dynamic('IN' or '=' )
	        AND C.COLLECT_DT BETWEEN '{2}' AND '{3}'
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND C.RSC_REG_SEQ = B.RSC_REG_SEQ
          GROUP BY COLLECT_DATE, A.INSTANCE_ID
          ORDER BY COLLECT_DATE, A.INSTANCE_ID;
      ]]>
        </DATA>
      </ROW>
      <ROW ID="SELECTREPORTCPUCHARTSTATS" PARAMS="5">
        <DESC>SELECTREPORTCPUCHARTSTATS</DESC>
        <DATA>
          <![CDATA[
        --Report (cpu info chart)         
        SELECT /* SELECTREPORTCPUCHARTSTATS */ 
	        MAX(A.INSTANCE_ID) INSTANCE_ID
	        --, to_char(COLLECT_DT, 'YYYY-MM-DD HH24:MI')::timestamp COLLECT_DT
          , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM C.COLLECT_DT) / {5} )) * {5}) AT TIME ZONE 'UTC' AS COLLECT_DATE
          , CASE WHEN max(C.USER_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE + C.NICE_UTIL_RATE) > 100 THEN 100.00 ELSE ROUND((max(C.USER_UTIL_RATE + C.SYS_UTIL_RATE + C.WAIT_UTIL_RATE + C.NICE_UTIL_RATE)),2) END AS USED_UTIL_RATE
          , ROUND((max(C.WAIT_UTIL_RATE)),2) AS WAIT_UTIL_RATE
          , CASE WHEN MAX(E.MEM_TOTAL_KB) != 0 THEN (MAX((E.MEM_TOTAL_KB - (E.MEM_FREE_KB +E.MEM_BUFFERED_KB + E.MEM_CACHED_KB)) / E.MEM_TOTAL_KB ) * 100)::int ELSE MAX(E.MEM_TOTAL_KB) END AS MEM_USED_RATE
          , CASE WHEN MAX(E.SWP_TOTAL_KB) != 0 THEN (MAX((E.SWP_TOTAL_KB - (E.SWP_FREE_KB + E.SWP_CACHED_KB)) / (CASE WHEN E.SWP_TOTAL_KB = 0 THEN 1 ELSE E.SWP_TOTAL_KB END)) * 100)::int ELSE MAX(E.SWP_TOTAL_KB) END AS SWP_USED_RATE
        FROM (SELECT INSTANCE_ID FROM TB_INSTANCE_INFO  WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N' AND INSTANCE_ID = {0} ) A
             LEFT OUTER JOIN TB_RSC_COLLECT_INFO B
               ON A.INSTANCE_ID = B.INSTANCE_ID
                  AND B.REG_DATE BETWEEN '{1}' AND '{2}'
              AND (B.REG_DATE || ' ' || B.REG_TIME) BETWEEN '{3}' AND '{4}'
        	 LEFT OUTER JOIN TB_CPU_STAT_MASTER C
          	   ON B.REG_DATE = C.REG_DATE
         	  AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
        	 LEFT OUTER JOIN TB_MEMORY_STAT E
          	   ON B.REG_DATE = E.REG_DATE
         	  AND B.RSC_REG_SEQ = E.RSC_REG_SEQ
       WHERE C.RSC_REG_SEQ = B.RSC_REG_SEQ
       GROUP BY COLLECT_DATE
       ORDER BY INSTANCE_ID, COLLECT_DATE ASC;
      ]]>
        </DATA>
      </ROW>
      <ROW ID="SELECTREPORTDISK" PARAMS="4">
        <DESC>SELECTREPORTDISK</DESC>
        <DATA>
          <![CDATA[    
            SELECT /* SELECTREPORTDISK */ 
	            A.INSTANCE_ID
              , C.DISK_NAME           --PT_06_04(Report disk info:DISK_NAME)
            FROM TB_INSTANCE_INFO A
              , TB_RSC_COLLECT_INFO B
              , TB_DISK_IO C
            WHERE A.INSTANCE_ID =  {0}
              AND ((B.REG_DATE = '{1}' AND C.COLLECT_DT BETWEEN '{2}' AND '{2}'::timestamp + interval '6 minutes' )
                    OR (B.REG_DATE = '{3}' AND C.COLLECT_DT BETWEEN '{4}'::timestamp - interval '6 minutes' AND '{4}'))
              AND A.COLLECT_YN = 'Y'
              AND A.DELETE_YN = 'N'
              AND A.INSTANCE_ID = B.INSTANCE_ID
              AND B.REG_DATE = C.REG_DATE
              AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
            GROUP BY A.INSTANCE_ID, C.DISK_NAME;      
      ]]>
        </DATA>
      </ROW>
      <ROW ID="SELECTREPORTDISKSTATS" PARAMS="4">
        <DESC>SELECTREPORTDISKSTATS</DESC>
        <DATA>
          <![CDATA[    
                SELECT /* SELECTREPORTDISKSTATS */ 
	                A.INSTANCE_ID
                  , C.DISK_NAME           --PT_06_04(Report disk info:DISK_NAME)
                FROM TB_INSTANCE_INFO A
                  , TB_RSC_COLLECT_INFO B
                  , TB_DISK_IO C
                WHERE A.INSTANCE_ID =  {0}
                  AND ((B.REG_DATE = '{1}' AND C.COLLECT_DT BETWEEN '{2}' AND '{2}'::timestamp + interval '6 minutes' )
                        OR (B.REG_DATE = '{3}' AND C.COLLECT_DT BETWEEN '{4}'::timestamp - interval '6 minutes' AND '{4}'))
                  AND A.COLLECT_YN = 'Y'
                  AND A.DELETE_YN = 'N'
                  AND A.INSTANCE_ID = B.INSTANCE_ID
                  AND B.REG_DATE = C.REG_DATE
                  AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
                GROUP BY A.INSTANCE_ID, C.DISK_NAME;      
          ]]>
        </DATA>
      </ROW>
      <ROW ID="SELECTREPORTDISKCHART" PARAMS="5">
        <DESC>SELECTREPORTCPUCHART</DESC>
        <DATA>
          <![CDATA[
         --Report (disk info chart)
          SELECT /* SELECTREPORTDISKCHART */ A.INSTANCE_ID
            , C.COLLECT_DT AS COLLECT_DT
            , C.DISK_NAME                                           --PT_06_04(Report disk info:DISK_NAME)
            , ROUND(C.READ_BUSY_RATE,2) AS READ_BUSY_RATE           --PT_06_04(Report disk info:READ_BUSY_RATE)
            , ROUND(C.WRITE_BUSY_RATE,2) AS WRITE_BUSY_RATE         --PT_06_04(Report disk info:WRITE_BUSY_RATE)
            , ROUND(C.CURRENT_READ_KB / DELTA_TIME,2) AS READ_KB_PER_SEC            --PT_04_03_001(DISK IO READ_KB)
            , ROUND(C.CURRENT_WRITE_KB / DELTA_TIME,2) AS WRITE_KB_PER_SEC          --PT_04_03_001(DISK IO WRITE_KB)
            , A.CONN_NAME AS CONN_NAME
          FROM TB_INSTANCE_INFO A
            , TB_RSC_COLLECT_INFO B
            , TB_DISK_IO C
          WHERE A.INSTANCE_ID = {0}
            AND B.REG_DATE {1}   -- Dynamic('IN' or '=' )
            AND C.COLLECT_DT BETWEEN  '{2}' AND '{3}'
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
            AND A.INSTANCE_ID = B.INSTANCE_ID
            AND C.DISK_NAME = '{4}'
            AND B.REG_DATE = C.REG_DATE
            AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
          ORDER BY A.INSTANCE_ID, B.RSC_REG_SEQ DESC
      ]]>
        </DATA>
      </ROW>
  <ROW ID="SELECTREPORTDISKCHARTSTATS" PARAMS="6">
    <DESC>SELECTREPORTDISKCHARTSTATS</DESC>
    <DATA>
      <![CDATA[
         --Report (disk info chart)
          SELECT /* SELECTREPORTDISKCHARTSTATS */ MAX(A.INSTANCE_ID) INSTANCE_ID
            --, C.COLLECT_DT AS COLLECT_DT
            , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {5} )) * {5}) AT TIME ZONE 'UTC' AS COLLECT_DATE
            , C.DISK_NAME                                           --PT_06_04(Report disk info:DISK_NAME)
            , ROUND(MAX(C.READ_BUSY_RATE),2) AS READ_BUSY_RATE           --PT_06_04(Report disk info:READ_BUSY_RATE)
            , ROUND(MAX(C.WRITE_BUSY_RATE),2) AS WRITE_BUSY_RATE         --PT_06_04(Report disk info:WRITE_BUSY_RATE)
            , ROUND(AVG(C.CURRENT_READ_KB / DELTA_TIME),2) AS READ_KB_PER_SEC            --PT_04_03_001(DISK IO READ_KB)
            , ROUND(AVG(C.CURRENT_WRITE_KB / DELTA_TIME),2) AS WRITE_KB_PER_SEC          --PT_04_03_001(DISK IO WRITE_KB)
            , A.CONN_NAME AS CONN_NAME
          FROM TB_INSTANCE_INFO A
            , TB_RSC_COLLECT_INFO B
            , TB_DISK_IO C
          WHERE A.INSTANCE_ID = {0}
            AND B.REG_DATE {1}   -- Dynamic('IN' or '=' )
            AND C.COLLECT_DT BETWEEN  '{2}' AND '{3}'
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
            AND A.INSTANCE_ID = B.INSTANCE_ID
            AND C.DISK_NAME = '{4}'
            AND B.REG_DATE = C.REG_DATE
            AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
          GROUP BY COLLECT_DATE, C.DISK_NAME, A.CONN_NAME
          ORDER BY INSTANCE_ID, COLLECT_DATE
      ]]>
    </DATA>
  </ROW>
    <ROW ID="SELECTREPORTDISKUSAGECHARTSTATS" PARAMS="6">
    <DESC>SELECTREPORTDISKUSAGECHARTSTATS</DESC>
    <DATA>
      <![CDATA[
         --Report (disk info chart)
           SELECT /* SELECTREPORTDISKCHARTSTATS */ 
            --, C.COLLECT_DT AS COLLECT_DT
            TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {5} )) * {5}) AT TIME ZONE 'UTC' AS COLLECT_DATE
            , C.mount_point_dir AS MOUNTPOINT
            --, ROUND(MAX(C.total_kb),2) AS TOTAL
            --, ROUND(MAX(C.used_kb),2) AS USED
            , ROUND(MAX(C.used_kb) / MAX(C.total_kb),3) * 100 AS USAGE
          FROM TB_RSC_COLLECT_INFO B
            , TB_DISK_usage C
          WHERE B.INSTANCE_ID = {0}
            AND B.REG_DATE BETWEEN '{1}' AND '{2}'
            AND (B.REG_DATE || ' ' || B.REG_TIME) BETWEEN '{3}' AND '{4}'
            AND B.REG_DATE = C.REG_DATE
            AND B.RSC_REG_SEQ = C.RSC_REG_SEQ
          GROUP BY COLLECT_DATE, C.mount_point_dir
          ORDER BY COLLECT_DATE
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTREPORTTBACCESS" PARAMS="4">
    <DESC>SELECTREPORTTBACCESS</DESC>
    <DATA>
      <![CDATA[
           SELECT /* SELECTTBACESINFO */ 
	             A.INSTANCE_ID
               , C.COLLECT_DT AS COLLECT_DT
               ,  CASE WHEN {4}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
               , C.DB_NAME AS DB_NAME --PT_05_03_001(DB INFO : DB) 
               -- BUFFER HIT1 ST 
               , ROUND((C.CURRENT_HEAP_BLKS_READ_KB),2) AS "DISK_READ_KB" --PT_05_03_001(DB INFO : DISK READ(KB)) 
               , ROUND((C.CURRENT_HEAP_BLKS_HIT_KB),2) AS "BUFFER_READ_KB" --PT_05_03_001(DB INFO : BUFFER READ(KB)) 
               -- BUFFER HIT1 ED
               -- BUFFER HIT2 ST
               --, ROUND((C.BUFFER_HIT_RATIO),4) AS "HIT_RATIO" --PT_05_03_001(DB INFO : HIT RATIO) 
               , ROUND( C.current_heap_blks_hit_kb::numeric / (case when ((C.current_heap_blks_hit_kb)+(C.current_heap_blks_read_kb)) = 0 then 1 else ((C.current_heap_blks_hit_kb)+(C.current_heap_blks_read_kb)) end),4)*100 AS "HIT_RATIO" --PT_05_03_001(DB INFO : HIT RATIO)  
               -- BUFFER HIT2 ST
               -- Logical IO ST
               , ROUND((C.CURRENT_INSERT_TUPLES), 2) AS INSERT_TUPLES_PER_SEC --PT_04_09_001(Object : INSERT_TUPLES)
               , ROUND((C.CURRENT_UPDATE_TUPLES), 2) AS UPDATE_TUPLES_PER_SEC --PT_04_09_001(Object : UPDATE_TUPLES)
               , ROUND((C.CURRENT_DELETE_TUPLES), 2) AS DELETE_TUPLES_PER_SEC --PT_04_09_001(Object : DELETE_TUPLES)
               , ROUND(((C.CURRENT_SEQ_READ_TUPLES) + (C.CURRENT_IDX_FETCH_TUPLES) - (C.CURRENT_UPDATE_TUPLES) - (C.CURRENT_DELETE_TUPLES)) , 2) AS SELECT_TUPLES_PER_SEC --PT_04_09_001(Object : READ_TUPLES)
               -- Logical IO ED
               -- Object TUPLE ST
               , ROUND((C.current_seq_read_tuples)::numeric, 2) AS SEQ_TUPLES --PT_06_06(TABLE ACCESS INFO : SEQ_TUPLES COUNT)
               , ROUND((C.current_idx_fetch_tuples)::numeric, 2) AS INDEX_TUPLES --PT_06_06(TABLE ACCESS INFO : INDEX_TUPLES COUNT) 
               -- Object TUPLE ED
               -- Object RATE ST
               , ROUND((C.current_seq_read_tuples)::numeric / (case when ((C.current_seq_read_tuples)+(C.current_idx_fetch_tuples)) = 0 then 1 else ((C.current_seq_read_tuples)+(C.current_idx_fetch_tuples)) end)*100 ,2) AS SEQ_SCAN --PT_06_06(TABLE ACCESS INFO : SEQ_SCAN COUNT)
               , ROUND((C.current_idx_fetch_tuples)::numeric / (case when ((C.current_seq_read_tuples)+(C.current_idx_fetch_tuples)) = 0 then 1 else ((C.current_seq_read_tuples)+(C.current_idx_fetch_tuples)) end)*100 ,2) AS INDEX_SCAN --PT_06_06(TABLE ACCESS INFO : INDEX_SCAN COUNT) 
               -- Object RATE ED
           FROM TB_INSTANCE_INFO A
               , TB_ACTV_COLLECT_INFO B
               , TB_ACCESS_INFO C
           WHERE A.INSTANCE_ID =  {0}
           AND B.REG_DATE {1}  -- Dynamic('IN' or '=' )
           AND C.COLLECT_DT  BETWEEN '{2}' AND '{3}'
           AND A.INSTANCE_ID = B.INSTANCE_ID
           AND B.REG_DATE = C.REG_DATE
           AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
           AND A.COLLECT_YN = 'Y'
           AND A.DELETE_YN = 'N'
           --AND C.current_seq_scan_cnt > 0 /* 순차탐색이 1건 이상인것만 */ 
           --AND C.current_seq_tuples > 0 /* 순차탐색튜플이 1건 이상인것만 */
           --AND C.current_index_tuples > 0 /* 인덱스탐색튜플이 1건 이상인것만 */
           --ORDER BY A.INSTANCE_ID, A.HOST_NAME, C.DB_NAME, C.COLLECT_DT ;
        ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTREPORTTBACCESSSTATS" PARAMS="5">
    <DESC>SELECTREPORTTBACCESSSTATS</DESC>
    <DATA>
      <![CDATA[
           SELECT /* SELECTREPORTTBACCESSSTATS */
		             STATS.instance_id AS instance_id 
	               , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {5} )) * {5}) AT TIME ZONE 'UTC' AS COLLECT_DATE
	               , MAX(HOST_NAME) AS HOST_NAME
	               , MAX(DB_NAME) AS DB_NAME 
	               , AVG(DISK_READ_KB) AS DISK_READ_KB 
	               , AVG(BUFFER_READ_KB) AS BUFFER_READ_KB
	               , AVG(HIT_RATIO) HIT_RATIO   
	               , AVG(INSERT_TUPLES_PER_SEC) AS INSERT_TUPLES_PER_SEC
	               , AVG(UPDATE_TUPLES_PER_SEC) AS UPDATE_TUPLES_PER_SEC
	               , AVG(DELETE_TUPLES_PER_SEC) AS DELETE_TUPLES_PER_SEC
	               , AVG(SELECT_TUPLES_PER_SEC) AS SELECT_TUPLES_PER_SEC
	               , AVG(SEQ_TUPLES) AS SEQ_TUPLES
	               , AVG(INDEX_TUPLES) AS INDEX_TUPLES 
	               , AVG(SEQ_SCAN) AS SEQ_SCAN
	               , AVG(INDEX_SCAN) AS INDEX_SCAN   
                 , AVG(PHY_READ_PER_SEC) AS PHY_READ_PER_SEC 
	         FROM (
		         	 SELECT A.INSTANCE_ID
			               	, C.COLLECT_DT AS COLLECT_DT
			               	, CASE WHEN {4}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
			               	, C.DB_NAME AS DB_NAME --PT_05_03_001(DB INFO : DB) 
			               	, ROUND((C.CURRENT_HEAP_BLKS_READ_KB),2) AS DISK_READ_KB --PT_05_03_001(DB INFO : DISK READ(KB)) 
			               	, ROUND((C.CURRENT_HEAP_BLKS_HIT_KB),2) AS BUFFER_READ_KB --PT_05_03_001(DB INFO : BUFFER READ(KB)) 
			               	, ROUND( C.CURRENT_HEAP_BLKS_HIT_KB::NUMERIC / (CASE WHEN ((C.CURRENT_HEAP_BLKS_HIT_KB)+(C.CURRENT_HEAP_BLKS_READ_KB)) = 0 THEN 1 ELSE ((C.CURRENT_HEAP_BLKS_HIT_KB)+(C.CURRENT_HEAP_BLKS_READ_KB)) END),4)*100 AS HIT_RATIO --PT_05_03_001(DB INFO : HIT RATIO)  
			               	, ROUND((C.CURRENT_INSERT_TUPLES), 2) AS INSERT_TUPLES_PER_SEC --PT_04_09_001(Object : INSERT_TUPLES)
			               	, ROUND((C.CURRENT_UPDATE_TUPLES), 2) AS UPDATE_TUPLES_PER_SEC --PT_04_09_001(Object : UPDATE_TUPLES)
			               	, ROUND((C.CURRENT_DELETE_TUPLES), 2) AS DELETE_TUPLES_PER_SEC --PT_04_09_001(Object : DELETE_TUPLES)
			               	, ROUND(((C.CURRENT_SEQ_READ_TUPLES) + (C.CURRENT_IDX_FETCH_TUPLES) - (C.CURRENT_UPDATE_TUPLES) - (C.CURRENT_DELETE_TUPLES)) , 2) AS SELECT_TUPLES_PER_SEC --PT_04_09_001(Object : READ_TUPLES)
			               	, ROUND((C.CURRENT_SEQ_READ_TUPLES)::NUMERIC, 2) AS SEQ_TUPLES --PT_06_06(TABLE ACCESS INFO : SEQ_TUPLES COUNT)
			               	, ROUND((C.CURRENT_IDX_FETCH_TUPLES)::NUMERIC, 2) AS INDEX_TUPLES --PT_06_06(TABLE ACCESS INFO : INDEX_TUPLES COUNT) 
			               	, ROUND((C.CURRENT_SEQ_READ_TUPLES)::NUMERIC / (CASE WHEN ((C.CURRENT_SEQ_READ_TUPLES)+(C.CURRENT_IDX_FETCH_TUPLES)) = 0 THEN 1 ELSE ((C.CURRENT_SEQ_READ_TUPLES)+(C.CURRENT_IDX_FETCH_TUPLES)) END)*100 ,2) AS SEQ_SCAN --PT_06_06(TABLE ACCESS INFO : SEQ_SCAN COUNT)
			               	, ROUND((C.CURRENT_IDX_FETCH_TUPLES)::NUMERIC / (CASE WHEN ((C.CURRENT_SEQ_READ_TUPLES)+(C.CURRENT_IDX_FETCH_TUPLES)) = 0 THEN 1 ELSE ((C.CURRENT_SEQ_READ_TUPLES)+(C.CURRENT_IDX_FETCH_TUPLES)) END)*100 ,2) AS INDEX_SCAN --PT_06_06(TABLE ACCESS INFO : INDEX_SCAN COUNT) 
                      , ROUND((C.CURRENT_PHY_READ)::NUMERIC, 2) AS PHY_READ_PER_SEC
			           FROM TB_INSTANCE_INFO A
			               , TB_ACTV_COLLECT_INFO B
			               , TB_ACCESS_INFO C
			           WHERE A.INSTANCE_ID =  {0}
			           AND B.REG_DATE {1}  -- Dynamic('IN' or '=' )
			           AND C.COLLECT_DT  BETWEEN '{2}' AND '{3}'
			           AND A.INSTANCE_ID = B.INSTANCE_ID
			           AND B.REG_DATE = C.REG_DATE
			           AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
			           AND A.COLLECT_YN = 'Y'
			           AND A.DELETE_YN = 'N'
			           ORDER BY DB_NAME
		           ) STATS
        	GROUP BY instance_id, DB_NAME, COLLECT_DATE
        ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTREPORTSESSIONCHART" PARAMS="4">
    <DESC>SELECTREPORTSESSIONCHART</DESC>
    <DATA>
      <![CDATA[
        --Report (session info chart)
         SELECT /* SELECTREPORTSESSIONCHART */ 
             MAX(IST.INSTANCE_ID)
           , MAX(BAK.COLLECT_DT) AS COLLECT_DT
           , BAK.ACTV_REG_SEQ 
           --, MAX(IST.MAX_CONN_CNT)
           --, SUM(CASE WHEN (BAK.SQL <> '<IDLE>' AND BAK.SQL <> '<IDLE> in transaction') THEN 1 ELSE 0 END) AS CUR_ACTV_BACKEND_CNT 
           --, SUM(CASE WHEN (BAK.SQL = '<IDLE>') THEN 1 ELSE 0 END) AS IDLE_BACKEND_CNT 
           --, SUM(CASE WHEN (BAK.SQL = '<IDLE> in transaction') THEN 1 ELSE 0 END) AS IDLE_IN_TRC_BACKEND_CNT 
           , SUM(CASE WHEN (BAK.STATE = 'active') THEN 1 ELSE 0 END) AS CUR_ACTV_BACKEND_CNT 
           , SUM(CASE WHEN (BAK.STATE = 'idle') THEN 1 ELSE 0 END) AS IDLE_BACKEND_CNT 
           , SUM(CASE WHEN (BAK.STATE = 'idle in transaction') THEN 1 WHEN (BAK.STATE = 'idle in transaction (aborted)') THEN 1 ELSE 0 END) AS IDLE_IN_TRC_BACKEND_CNT 
           , DB_NAME 
         FROM TB_INSTANCE_INFO IST
           , TB_BACKEND_RSC BAK
           , TB_ACTV_COLLECT_INFO ACT
         WHERE IST.INSTANCE_ID =  {0}
        AND BAK.REG_DATE {1}  -- Dynamic('IN' or '=' )
        AND BAK.COLLECT_DT BETWEEN '{2}' AND '{3}'
         AND BAK.REG_DATE = ACT.REG_DATE
         AND ACT.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ
         AND IST.COLLECT_YN = 'Y'
         AND IST.DELETE_YN = 'N'
         AND IST.INSTANCE_ID = ACT.INSTANCE_ID
         GROUP BY BAK.ACTV_REG_SEQ , DB_NAME ;
        ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTREPORTSESSIONCHARTSTATS" PARAMS="5">
    <DESC>SELECTREPORTSESSIONCHARTSTATS</DESC>
    <DATA>
      <![CDATA[
              --Report (session info chart)
              SELECT /*SELECTREPORTSESSIONCHARTSTATS*/
                      MAX(INSTANCE_ID) AS INSTANCE_ID
                    , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {4} )) * {4}) AT TIME ZONE 'UTC' AS COLLECT_DATE
                    , MAX(CUR_ACTV_BACKEND_CNT) AS CUR_ACTV_BACKEND_CNT
                    , MAX(IDLE_BACKEND_CNT) AS IDLE_BACKEND_CNT
                    , MAX(IDLE_IN_TRC_BACKEND_CNT) AS IDLE_IN_TRC_BACKEND_CNT
                    , MAX(DB_NAME) AS DB_NAME
              FROM (SELECT  MAX(IST.INSTANCE_ID) AS INSTANCE_ID
                            , MAX(BAK.COLLECT_DT) AS COLLECT_DT
                            , BAK.ACTV_REG_SEQ
                            , SUM(CASE WHEN (BAK.STATE = 'active') THEN 1 ELSE 0 END) AS CUR_ACTV_BACKEND_CNT
                            , SUM(CASE WHEN (BAK.STATE = 'idle') THEN 1 ELSE 0 END) AS IDLE_BACKEND_CNT
                            , SUM(CASE WHEN (BAK.STATE = 'idle in transaction') THEN 1 WHEN (BAK.STATE = 'idle in transaction (aborted)') THEN 1 ELSE 0 END) AS IDLE_IN_TRC_BACKEND_CNT
                            , DB_NAME
                      FROM TB_INSTANCE_INFO IST
                            , TB_BACKEND_RSC BAK
                            , TB_ACTV_COLLECT_INFO ACT
                     WHERE IST.INSTANCE_ID =  {0}
                       AND BAK.REG_DATE {1}  -- Dynamic('IN' or '=' )
                       AND BAK.COLLECT_DT BETWEEN '{2}' AND '{3}'
                       AND BAK.REG_DATE = ACT.REG_DATE
                       AND ACT.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ
                       AND IST.COLLECT_YN = 'Y'
                       AND IST.DELETE_YN = 'N'
                       AND IST.INSTANCE_ID = ACT.INSTANCE_ID
                     GROUP BY BAK.ACTV_REG_SEQ , DB_NAME
                    ) BYSEQ
              GROUP BY DB_NAME, COLLECT_DATE
              ORDER BY DB_NAME, COLLECT_DATE
          ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTREPORTSQL" PARAMS="4">
    <DESC>SELECTREPORTSQL</DESC>
    <DATA>
      <![CDATA[
			SELECT 
          S.DB_NAME
				--, MAX(MAX_CPU_USAGE) AS MAX_CPU_USAGE
				--, SUM(MAX_ELAPSED_TIME) AS ELAPSED_TIME
        , (CASE WHEN SUM(MAX_ELAPSED_TIME) <= 1 THEN 1 ELSE SUM(MAX_ELAPSED_TIME) END) AS ELAPSED_TIME
				, SUM(OCCUPIED_TIME) OCCUPIED_TIME
				, S.SQL 
        , COUNT(S.SQL) SQL_COUNT
        , S.USER_NAME
			FROM(
					SELECT
				      --A.INSTANCE_ID
				      E.DB_NAME                                            --PT_06_07(Report (sql info): DB)     
				      , ROUND(SUM(E.CURRENT_PROC_UTIME + E.CURRENT_PROC_STIME)/100, 2) OCCUPIED_TIME
				      , MAX(E.CLIENT_ADDR) AS CLIENT_ADDR
				      , MAX(E.USER_NAME) AS USER_NAME
				      , MAX(E.COLLECT_DT) AS COLLECT_DT		      
				      , TRUNC(MAX(E.PROC_CPU_UTIL) / 100, 4) AS MAX_CPU_USAGE   --PT_06_07(Report (sql info): MAX_CPU_USAGE
				      , E.QUERY_START 
				      , ROUND(CASE WHEN MAX(E.ELAPSED_TIME) < 0  THEN 0 ELSE MAX(E.ELAPSED_TIME) END,2) AS MAX_ELAPSED_TIME  --PT_06_07(Report (sql info): MAX_ELAPSED_TIME)
				      , MAX(E.SQL) AS SQL                                      --PT_06_07(Report (sql info):  SQL
          FROM TB_INSTANCE_INFO A
              , TB_ACTV_COLLECT_INFO B
              , TB_BACKEND_RSC E
              WHERE A.INSTANCE_ID = {0}
              AND B.REG_DATE {1}  -- Dynamic('IN' or '=' )
              AND E.COLLECT_DT BETWEEN '{2}' AND '{3}'
              AND B.REG_DATE = E.REG_DATE
              AND A.INSTANCE_ID = B.INSTANCE_ID
              AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ
              AND A.COLLECT_YN = 'Y' 
              AND A.DELETE_YN = 'N'
              AND E.ELAPSED_TIME >  0
              AND E.PROC_CPU_UTIL > 0
              AND E.SQL != 'BACKGROUND PROC'
              AND E.SQL != 'COMMIT'
              --AND E.SQL NOT LIKE 'SELECT /* EXPERDBMA%'  
             GROUP BY E.DB_NAME, E.QUERY_START, E.PROCESS_ID ORDER BY MAX_CPU_USAGE DESC) S
			GROUP BY S.DB_NAME, S.SQL, S.USER_NAME
			ORDER BY ELAPSED_TIME DESC
        ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTREPORTSQLEXT" PARAMS="4">
    <DESC>SELECTREPORTSQL</DESC>
    <DATA>
      <![CDATA[
			SELECT 
          S.DB_NAME
				--, MAX(MAX_CPU_USAGE) AS MAX_CPU_USAGE
				--, SUM(MAX_ELAPSED_TIME) AS ELAPSED_TIME
        , (CASE WHEN SUM(MAX_ELAPSED_TIME) <= 1 THEN 1 ELSE SUM(MAX_ELAPSED_TIME) END) AS ELAPSED_TIME
				, SUM(OCCUPIED_TIME) OCCUPIED_TIME
        --, S.SQL 
				--, CASE WHEN (S.SQL = '') THEN Q.QUERY ELSE S.SQL END AS SQL  -- 1005
        --, MAX(Q.QUERY) AS SQL
        , COALESCE(MAX(Q.QUERY),MAX(S.SQL)) AS SQL
        , COUNT(S.SQL) SQL_COUNT
        , S.USER_NAME
			FROM(
					SELECT
				      A.INSTANCE_ID
				      , E.DB_NAME                                            --PT_06_07(Report (sql info): DB)     
				      , ROUND(SUM(E.CURRENT_PROC_UTIME + E.CURRENT_PROC_STIME)/100, 2) OCCUPIED_TIME
				      , MAX(E.CLIENT_ADDR) AS CLIENT_ADDR
				      , MAX(E.USER_NAME) AS USER_NAME
				      , MAX(E.COLLECT_DT) AS COLLECT_DT		      
				      , TRUNC(MAX(E.PROC_CPU_UTIL) / 100, 4) AS MAX_CPU_USAGE   --PT_06_07(Report (sql info): MAX_CPU_USAGE
				      , E.QUERY_START 
				      , ROUND(CASE WHEN MAX(E.ELAPSED_TIME) < 0  THEN 0 ELSE MAX(E.ELAPSED_TIME) END,2) AS MAX_ELAPSED_TIME  --PT_06_07(Report (sql info): MAX_ELAPSED_TIME)
				      , MAX(E.SQL) AS SQL                                      --PT_06_07(Report (sql info):  SQL
				      --, MAX(E.QUERYID) AS QUERYID -- 1005
              , E.QUERYID AS QUERYID
              , MAX(E.REG_DATE) AS REG_DATE
          FROM TB_INSTANCE_INFO A
              , TB_ACTV_COLLECT_INFO B
              , TB_BACKEND_RSC E
              WHERE A.INSTANCE_ID = {0}
              AND B.REG_DATE {1}  -- Dynamic('IN' or '=' )
              AND to_date_imm(B.REG_DATE, 'yyyymmdd') + B.REG_TIME BETWEEN '{2}' AND '{3}'
              --AND E.COLLECT_DT BETWEEN '{2}' AND '{3}'
              AND B.REG_DATE = E.REG_DATE
              AND A.INSTANCE_ID = B.INSTANCE_ID
              AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ
              AND A.COLLECT_YN = 'Y' 
              AND A.DELETE_YN = 'N'
              AND E.ELAPSED_TIME >  0
              AND E.PROC_CPU_UTIL > 0
              AND E.SQL != 'BACKGROUND PROC'
              AND E.SQL != 'COMMIT'
              --AND E.SQL NOT LIKE 'SELECT /* EXPERDBMA%'  
             -- GROUP BY E.DB_NAME, E.QUERY_START, E.PROCESS_ID ORDER BY MAX_CPU_USAGE DESC) S -- 1005
             GROUP BY A.INSTANCE_ID, E.DB_NAME, E.QUERY_START, E.PROCESS_ID, E.QUERYID ORDER BY MAX_CPU_USAGE DESC) S
          LEFT OUTER JOIN TB_QUERY_INFO Q ON S.REG_DATE = Q.REG_DATE AND S.INSTANCE_ID = Q.INSTANCE_ID AND S.QUERYID = Q.QUERYID
          WHERE Q.REG_DATE {1}
			-- GROUP BY S.DB_NAME, S.SQL, Q.QUERY, S.USER_NAME -- 1005
			-- GROUP BY S.DB_NAME, S.SQL, S.USER_NAME
      			GROUP BY S.DB_NAME, S.QUERYID, S.USER_NAME
			ORDER BY ELAPSED_TIME DESC
        ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTREPORTSQL_ORG" PARAMS="4">
    <DESC>SELECTREPORTSQL_ORG</DESC>
    <DATA>
      <![CDATA[
    
    SELECT  
		      A.INSTANCE_ID
		      , E.DB_NAME                                            --PT_06_07(Report (sql info): DB)     
		      , MAX(E.CLIENT_ADDR) AS CLIENT_ADDR
		      , MAX(E.USER_NAME) AS USER_NAME
		      , MAX(E.COLLECT_DT) AS COLLECT_DT
		      , ROUND(MAX(E.PROC_CPU_UTIL) / 100 /100,4) AS MAX_CPU_USAGE   --PT_06_07(Report (sql info): MAX_CPU_USAGE
		      --, ROUND(AVG(E.PROC_CPU_UTIL) / 100 /100,4) AS AVG_CPU_USAGE   --PT_06_07(Report (sql info): AVG_CPU_USAGE)
		      , E.QUERY_START 
		      , ROUND(CASE WHEN MAX(E.ELAPSED_TIME) < 0  THEN 0 ELSE MAX(E.ELAPSED_TIME) END,6) AS MAX_ELAPSED_TIME  --PT_06_07(Report (sql info): MAX_ELAPSED_TIME)
		      --, ROUND(CASE WHEN AVG(E.ELAPSED_TIME) < 0  THEN 0 ELSE AVG(E.ELAPSED_TIME) END,6) AS AVG_ELAPSED_TIME  --PT_06_07(Report (sql info): AVG_ELAPSED_TIME)
		      , MAX(E.SQL) AS SQL                                      --PT_06_07(Report (sql info):  SQL
             FROM TB_INSTANCE_INFO A
               , TB_ACTV_COLLECT_INFO B
               , TB_BACKEND_RSC E
              WHERE A.INSTANCE_ID = {0}
              AND B.REG_DATE {1}  -- Dynamic('IN' or '=' )
              AND E.COLLECT_DT BETWEEN '{2}' AND '{3}'
              AND B.REG_DATE = E.REG_DATE
              AND A.INSTANCE_ID = B.INSTANCE_ID
              AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ
              AND A.COLLECT_YN = 'Y' 
              AND A.DELETE_YN = 'N'
              AND E.ELAPSED_TIME >  0
              AND E.PROC_CPU_UTIL > 0
              AND E.SQL != 'BACKGROUND PROC'
              AND E.SQL != 'COMMIT'
              --AND E.SQL NOT LIKE 'SELECT /* EXPERDBMA%'           
              GROUP BY A.INSTANCE_ID, E.DB_NAME, MD5(E.SQL), E.QUERY_START
        ]]>
    </DATA>
  </ROW>


  <ROW ID="SELECTINIFIXEDTHRESHOLD" PARAMS="0">
    <DESC>헬스체크 고정값 가져오기</DESC>
    <DATA>
      <![CDATA[
            SELECT HCHK_NAME, FIXED_THRESHOLD, (SELECT HCHK_PERIOD_SEC FROM TB_CONFIG) HCHK_PERIOD_SEC
            FROM TB_HCHK_THRD_LIST 
            WHERE INSTANCE_ID = -1
            --AND HCHK_NAME IN ('UNUSEDINDEX','TRAXIDLECNT','LOCKCNT','CONNECTIONFAIL','LASTANALYZE','LASTVACUUM','LONGRUNSQL')
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="BUFFERHITRATIO" PARAMS="3">
  <DESC>HEALTH CHECK BUFFER HIT RATIO</DESC>
  <DATA>
    <![CDATA[
           SELECT DB_NAME,
                 DB_SIZE_KB,
                 TABLE_CNT,
                 INDEX_CNT,
                 ROUND(BUFFER_HIT_RATIO/100, 2) AS BUFFER_HIT_RATIO,
                 COLLECT_DT 
            FROM TB_ACCESS_INFO 
           WHERE REG_DATE='{1}'
		     AND ACTV_REG_SEQ = {2}
    ]]>
  </DATA>
  <COMMENTS />
  </ROW>
  <ROW ID="ACTIVECONNECTION" PARAMS="2">
    <DESC>HEALTH CHECK ACTIVE CONNECTION</DESC>
    <DATA>
      <![CDATA[
         SELECT DB_NAME,
                 IDLE_CNT + ACTIVE_CNT AS BACKEND,
                 IDLE_CNT / MAX_CONN_CNT  AS IDLE_RATE,
                 ACTIVE_CNT / MAX_CONN_CNT  AS ACTIVE_RATE,
                 (IDLE_CNT + ACTIVE_CNT) / MAX_CONN_CNT  AS TOTAL_RATE,
                 COLLECT_DT
          FROM (         
            SELECT DB_NAME,
                      SUM(CASE WHEN SQL     LIKE '%IDLE%' THEN 1 ELSE 0 END) AS IDLE_CNT,
                      SUM(CASE WHEN SQL NOT LIKE '%IDLE%' THEN 1 ELSE 0 END) AS ACTIVE_CNT,
                      SUM(1) AS TOTAL_CNT,
                      (SELECT MAX_CONN_CNT FROM TB_INSTANCE_INFO WHERE INSTANCE_ID=(SELECT INSTANCE_ID FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE='{0}' AND ACTV_REG_SEQ IN ({1}))) AS MAX_CONN_CNT,
                      MAX(COLLECT_DT) AS COLLECT_DT
              FROM TB_BACKEND_RSC 
             WHERE REG_DATE='{0}' 
                AND ACTV_REG_SEQ = {1}
             GROUP BY DB_NAME
         ) AS A;
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="COMMITRATIO" PARAMS="2">
    <DESC>HEALTH CHECK COMMIT RATIO</DESC>
    <DATA>
      <![CDATA[
        SELECT DB_NAME, 
          CURRENT_COMMIT+CURRENT_ROLLBACK AS CURRENT_TRANX, 
          CURRENT_COMMIT/(CURRENT_COMMIT+CURRENT_ROLLBACK) AS CURRENT_COMMIT_RATE,  
          CURRENT_ROLLBACK/(CURRENT_COMMIT+CURRENT_ROLLBACK) AS CURRENT_ROLLBACK_RATE, 
          AGG_COMMIT/(AGG_COMMIT+AGG_ROLLBACK) AS AGG_COMMIT_RATE, 
          COLLECT_DT 
        FROM TB_ACCESS_INFO 
        WHERE REG_DATE='{0}' 
          AND ACTV_REG_SEQ = {1};
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="CONNECTIONFAIL" PARAMS="5">
    <DESC>HEALTH CHECK CONNECTION FAIL</DESC>
    <DATA>
      <![CDATA[
        SELECT CASE WHEN IS_COLLECT_OK='Y' THEN 'OK' ELSE 'FAIL' END AS IS_OK, REG_TIME::TIME(0),  LAST_OK_DT, COLLECT_DT FROM (
       -- SELECT IS_COLLECT_OK, 
       --          REG_TIME,
       --          CASE WHEN IS_COLLECT_OK='N' THEN (SELECT REG_DATE::DATE||' '||REG_TIME AS LAST_OK_DT 
       --                                                            FROM TB_OBJT_COLLECT_INFO 
       --                                                          WHERE (REG_DATE = '{1}' AND OBJT_REG_SEQ < {2})  --(A,B,C) 중 A
       --                                                               OR REG_DATE < '{1}' 
       --                                                             AND IS_COLLECT_OK = 'Y' 
       --                                                          ORDER BY REG_DATE DESC, OBJT_REG_SEQ DESC LIMIT 1) ELSE '-' END AS LAST_OK_DT, reg_date::DATE + reg_time AS COLLECT_DT
       --  FROM TB_OBJT_COLLECT_INFO 
       -- WHERE REG_DATE='{1}'
       --    AND OBJT_REG_SEQ={2}
       --    AND INSTANCE_ID={0}
       -- UNION ALL
        SELECT IS_COLLECT_OK, 
                 REG_TIME,
                 CASE WHEN IS_COLLECT_OK='N' THEN (SELECT REG_DATE::DATE||' '||REG_TIME AS LAST_OK_DT 
                                                                   FROM TB_ACTV_COLLECT_INFO 
                                                                 WHERE (REG_DATE = '{1}' AND ACTV_REG_SEQ < {2} ) --(A,B,C) 중 B
                                                                      OR REG_DATE < '{1}' 
                                                                    AND IS_COLLECT_OK = 'Y' 
                                                                 ORDER BY REG_DATE DESC, ACTV_REG_SEQ DESC LIMIT 1) ELSE '-' END AS LAST_OK_DT, reg_date::DATE + reg_time AS COLLECT_DT
         FROM TB_ACTV_COLLECT_INFO 
        WHERE REG_DATE='{1}'
           AND ACTV_REG_SEQ={2} 
           AND INSTANCE_ID={0}
        UNION ALL
        SELECT IS_COLLECT_OK, 
                 REG_TIME,
                 CASE WHEN IS_COLLECT_OK='N' THEN (SELECT REG_DATE::DATE||' '||REG_TIME AS LAST_OK_DT 
                                                                   FROM TB_RSC_COLLECT_INFO 
                                                                  WHERE (REG_DATE = '{1}' AND RSC_REG_SEQ < {3}) --(A,B,C) 중 C
                                                                       OR REG_DATE < '{1}' 
                                                                     AND IS_COLLECT_OK = 'Y' 
                                                                  ORDER BY REG_DATE DESC, RSC_REG_SEQ DESC LIMIT 1) ELSE '-' END AS LAST_OK_DT, reg_date::DATE + reg_time AS COLLECT_DT
         FROM TB_RSC_COLLECT_INFO   
        WHERE REG_DATE='{1}' 
           AND RSC_REG_SEQ={3}
           AND INSTANCE_ID={0}) AS A
        ORDER BY IS_COLLECT_OK, REG_TIME DESC LIMIT 1;

    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="DISKUSAGE" PARAMS="2">
    <DESC>HEALTH CHECK Disk Usage</DESC>
    <DATA>
      <![CDATA[
        SELECT DEVICE_NAME,
               MOUNT_POINT_DIR,
	           CASE 
	               WHEN TOTAL_KB < 1024 THEN TOTAL_KB || ' KB'
	               WHEN TOTAL_KB < 1048576 THEN round(TOTAL_KB / 1024.0, 2) || ' MB'
	               WHEN TOTAL_KB < 1073741824 THEN round(TOTAL_KB / 1048576.0, 2) || ' GB'
	               ELSE round(TOTAL_KB / 1073741824.0, 4) || ' TB'
	           END AS TOTAL_KB,
	           CASE 
	               WHEN USED < 1024 THEN USED || ' KB'
	               WHEN USED < 1048576 THEN round(USED / 1024.0, 2) || ' MB'
	               WHEN USED < 1073741824 THEN round(USED / 1048576.0, 2) || ' GB'
	               ELSE round(USED / 1073741824.0, 4) || ' TB'
	           END AS USED,
               USED_RATE, 
               COLLECT_DT 
          FROM	(	
            SELECT DEVICE_NAME,
                     MOUNT_POINT_DIR,
                     TOTAL_KB,
                     TOTAL_KB - AVAIL_KB AS USED,
                     1 - (AVAIL_KB / TOTAL_KB) AS USED_RATE, 
                     COLLECT_DT 
             FROM TB_DISK_USAGE
            WHERE REG_DATE='{0}'
              AND RSC_REG_SEQ={1}
	        ORDER BY USED_RATE desc
        ) AS T;
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="DISKUSAGE_20231124_ROUNT_ERR" PARAMS="2">
    <DESC>HEALTH CHECK Disk Usage</DESC>
    <DATA>
      <![CDATA[
    SELECT DEVICE_NAME,
             MOUNT_POINT_DIR,
             TOTAL_KB,
             TOTAL_KB - AVAIL_KB AS USED,
             1 - (avail_KB / TOTAL_KB) AS USED_RATE, 
             COLLECT_DT 
     FROM TB_DISK_USAGE
    WHERE REG_DATE='{0}'
      AND RSC_REG_SEQ={1}
	ORDER BY USED_RATE DESC;
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="LOCKCNT" PARAMS="2">
    <DESC>HEALTH CHECK LOCKCNT</DESC>
    <DATA>
      <![CDATA[
              SELECT DB_NAME          
                ,BLOCKING_USER    
                ,BLOCKING_PID     
                --,BLOCKING_QUERY AS BLOCKING_STATEMENT
                ,(SELECT query FROM TB_QUERY_INFO WHERE REG_DATE = '{0}' AND QUERYID = BLOCKING_QUERY) BLOCKING_STATEMENT   
                ,BLOCKED_USER     
                ,BLOCKED_PID      
                --,BLOCKED_QUERY AS BLOCKED_STATEMENT
                ,(SELECT query FROM TB_QUERY_INFO WHERE REG_DATE = '{0}' AND QUERYID = BLOCKED_QUERY) BLOCKED_STATEMENT         
                ,BLOCKED_DURATION 
                ,LOCK_MODE  
				        ,COLLECT_DT
           FROM TB_CURRENT_LOCK 
          WHERE REG_DATE='{0}'
             AND ACTV_REG_SEQ={1}
          ORDER BY ORDER_NO;                        
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="LASTANALYZE" PARAMS="3">
    <DESC>HEALTH CHECK LASTANALYZE</DESC>
    <DATA>
      <![CDATA[
          SELECT DB_NAME,
                 SCHEMA_NAME,
                 TABLE_NAME,
                 TABLE_SIZE_KB / 1000 AS TABLE_SIZE_KB,
                 LIVE_TUPLE_CNT,
	               DEAD_TUPLE_CNT AS DEAD_TUPLE_CNT,
                 CASE WHEN (LIVE_TUPLE_CNT + DEAD_TUPLE_CNT) > 0 THEN ROUND(100 * DEAD_TUPLE_CNT / (LIVE_TUPLE_CNT + DEAD_TUPLE_CNT) ,2) ELSE 0 END AS DEAD_TUPLE_RATIO,
                 --LAST_ANALYZE,
                 CASE WHEN LAST_ANALYZE::DATE = '10000101'::DATE THEN NULL ELSE LAST_ANALYZE END AS LAST_ANALYZE,
                 --CASE WHEN LAST_ANALYZE IS NULL THEN 'UnAnalyzed' ELSE EXTRACT (DAY FROM COLLECT_DT) - EXTRACT (DAY FROM LAST_ANALYZE)||' DAY' END AS DAYS,
                 CASE WHEN LAST_ANALYZE::DATE = '10000101'::DATE THEN 'UnAnalyzed' ELSE COLLECT_DT::DATE - LAST_ANALYZE::DATE||' DAY' END AS DAYS,
                 COLLECT_DT
         FROM TB_TABLE_INFO 
        WHERE REG_DATE='{1}'
           AND OBJT_REG_SEQ={2}
           --AND (LAST_ANALYZE IS NULL OR EXTRACT (DAY FROM COLLECT_DT) - EXTRACT (DAY FROM LAST_ANALYZE) > (SELECT CASE WHEN FIXED_THRESHOLD='9' THEN 99999999 ELSE WARNING_THRESHOLD END FROM TB_HCHK_THRD_LIST WHERE HCHK_NAME='LASTANALYZE' AND INSTANCE_ID={0}))
		   AND COLLECT_DT::DATE - LAST_ANALYZE::DATE > (SELECT CASE WHEN FIXED_THRESHOLD='9' THEN 99999999 ELSE WARNING_THRESHOLD END FROM TB_HCHK_THRD_LIST WHERE HCHK_NAME='LASTANALYZE' AND INSTANCE_ID={0})
           AND NEED_ANALYZE = true
        ORDER BY DB_NAME, SCHEMA_NAME, TABLE_NAME
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="LASTVACUUM" PARAMS="3">
    <DESC>HEALTH CHECK LASTVACUUM</DESC>
    <DATA>
      <![CDATA[
          SELECT DB_NAME,
             SCHEMA_NAME,
             TABLE_NAME,
             TABLE_SIZE_KB / 1000 AS TABLE_SIZE_KB,
             LIVE_TUPLE_CNT,
             DEAD_TUPLE_CNT AS DEAD_TUPLE_CNT,
             CASE WHEN (LIVE_TUPLE_CNT + DEAD_TUPLE_CNT) > 0 THEN ROUND(100 * DEAD_TUPLE_CNT / (LIVE_TUPLE_CNT + DEAD_TUPLE_CNT) ,2) ELSE 0 END AS DEAD_TUPLE_RATIO,
             --LAST_VACUUM,
             CASE WHEN LAST_VACUUM::DATE = '10000101'::DATE THEN NULL ELSE LAST_VACUUM END AS LAST_VACUUM,
             --CASE WHEN LAST_VACUUM IS NULL THEN 'Not Running' ELSE EXTRACT (DAY FROM COLLECT_DT) - EXTRACT (DAY FROM LAST_VACUUM)||' DAY' END AS DAYS,
             CASE WHEN LAST_VACUUM::DATE = '10000101'::DATE THEN 'UnVacuumed' ELSE COLLECT_DT::DATE - LAST_VACUUM::DATE||' DAY' END AS DAYS,
             COLLECT_DT
     FROM TB_TABLE_INFO 
    WHERE REG_DATE='{1}'
       AND OBJT_REG_SEQ={2}
       --AND (LAST_VACUUM IS NULL OR EXTRACT (DAY FROM COLLECT_DT) - EXTRACT (DAY FROM LAST_VACUUM) > (SELECT WARNING_THRESHOLD FROM TB_HCHK_THRD_LIST WHERE HCHK_NAME='LASTANALYZE' AND INSTANCE_ID='{0}'))
	     AND COLLECT_DT::DATE - LAST_VACUUM::DATE > (SELECT CASE WHEN FIXED_THRESHOLD='9' THEN 99999999 ELSE WARNING_THRESHOLD END FROM TB_HCHK_THRD_LIST WHERE HCHK_NAME='LASTVACUUM' AND INSTANCE_ID='{0}')
       AND NEED_VACUUM = true
    ORDER BY DB_NAME, SCHEMA_NAME, TABLE_NAME;
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="LONGRUNSQL" PARAMS="3">
    <DESC>HEALTH CHECK Long Run Sql</DESC>
    <DATA>
      <![CDATA[
       SELECT PROCESS_ID,
         A.DB_NAME,
         CLIENT_ADDR,
         USER_NAME,
         QUERY_START,
         --SQL,
	       CASE WHEN (A.SQL = '') THEN Q.QUERY ELSE A.SQL END AS SQL,
         PROC_CPU_UTIL,
         ELAPSED_TIME,
         --COLLECT_DT
         A.COLLECT_DT
       FROM (
              SELECT MAX(PROCESS_ID) AS PROCESS_ID,
                       MAX(DB_NAME) AS DB_NAME,
                       MAX(CLIENT_ADDR) AS CLIENT_ADDR,
                       MAX(USER_NAME) AS USER_NAME,
                       QUERY_START,
                       QUERYID,
                       SQL,
                       ROUND(MAX(PROC_CPU_UTIL)/100, 2) AS PROC_CPU_UTIL,
                       MAX(ELAPSED_TIME) AS ELAPSED_TIME ,
                       MAX(COLLECT_DT) AS COLLECT_DT
               FROM TB_BACKEND_RSC 
              WHERE REG_DATE='{1}'
               AND ACTV_REG_SEQ={2}
              --GROUP BY SQL, QUERY_START) AS A
              GROUP BY SQL, QUERY_START, QUERYID) AS A LEFT OUTER JOIN TB_QUERY_INFO Q ON A.QUERYID = Q.QUERYID AND Q.INSTANCE_ID={0} AND Q.REG_DATE='{1}'
      WHERE ELAPSED_TIME > (SELECT WARNING_THRESHOLD FROM TB_HCHK_THRD_LIST WHERE INSTANCE_ID={0} AND HCHK_NAME='LONGRUNSQL')
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="TRAXIDLECNT" PARAMS="2">
    <DESC>HEALTH CHECK Trax IDLE Count</DESC>
    <DATA>
      <![CDATA[
       SELECT DB_NAME,
         PROCESS_ID,
         CLIENT_ADDR,
         USER_NAME, 
         QUERY_START AS TRANX_START,
		 COLLECT_DT
       FROM (
                SELECT DB_NAME,
                          PROCESS_ID,
                          CLIENT_ADDR,
                          USER_NAME, 
                          --CASE WHEN SQL NOT LIKE '%IDLE%' THEN 'ACTIVE' WHEN SQL='<IDLE>' THEN 'IDLE' WHEN SQL='<IDLE> in transaction' THEN 'IDLE_TRANX' END AS STATUS,
                          CASE WHEN STATE = 'active' THEN 'ACTIVE' WHEN STATE='idle' THEN 'IDLE' WHEN STATE='idle in transaction' THEN 'IDLE_TRANX' WHEN STATE='idle in transaction (aborted)' THEN 'IDLE_TRANX' END AS STATUS,
                          QUERY_START,
						  COLLECT_DT
                 FROM TB_BACKEND_RSC 
                WHERE REG_DATE='{0}'
                   AND ACTV_REG_SEQ={1}) AS A
       WHERE STATUS='IDLE_TRANX';
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="UNUSEDINDEX" PARAMS="2">
    <DESC>HEALTH CHECK Unused Index</DESC>
    <DATA>
      <![CDATA[
       SELECT DB_NAME,
         SCHEMA_NAME,
         INDEX_NAME,
         TABLE_NAME,
         INDEX_SIZE_KB /1024 AS INDEX_SIZE_KB,
         COLUMNS_CNT,
		 COLLECT_DT
       FROM TB_INDEX_INFO 
      WHERE REG_DATE='{1}' 
         AND OBJT_REG_SEQ=(SELECT MAX(OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO WHERE INSTANCE_ID = {0} AND REG_DATE='{1}' )
         AND AGG_INDEX_SCAN_CNT=0;
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="INVALIDINDEX" PARAMS="2">
    <DESC>HEALTH CHECK Invalid Index</DESC>
    <DATA>
      <![CDATA[
       SELECT DB_NAME,
         SCHEMA_NAME,
         INDEX_NAME,
         TABLE_NAME,
         INDEX_SIZE_KB /1024 AS INDEX_SIZE_KB,
         COLUMNS_CNT,
		 COLLECT_DT
       FROM TB_INDEX_INFO 
      WHERE REG_DATE='{1}' 
         AND OBJT_REG_SEQ=(SELECT MAX(OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO WHERE INSTANCE_ID = {0} AND REG_DATE='{1}' )
         AND INDEX_IS_VALID = false;
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <!--ROW ID="HASTATUS" PARAMS="6">
    <DESC>HEALTH CHECK HA Status</DESC>
    <DATA>
      <![CDATA[
	      SELECT REPL.INSTANCE_ID, REPL.HA_ROLE AS HA_ROLE_S, REPL.HA_HOST AS HA_HOST_S, REPL.HA_PORT AS HA_PORT_S,
				       IST.HA_ROLE, IST.HA_HOST, IST.HA_PORT,	
				       MP.INSTANCE_ID MULTI_PRIMARY_INSTANCE_ID,
				       PRIMARY_LIST.PRIMARY_CNT,
				       '4'                        AS COLLECT_GROUP,
				       REPL.REG_DATE              AS COLLECT_REG_DATE,
				       REPL.REPL_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
				       REPL.COLLECT_DT::time      AS REG_TIME          
	       FROM  TB_INSTANCE_INFO AS IST 
				      ,TB_REPLICATION_INFO AS REPL inner join TB_REPLICATION_INFO AS MP on MP.HA_GROUP = REPL.HA_GROUP
				      ,(SELECT MSS.ha_group HG, SUM(CASE WHEN MSS.HA_ROLE = 'S' THEN 0 ELSE 1 END) AS PRIMARY_CNT
		    	        FROM TB_REPLICATION_INFO MSS
				      ,(SELECT INSTANCE_ID, MAX(C.REPL_REG_SEQ) REG_SEQ from TB_REPLICATION_INFO C WHERE C.REG_DATE='{0}' GROUP BY INSTANCE_ID) MAX_SEQ	        
			  	       WHERE MSS.REPL_REG_SEQ = MAX_SEQ.REG_SEQ
			  		       AND MSS.REG_DATE = '{0}'
		   		       GROUP BY MSS.HA_GROUP) AS PRIMARY_LIST
	      WHERE REPL.REG_DATE     = '{0}'
          AND REPL.INSTANCE_ID  = {1}
	        AND REPL.INSTANCE_ID  = IST.INSTANCE_ID   
	        AND IST.COLLECT_YN    = 'Y'             
	        AND IST.DELETE_YN     = 'N'	
	        AND (IST.HA_ROLE != REPL.HA_ROLE OR IST.HA_HOST != REPL.HA_HOST OR IST.HA_PORT != REPL.HA_PORT OR REPL.HA_ROLE is null OR REPL.HA_HOST is null OR REPL.HA_PORT is null)
	        AND REPL.REPL_REG_SEQ = (SELECT MAX(A.REPL_REG_SEQ) from TB_REPLICATION_INFO A WHERE A.REG_DATE='{0}' AND A.INSTANCE_ID = REPL.INSTANCE_ID)
	        AND MP.INSTANCE_ID != REPL.INSTANCE_ID 
	        AND MP.REPL_REG_SEQ = (SELECT MAX(C.REPL_REG_SEQ) from TB_REPLICATION_INFO C WHERE C.REG_DATE='{0}' AND C.INSTANCE_ID = MP.INSTANCE_ID)
	        AND REPL.HA_GROUP = PRIMARY_LIST.HG
	      ORDER BY REPL.REG_DATE,REPL.REPL_REG_SEQ,REPL.INSTANCE_ID	
    ]]>
    </DATA>
    <COMMENTS />
  </ROW-->
  <ROW ID="HASTATUS" PARAMS="6">
    <DESC>HEALTH CHECK HA Status</DESC>
    <DATA>
      <![CDATA[
	      WITH  TEMP_MAX_SEQ AS ( 
		      SELECT A.INSTANCE_ID, MAX(A.REPL_REG_SEQ) MAX_REG_SEQ 
		      FROM   TB_REPLICATION_INFO A 
		      WHERE  A.REG_DATE    = TO_CHAR(NOW(), 'YYYYMMDD')
            AND REPL_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) + 1 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM REPL_REG_SEQ)
		      GROUP BY A.INSTANCE_ID
	      )
              SELECT  REPL.INSTANCE_ID,
		                  (CASE WHEN PRIMARY_LIST.PRIMARY_CNT > 1 THEN 'Multi Primary.'
		                        WHEN PRIMARY_CNT <= 0 THEN 'NO Primary.'
		                        WHEN IST.HA_ROLE != REPL.HA_ROLE THEN 'Role changed.'
		                        WHEN IST.HA_REPL_HOST != REPL.HA_HOST THEN 'Primary Host changed.'
		                        WHEN IST.HA_PORT != REPL.HA_PORT THEN 'Primary Port changed.'
 		                        WHEN REPL.HA_ROLE IS NULL THEN 'Role changed.'
		                        WHEN REPL.HA_HOST IS NULL THEN 'Primary Host changed.'
		                        WHEN REPL.HA_PORT IS NULL THEN 'Primary Port changed.'
		                        ELSE 'Normal State.' END) ALERT_NAME,
          	                        --'Role : '|| REPL.HA_ROLE ||', Primary Server : '|| REPL.HA_HOST ||': '|| REPL.HA_PORT AS CURRENT_STATUS,
          	                        --'Role : '|| IST.HA_ROLE  ||', Primary Server : '|| IST.HA_HOST  ||': '|| IST.HA_PORT AS CONFIGURATION,
             	        (CASE WHEN REPL.HA_ROLE = 'P' THEN 'HA Role :                  '|| '"HA Primary"' 
                            WHEN REPL.HA_ROLE = 'A' THEN 'HA Role :                  '|| '"Single"' 
            	              ELSE 'HA Role                  : '|| '"HA Stand by"'  || '\n\n' || 'Primary Server host : "'|| REPL.HA_HOST || '"\n\n' ||'Primary Server port  : "'|| REPL.HA_PORT ||'"' END) AS CURRENT_STATUS,
		                  (CASE WHEN IST.HA_ROLE = 'P' THEN 'HA Role :                  '|| '"HA Primary"' 
                            WHEN IST.HA_ROLE = 'A' THEN 'HA Role :                  '|| '"Single"' 
		                        ELSE 'HA Role                  : '|| '"HA Stand by"'  || '\n\n' || 'Primary Server host : "'|| IST.HA_HOST || '"\n\n' ||'Primary Server port  : "'|| IST.HA_PORT ||'"' END) AS CONFIGURATION,
          	          (CASE WHEN PRIMARY_LIST.PRIMARY_CNT > 1 THEN 'Multi Primary Server : ' || IST2.HOST_NAME ||':'|| IST2.SERVICE_PORT
          	                ELSE '' END) AS DESCRIPTION,
          	          '4'                        AS COLLECT_GROUP,
          	          REPL.REG_DATE              AS COLLECT_REG_DATE,
          	          REPL.REPL_REG_SEQ::VARCHAR AS COLLECT_REG_SEQ,
          	          REPL.COLLECT_DT      AS COLLECT_DT
                FROM  TB_INSTANCE_INFO AS IST
          	      ,TB_REPLICATION_INFO AS REPL inner join TB_REPLICATION_INFO AS MP on MP.HA_GROUP = REPL.HA_GROUP
          	      ,(SELECT MSS.HA_GROUP HG, SUM(CASE WHEN MSS.HA_ROLE = 'P' THEN 1  WHEN MSS.HA_ROLE = 'A' THEN 1 ELSE 0 END) AS PRIMARY_CNT FROM TB_REPLICATION_INFO MSS
			      --,(SELECT INSTANCE_ID, MAX(C.REPL_REG_SEQ) REG_SEQ from TB_REPLICATION_INFO C WHERE C.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') GROUP BY INSTANCE_ID) MAX_SEQ
		         --WHERE MSS.REPL_REG_SEQ = MAX_SEQ.REG_SEQ
			      ,TEMP_MAX_SEQ MAX_SEQ
		         WHERE MSS.REPL_REG_SEQ = MAX_SEQ.MAX_REG_SEQ
		           AND MSS.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
                         GROUP BY MSS.HA_GROUP) AS PRIMARY_LIST
                      ,TB_INSTANCE_INFO IST2
                      ,TEMP_MAX_SEQ TMS
                WHERE REPL.REG_DATE     = TO_CHAR(NOW(), 'YYYYMMDD')
                  AND REPL.INSTANCE_ID  = {0}
	          AND REPL.INSTANCE_ID  = IST.INSTANCE_ID
	          AND IST.COLLECT_YN    = 'Y'
	          AND IST.DELETE_YN     = 'N'
	          --AND (IST.HA_ROLE != REPL.HA_ROLE OR IST.HA_HOST != REPL.HA_HOST OR IST.HA_PORT != REPL.HA_PORT OR REPL.HA_ROLE is null OR REPL.HA_HOST is null OR REPL.HA_PORT is null)
	          --AND REPL.REPL_REG_SEQ = (SELECT MAX(A.REPL_REG_SEQ) from TB_REPLICATION_INFO A WHERE A.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') AND A.INSTANCE_ID = REPL.INSTANCE_ID)
	          AND REPL.REPL_REG_SEQ = (SELECT MAX_REG_SEQ from TEMP_MAX_SEQ D WHERE D.INSTANCE_ID = REPL.INSTANCE_ID)
	          AND MP.HA_GROUP = REPL.HA_GROUP
	          AND MP.INSTANCE_ID != REPL.INSTANCE_ID /*싱글은 조회 대상이 아님*/
	          --AND MP.REPL_REG_SEQ = (SELECT MAX(C.REPL_REG_SEQ) from TB_REPLICATION_INFO C WHERE C.REG_DATE=TO_CHAR(NOW(), 'YYYYMMDD') AND C.INSTANCE_ID = MP.INSTANCE_ID)
	          AND MP.REPL_REG_SEQ = TMS.MAX_REG_SEQ
	          AND MP.INSTANCE_ID = TMS.INSTANCE_ID
	          AND MP.INSTANCE_ID = IST2.INSTANCE_ID
	          AND REPL.HA_GROUP = PRIMARY_LIST.HG
          ORDER BY REPL.REG_DATE,REPL.REPL_REG_SEQ,REPL.INSTANCE_ID LIMIT 1;
    ]]>
    </DATA>
    <COMMENTS />
    </ROW>
  
    <ROW ID="REPLICATION_SLOTS" PARAMS="1">
    <DESC>HEALTH CHECK Replication Slots</DESC>
    <DATA>
      <![CDATA[
      SELECT SLOT_NAME, PLUGIN, SLOT_TYPE, DATOID, 
             TEMPORARY::VARCHAR AS ISTEMPORARY, 
             ACTIVE::VARCHAR AS ISACTIVE, OLDXMIN, 
             RESTART_LSN, CONFIRMED_FLUSH_LSN, COLLECT_DT 
        FROM TB_REPLICATION_SLOTS
       WHERE INSTANCE_ID = {0}
         AND REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
         AND REPL_REG_SEQ = (SELECT MAX(REPL_REG_SEQ) REPL_REG_SEQ FROM TB_REPLICATION_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND INSTANCE_ID = {0})
    ]]>
    </DATA>
    </ROW>

    <ROW ID="VIRTUAL_IP" PARAMS="1">
    <DESC>HEALTH CHECK Virtual IP</DESC>
    <DATA>
      <![CDATA[
      WITH  TEMP_MAX_SEQ AS ( 
	        SELECT A.INSTANCE_ID, MAX(A.REPL_REG_SEQ) MAX_REG_SEQ, ha_role, MAX(COLLECT_DT) COLLECT_DT 
	        FROM   TB_REPLICATION_INFO A 
	        WHERE  A.REG_DATE    = TO_CHAR(NOW(), 'YYYYMMDD')
          AND REPL_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) * 2 + 5 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM REPL_REG_SEQ)
	        GROUP BY A.INSTANCE_ID, ha_role
      )
      SELECT HOST_NAME, SERVER_IP, SERVICE_PORT, 
      		 CASE WHEN REP.HA_ROLE = 'P' THEN 'Primary'
      		 	  WHEN REP.HA_ROLE = 'S' THEN 'Slave'
      		 	  ELSE '' END AS HA_ROLE, 
      		 VIRTUAL_IP, VIRTUAL_IP2, COLLECT_DT 
        FROM TB_INSTANCE_INFO INS, TEMP_MAX_SEQ REP
       WHERE ha_group IN (SELECT ha_group FROM TB_INSTANCE_INFO WHERE INSTANCE_ID = {0})
         AND INS.INSTANCE_ID = REP.INSTANCE_ID
    ]]>
    </DATA>
    </ROW>
  <ROW ID="FROZENMAXAGE" PARAMS="2">
    <DESC>HEALTH CHECK FROZENMAXAGE</DESC>
    <DATA>
      <![CDATA[
				WITH IST AS (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN='N' AND INSTANCE_ID = {0})
				 ,TTE AS (
					  SELECT O.REG_DATE, O.OBJT_REG_SEQ, CAST(MAX(T.MAXAGE) AS REAL) M1, RELID, MAX(T.COLLECT_DT) COLLECT_DT
					    FROM IST,
					  	     TB_OBJT_COLLECT_INFO O,
					  	     TB_TABLE_EXT_INFO T
					   WHERE O.REG_DATE='{1}'
					     and O.REG_DATE=T.REG_DATE
					     AND O.OBJT_REG_SEQ = (SELECT MAX(X.OBJT_REG_SEQ) FROM TB_OBJT_COLLECT_INFO X WHERE X.REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') AND X.INSTANCE_ID=O.INSTANCE_ID )
					     AND O.OBJT_REG_SEQ = T.OBJT_REG_SEQ
					     AND O.INSTANCE_ID = IST.INSTANCE_ID
					   GROUP BY O.REG_DATE,O.OBJT_REG_SEQ,O.INSTANCE_ID, RELID
					   ORDER BY M1 desc
					   LIMIT 1
					 )
					SELECT DB_NAME, M1 FROZENMAXAGE, TTE.COLLECT_DT
					 FROM TTE, TB_TABLE_INFO TTI
					 WHERE TTE.REG_DATE = TTI.REG_DATE
					   AND TTE.OBJT_REG_SEQ = TTI.OBJT_REG_SEQ 
					   and TTE.RELID = TTI.RELID
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  
  
  <ROW ID="SELECTSERIALKEY" PARAMS="0">
    <DESC>SELECT SERIAL KEY</DESC>
    <DATA>
      <![CDATA[
       SELECT SERIAL_KEY AS LICDATA
        , NOW()  AS CURDATETIME
      FROM TB_CONFIG;
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>

  <ROW ID="SELECTLICENSE" PARAMS="0">
    <DESC>SELECT LICENSE STATUS </DESC>
    <DATA>
      <![CDATA[
      SELECT STATUS FROM TB_SYS_LOG WHERE REG_DATE = TO_CHAR((NOW() - INTERVAL '1 DAY'), 'YYYYMMDD') AND TASK_CD='3' ORDER BY START_DT DESC LIMIT 1;
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTSERVERDATE" PARAMS="0">
    <DESC>SELECT SERVER DATE </DESC>
    <DATA>
      <![CDATA[
      SELECT  START_DT, CASE WHEN DRIVER_STATUS = 'H' THEN true ELSE FALSE END AS DRIVER_STATUS
        FROM TB_SYS_LOG 
       WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') 
         AND START_DT = (SELECT MAX(START_DT) FROM TB_SYS_LOG)
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTBACKENDCONTROLHIST" PARAMS="0">
    <DESC>SELECT backend control History</DESC>
    <DATA>
      <![CDATA[
       SELECT /* SELECTBACKENDCONTROLHIST */ BACKEND.* 
          FROM 
		    (SELECT  A.INSTANCE_ID
		    , F.CONTROL_TYPE
		    , CASE WHEN (F.ACCESS_TYPE = '0') THEN 'Cancel' ELSE 'Stop' END AS ACCESS_TYPE
		    , F.CONTROL_TIME    
		    , F.ACTV_REG_SEQ
		    , E.COLLECT_DT AS REG_DATE
		    , ROW_NUMBER() OVER (PARTITION BY A.INSTANCE_ID ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL  DESC) AS RNUM
		    , E.DB_NAME                                     --PT_04_04_001(RESRCUTILPERBACK : DB)
		    , E.USER_NAME
		    , E.CLIENT_ADDR
		    , E.CLIENT_APP
		    --, CASE WHEN (E.SQL <>'<IDLE>') THEN 'Active' ELSE 'Idle' END AS "STATE"
		    , CASE WHEN (E.STATE = 'active') THEN 'Active' ELSE 'Idle' END AS "STATE"
		    , E.PROCESS_ID                                  --PT_04_04_001(RESRCUTILPERBACK : PID)
		    , E.CURRENT_PROC_READ_KB                        --PT_03_06_001(BACKEND PROCS : MEM USEAGE READ KB)
		    , E.CURRENT_PROC_WRITE_KB                       --PT_04_04_001(RESRCUTILPERBACK : MEM USAGE WRITE KB)
		    , ROUND(E.PROC_CPU_UTIL / 100,2) AS "CPU_USAGE"          --PT_03_06_001(BACKEND PROCS : CPU_USAGE PER), PT_04_04_001(RESRCUTILPERBACK : CPU_USAGE PER)
		    , E.QUERY_START AS "START_TIME"                 --PT_03_06_001(BACKEND PROCS : QUERY_START)
		    --, CASE WHEN (E.SQL <>'<IDLE>' AND  E.ELAPSED_TIME >= 0 ) THEN E.ELAPSED_TIME ELSE '0' END AS "ELAPSED_TIME"              --PT_03_06_001(BACKEND PROCS : ) 
		    , CASE WHEN (E.SQL = 'active' AND  E.ELAPSED_TIME > 0 ) THEN E.ELAPSED_TIME ELSE '0' END AS "ELAPSED_TIME"              --PT_03_06_001(BACKEND PROCS : ) 
		    , E.SQL AS SQL                                  --PT_03_06_001(BACKEND PROCS : SQL), PT_04_04_001(RESRCUTILPERBACK : SQL)
		    , E.ELAPSED_TIME
		    , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
		    , A.HOST_NAME
		    , E.CURRENT_PROC_READ_KB + E.CURRENT_PROC_WRITE_KB AS "MEM_USAGE_KB"
        , CD.CODE_NAME AS WAIT_EVENT
		   FROM TB_INSTANCE_INFO A,
			   --(SELECT MAX(REG_DATE) AS REG_DATE, MAX(ACTV_REG_SEQ) AS ACTV_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME FROM TB_ACTV_COLLECT_INFO WHERE REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD') GROUP BY INSTANCE_ID) B,
			   TB_BACKEND_RSC E,
			   TB_CONTROL_PROCESS_HIST F, TB_SYS_CODE CD
			    WHERE E.REG_DATE = F.REG_DATE
			    AND A.INSTANCE_ID IN ({0})
			    AND A.INSTANCE_ID = F.INSTANCE_ID
			    AND E.ACTV_REG_SEQ = F.ACTV_REG_SEQ
			    AND F.PROCESS_ID = E.PROCESS_ID			  
			    --AND F.CONTROL_TYPE = '0'
			    AND A.COLLECT_YN = 'Y' 
			    AND A.DELETE_YN = 'N'
			    AND E.SQL != 'BACKGROUND PROC'
			    --AND E.SQL NOT LIKE 'SELECT /* EXPERDBMA%'
			    AND E.SQL IS NOT NULL
          AND E.WAIT_EVENT = CD.CODE
			    ORDER BY E.ELAPSED_TIME DESC, E.PROC_CPU_UTIL DESC)  BACKEND
          WHERE BACKEND.RNUM <= 30   
	    AND ELAPSED_TIME >= 0;     
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTLOCKCONTROLHIST" PARAMS="0">
    <DESC>SELECT lock control History</DESC>
    <DATA>
      <![CDATA[
     SELECT /* SELECTLOCKCONTROLHIST */
           A.INSTANCE_ID
           ,D.CONTROL_TYPE
           ,CASE WHEN (D.ACCESS_TYPE = '0') THEN 'Cancel' ELSE 'Stop' END AS ACCESS_TYPE
           ,D.CONTROL_TIME
           --,TO_CHAR(CONTROL_TIME, 'yyyy-MM-dd hh:mm:ss') AS CONTROL_TIME
           ,D.PROCESS_ID
	         ,C.COLLECT_DT AS REG_DATE
	         ,DB_NAME          
           ,BLOCKING_USER    
           ,BLOCKING_PID     
           --,BLOCKING_QUERY   
           ,(SELECT query FROM TB_QUERY_INFO WHERE INSTANCE_ID IN ({0}) AND QUERYID = BLOCKING_QUERY limit 1) BLOCKING_QUERY           
           ,BLOCKED_USER     
           ,BLOCKED_PID      
           ,BLOCKED_QUERY    
           --,BLOCKING_QUERY   
           ,(SELECT query FROM TB_QUERY_INFO WHERE INSTANCE_ID IN ({0}) AND QUERYID = BLOCKED_QUERY limit 1) BLOCKED_QUERY           
           ,BLOCKED_DURATION 
           ,LOCK_MODE        
           ,QUERY_START      
           ,XACT_START     
           ,ORDER_NO
        FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B, TB_CURRENT_LOCK C, TB_CONTROL_PROCESS_HIST D
        WHERE B.REG_DATE = C.REG_DATE
          AND B.REG_DATE = D.REG_DATE
          AND A.INSTANCE_ID IN ({0})
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND A.INSTANCE_ID = D.INSTANCE_ID          
          AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
          AND B.ACTV_REG_SEQ = D.ACTV_REG_SEQ
          AND D.CONTROL_TYPE = '1'
          AND D.PROCESS_ID = C.BLOCKING_PID 
       ORDER BY ORDER_NO;
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTALERT" PARAMS="2">
    <DESC>Alert</DESC>
    <DATA>
      <![CDATA[
        SELECT 
		        ALERT.instance_id INSTANCE_ID, 
		        CASE WHEN {1}=0 THEN INS.HOST_NAME ELSE INS.CONN_NAME END AS HOST_NAME,
		        ALERT.reg_date REG_DATE,
		        ALERT.hchk_reg_seq HCHK_REG_SEQ,
		        ALERT.hchk_name HCHK_NAME,
            ALERT.state STATE,		
		        --COL.VALUE ,
            CASE WHEN TH.UNIT <> '%' THEN COL.VALUE::integer ELSE COL.VALUE END AS VALUE,
            TH.unit UNIT,
		        DATE(ALERT.reg_date) + COL.reg_time COLLECT_TIME
        FROM TB_HCHK_ALERT_INFO ALERT, 
             TB_INSTANCE_INFO INS ,
             TB_HCHK_COLLECT_INFO COL,
             TB_HCHK_THRD_LIST TH
        WHERE ALERT.hchk_reg_seq = (SELECT MAX(hchk_reg_seq) FROM TB_HCHK_COLLECT_INFO WHERE reg_date = TO_CHAR(NOW(), 'YYYYMMDD'))
        AND ALERT.instance_id = INS.instance_id
        AND ALERT.instance_id = COL.instance_id
        AND ALERT.reg_date = COL.reg_date 
        AND ALERT.reg_date = TO_CHAR(NOW(), 'YYYYMMDD')
        AND ALERT.hchk_reg_seq = COL.hchk_reg_seq
        AND ALERT.hchk_name = COL.hchk_name
        AND ALERT.instance_id = TH.instance_id
        AND ALERT.hchk_name = TH.hchk_name   
        AND ALERT.instance_id in ({0})
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTALERTSEARCH" PARAMS="2">
    <DESC>Alert Search</DESC>
    <DATA>
      <![CDATA[
      SELECT 
		        ALERT.instance_id INSTANCE_ID, 
		        CASE WHEN {0}=0 THEN INS.HOST_NAME ELSE INS.CONN_NAME END AS HOST_NAME,
		        ALERT.reg_date REG_DATE,
		        ALERT.hchk_reg_seq HCHK_REG_SEQ,
		        ALERT.hchk_name HCHK_NAME,
			      ALERT.state STATE,
			      CASE WHEN COALESCE(check_user_id, 'f') = 'f' THEN 'f' ELSE 't' END AS CHECK,
		        COL.VALUE ,
			      TH.unit UNIT,
		        DATE(ALERT.reg_date) + COL.reg_time COLLECT_TIME,
		        CHECK_USER_ID,
		        CHECK_COMMENT,
		        CHECK_IP,
		        CHECK_DT		        
        FROM TB_HCHK_ALERT_INFO ALERT, 
             TB_INSTANCE_INFO INS ,
             TB_HCHK_COLLECT_INFO COL,
             TB_HCHK_THRD_LIST TH
        WHERE ALERT.instance_id = INS.instance_id
        --AND ALERT.hchk_reg_seq = (SELECT MAX(hchk_reg_seq) FROM TB_HCHK_COLLECT_INFO)
        AND ALERT.instance_id = COL.instance_id
        AND ALERT.instance_id = TH.instance_id
        AND ALERT.reg_date = COL.reg_date 
        AND ALERT.hchk_reg_seq = COL.hchk_reg_seq
        AND ALERT.hchk_name = COL.hchk_name
        AND ALERT.hchk_name = TH.hchk_name   
        AND ALERT.REG_DATE BETWEEN '{1}' AND '{2}'
        AND to_date(COL.reg_date, 'YYYYMMDD') || ' ' || COL.reg_time BETWEEN '{3}' AND '{4}'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="UPDATEPAUSEALERT" PARAMS="3">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
      UPDATE TB_HCHK_THRD_LIST
      SET PAUSE_COLLECT_DT = timestamp '{2}' 
      WHERE INSTANCE_ID = {0}
      AND HCHK_NAME = '{1}'
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="UPDATECHECKALERT" PARAMS="7">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
      UPDATE TB_HCHK_ALERT_INFO 
      SET CHECK_USER_ID = '{4}' 
        ,CHECK_COMMENT = '{5}' 
        ,CHECK_IP = '{6}' 
        ,CHECK_DT = NOW()         
      WHERE REG_DATE = '{0}'
      AND HCHK_REG_SEQ = {1}
      AND INSTANCE_ID = '{2}'
      AND HCHK_NAME = '{3}'
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTDETAILSQLRESPTIME" PARAMS="0">
    <DESC>PT_04_10_001(SQL RESPONSE TIME)</DESC>
    <DATA>
      <![CDATA[          
       SELECT	/* SELECTDETAILSQLRESPTIME */ A.INSTANCE_ID
        	   , MAX(BAK.COLLECT_DT) AS COLLECT_DATE
        	   , BAK.PROCESS_ID, BAK.QUERY_START
        	   , CASE WHEN max(BAK.ELAPSED_TIME) < 0 THEN 0 ELSE max(BAK.ELAPSED_TIME) END AS SQL_ELAPSED_SEC
          FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO TAC, TB_BACKEND_RSC BAK
         WHERE TAC.REG_DATE {1}
           AND A.INSTANCE_ID = TAC.INSTANCE_ID       
           AND A.INSTANCE_ID IN ({0})
           AND A.COLLECT_YN = 'Y'
           AND A.DELETE_YN = 'N'
           AND TAC.ACTV_REG_SEQ = BAK.ACTV_REG_SEQ
           AND TAC.REG_DATE = BAK.REG_DATE
           AND BAK.STATE = 'active'
           AND BAK.USER_NAME IS NOT NULL
           AND TO_DATE_IMM(TAC.REG_DATE, 'yyyymmdd') + TAC.REG_TIME BETWEEN {2} AND {3}
           {5}
           GROUP BY A.INSTANCE_ID, BAK.PROCESS_ID, BAK.QUERY_START
           ORDER BY COLLECT_DATE, QUERY_START, COLLECT_DATE , A.INSTANCE_ID
     ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTDETAILSQLLIST" PARAMS="0">
    <DESC>PT_04_10_001(SELECTDETAILSQLLIST)</DESC>
    <DATA>
      <![CDATA[          
          SELECT  A.INSTANCE_ID /* SELECTDETAILSQLLIST */
          , MAX(E.COLLECT_DT) AS COLLECT_DT
          , E.DB_NAME                                     --PT_04_04_001(RESRCUTILPERBACK : DB)
          , E.PROCESS_ID
          , E.QUERY_START AS QUERY_START
				  , E.USER_NAME
				  , E.CLIENT_ADDR
				  , E.CLIENT_APP
          , MAX(E.SQL) AS SQL
	        , MAX(E.ELAPSED_TIME) ELAPSED_TIME
          , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
--          , E.CURRENT_PROC_READ_KB + E.CURRENT_PROC_WRITE_KB AS "MEM_USAGE_KB"
          , ROUND(AVG(E.PROC_CPU_UTIL) / 100,2) AS CPU_USAGE
          , COUNT(E.SQL) SQL_COUNT
         FROM TB_INSTANCE_INFO A,
              TB_ACTV_COLLECT_INFO B,
              TB_BACKEND_RSC E
          WHERE E.REG_DATE {2}
          AND B.REG_DATE = E.REG_DATE
          AND A.INSTANCE_ID IN ({0})
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ
          AND A.COLLECT_YN = 'Y' 
          AND A.DELETE_YN = 'N'
          AND E.ELAPSED_TIME > 0
          --AND E.PROC_CPU_UTIL > 0
          AND E.SQL IS NOT NULL
          AND E.SQL != 'BACKGROUND PROC'
          AND E.SQL != 'COMMIT'
          --AND E.SQL NOT LIKE 'SELECT /* EXPERDBMA%'
          AND E.COLLECT_DT BETWEEN {3} AND {4}
          GROUP BY A.INSTANCE_ID, E.DB_NAME, E.PROCESS_ID, QUERY_START, E.USER_NAME, E.CLIENT_ADDR, E.CLIENT_APP
          ORDER BY ELAPSED_TIME DESC, CPU_USAGE DESC
          LIMIT 1000; --temporary
     ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTDETAILSQLLISTEXT_OLD" PARAMS="0">
    <DESC>PT_04_10_001(SELECTDETAILSQLLISTEXT)</DESC>
    <DATA>
      <![CDATA[
          {5}
          SELECT  A.INSTANCE_ID /* SELECTDETAILSQLLISTEXT */
          , MAX(E.COLLECT_DT) AS COLLECT_DT
          , E.DB_NAME                                     --PT_04_04_001(RESRCUTILPERBACK : DB)
          , E.PROCESS_ID
          , E.QUERY_START AS QUERY_START
				  , E.USER_NAME
				  , E.CLIENT_ADDR
				  , E.CLIENT_APP
          --, MAX(E.SQL) AS SQL
          --, CASE WHEN (MAX(E.SQL) = '') THEN MAX(Q.QUERY) ELSE MAX(E.SQL) END AS SQL -- 1005
          , MAX(Q.QUERY) AS SQL
	        , MAX(E.ELAPSED_TIME) ELAPSED_TIME
          , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
--          , E.CURRENT_PROC_READ_KB + E.CURRENT_PROC_WRITE_KB AS "MEM_USAGE_KB"
          , ROUND(AVG(E.PROC_CPU_UTIL) / 100,2) AS CPU_USAGE
          , COUNT(E.SQL) SQL_COUNT
         FROM TB_INSTANCE_INFO A,
              TB_ACTV_COLLECT_INFO B,
              TB_BACKEND_RSC E
              LEFT OUTER JOIN TB_QUERY_INFO Q ON E.QUERYID = Q.QUERYID AND INSTANCE_ID in ({0})
          WHERE E.REG_DATE {2}
          AND to_date_imm(b.reg_date, 'yyyymmdd') + b.reg_time BETWEEN {3} AND {4}
          AND B.REG_DATE = E.REG_DATE
          AND A.INSTANCE_ID IN ({0})
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND A.INSTANCE_ID = Q.INSTANCE_ID
          AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ
          AND A.COLLECT_YN = 'Y' 
          AND A.DELETE_YN = 'N'
          --AND E.ELAPSED_TIME > 0
          --AND E.PROC_CPU_UTIL > 0
          AND E.SQL IS NOT NULL
          --AND E.SQL != 'BACKGROUND PROC'
          --AND E.SQL != 'COMMIT'
          --AND E.SQL NOT LIKE 'SELECT /* EXPERDBMA%'
          --AND E.COLLECT_DT BETWEEN {3} AND {4}
          --AND B.REG_TIME BETWEEN {3} AND {4}
          GROUP BY A.INSTANCE_ID, E.DB_NAME, E.PROCESS_ID, QUERY_START, E.USER_NAME, E.CLIENT_ADDR, E.CLIENT_APP
          ORDER BY ELAPSED_TIME DESC, CPU_USAGE DESC
          LIMIT 3000; --temporary
     ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTDETAILSQLLISTEXT" PARAMS="0">
    <DESC>PT_04_10_001(SELECTDETAILSQLLISTEXT)</DESC>
    <DATA>
      <![CDATA[
{5}
WITH PGSTA AS (SELECT INSTANCE_ID, HOST_NAME, CONN_NAME FROM TB_INSTANCE_INFO WHERE instance_id IN ({0}) AND (EXTENSIONS & 4) = 0),
	 PGACT AS (SELECT INSTANCE_ID, HOST_NAME, CONN_NAME FROM TB_INSTANCE_INFO WHERE instance_id IN ({0}) AND (EXTENSIONS & 4) > 0)
          SELECT  A.INSTANCE_ID /* SELECTDETAILSQLLISTEXT */
          , MAX(E.COLLECT_DT) AS COLLECT_DT
          , E.DB_NAME                                     --PT_04_04_001(RESRCUTILPERBACK : DB)
          , E.PROCESS_ID
          , E.QUERY_START AS QUERY_START
		  , E.USER_NAME
		  , E.CLIENT_ADDR
		  , E.CLIENT_APP
      , E.STATE       
      , (SELECT CODE_NAME FROM TB_SYS_CODE WHERE CODE = E.WAIT_EVENT ) WAIT_EVENT
          , MAX(Q.QUERY) AS SQL
	      , MAX(E.ELAPSED_TIME) ELAPSED_TIME
          , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
          , ROUND(AVG(E.PROC_CPU_UTIL) / 100,2) AS CPU_USAGE
          , COUNT(E.SQL) SQL_COUNT
         FROM PGSTA A,
              TB_ACTV_COLLECT_INFO B
              JOIN TB_BACKEND_RSC E ON B.REG_DATE = E.REG_DATE AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ   
              LEFT OUTER JOIN TB_QUERY_INFO Q ON E.REG_DATE = Q.REG_DATE AND B.INSTANCE_ID = Q.INSTANCE_ID AND E.QUERYID = Q.QUERYID 
          WHERE E.REG_DATE {2}
          AND to_date_imm(b.reg_date, 'yyyymmdd') + b.reg_time BETWEEN {3} AND {4}
          AND B.REG_DATE = E.REG_DATE
          AND A.INSTANCE_ID IN ({0})
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND E.SQL IS NOT NULL
          GROUP BY A.INSTANCE_ID, A.HOST_NAME, A.CONN_NAME, E.DB_NAME, E.PROCESS_ID, QUERY_START, E.USER_NAME, E.CLIENT_ADDR, E.CLIENT_APP, E.WAIT_EVENT, E.STATE 
UNION    
          SELECT  A.INSTANCE_ID /* SELECTDETAILSQLLISTEXT */
          , MAX(E.COLLECT_DT) AS COLLECT_DT
          , E.DB_NAME                                     --PT_04_04_001(RESRCUTILPERBACK : DB)
          , E.PROCESS_ID
          , E.QUERY_START AS QUERY_START
		  , E.USER_NAME
		  , E.CLIENT_ADDR
		  , E.CLIENT_APP
      , E.STATE       
      , (SELECT CODE_NAME FROM TB_SYS_CODE WHERE CODE = E.WAIT_EVENT ) WAIT_EVENT
          , MAX(Q.QUERY) AS SQL
	      , MAX(E.ELAPSED_TIME) ELAPSED_TIME
          , CASE WHEN {1}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
          , ROUND(AVG(E.PROC_CPU_UTIL) / 100,2) AS CPU_USAGE
          , COUNT(E.SQL) SQL_COUNT
         FROM PGACT A,
              TB_ACTV_COLLECT_INFO B
              JOIN TB_BACKEND_RSC E ON B.REG_DATE = E.REG_DATE AND B.ACTV_REG_SEQ = E.ACTV_REG_SEQ   
              LEFT OUTER JOIN TB_PGSS_QUERY_INFO Q ON B.INSTANCE_ID = Q.INSTANCE_ID AND E.QUERYID = Q.QUERYID 
          WHERE E.REG_DATE {2}
          AND to_date_imm(b.reg_date, 'yyyymmdd') + b.reg_time BETWEEN {3} AND {4}
          AND B.REG_DATE = E.REG_DATE
          AND A.INSTANCE_ID IN ({0})
          AND A.INSTANCE_ID = B.INSTANCE_ID
          AND E.SQL IS NOT NULL
          GROUP BY A.INSTANCE_ID, A.HOST_NAME, A.CONN_NAME, E.DB_NAME, E.PROCESS_ID, QUERY_START, E.USER_NAME, E.CLIENT_ADDR, E.CLIENT_APP, E.WAIT_EVENT, E.STATE  
          ORDER BY ELAPSED_TIME DESC, CPU_USAGE DESC
          LIMIT 1000; --temporary
     ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTTBSPACEINFO2" PARAMS="0">
    <DESC>PT_05_04_001(TABLESPACE INFO)</DESC>
    <DATA>
      <![CDATA[
          SELECT A.INSTANCE_ID
            , D.COLLECT_DT AS REG_DATE
            , D.MOUNT_POINT_DIR                                                           --PT_03_05_001(DISK USAGE)
            , D.TOTAL_KB                                                                  --PT_03_05_001(DISK USAGE TOTAL)
            , D.USED_KB
            , D.AVAIL_KB
            , ROUND((((D.TOTAL_KB-D.avail_kb)/D.TOTAL_KB) * 100),2) AS DISK_USAGE_PER     --PT_03_05_001(DISK USAGE PER)
            , CASE WHEN {0}=0 THEN A.HOST_NAME ELSE A.CONN_NAME END AS HOST_NAME
            , NULL AS TABLESPACE_NAME
            , NULL AS LOCATION
            , NULL AS TS_SIZE_KB
          FROM TB_INSTANCE_INFO A
               , (SELECT MAX(REG_DATE) AS REG_DATE, MAX(RSC_REG_SEQ) AS RSC_REG_SEQ, INSTANCE_ID, MAX(REG_TIME) AS REG_TIME 
                    FROM TB_RSC_COLLECT_INFO 
                   WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD')
			               AND RSC_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) + 1 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM RSC_REG_SEQ)
                   GROUP BY INSTANCE_ID) B  
               , TB_DISK_USAGE D
          WHERE A.INSTANCE_ID = B.INSTANCE_ID
            AND B.REG_DATE = D.REG_DATE
            AND B.RSC_REG_SEQ = D.RSC_REG_SEQ
            AND A.INSTANCE_ID IN ({1})
            AND A.COLLECT_YN = 'Y'
            AND A.DELETE_YN = 'N'
        UNION
           SELECT NULL AS INSTANCE_ID
            , NULL AS REG_DATE
            , NULL MOUNT_POINT_DIR                                                           --PT_03_05_001(DISK USAGE)
            , NULL AS TOTAL_KB                                                                  --PT_03_05_001(DISK USAGE TOTAL)
            , NULL AS USED_KB
            , NULL AS AVAIL_KB
            , NULL AS DISK_USAGE_PER     --PT_03_05_001(DISK USAGE PER)
            , NULL AS HOST_NAME
            , CC.TABLESPACE_NAME AS TABLESPACE
	    , CC.LOCATION AS LOCATION
            , CC.SIZE_KB AS TS_SIZE_KB
          FROM TB_INSTANCE_INFO AA
               , (SELECT MAX(REG_DATE) AS REG_DATE, MAX(OBJT_REG_SEQ) AS OBJT_REG_SEQ, INSTANCE_ID 
                    FROM TB_OBJT_COLLECT_INFO 
                   WHERE REG_DATE=TO_CHAR(NOW(),'YYYYMMDD') 
   		               AND OBJT_REG_SEQ >= (SELECT (LAST_VALUE - (SELECT COUNT(*) + 1 FROM TB_INSTANCE_INFO)) + 1 AS LAST_VALUE FROM OBJT_REG_SEQ)
                   GROUP BY INSTANCE_ID) BB          
          , TB_TABLESPACE_INFO CC
          WHERE AA.INSTANCE_ID = BB.INSTANCE_ID
          AND BB.REG_DATE = CC.REG_DATE
          AND BB.OBJT_REG_SEQ = CC.OBJT_REG_SEQ
          AND AA.INSTANCE_ID IN ({2})
          AND AA.COLLECT_YN = 'Y'
          AND AA.DELETE_YN = 'N' 
        ORDER BY INSTANCE_ID, MOUNT_POINT_DIR, LOCATION
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTREPLICATIONSTATE" PARAMS="0">
    <DESC>PT_05_04_001(TABLESPACE INFO)</DESC>
    <DATA>
      <![CDATA[
        SELECT 
            (SELECT trim(substring(ARR_COL, length('host=')+1), E'\'')  
              FROM 
                (SELECT regexp_split_to_table(conninfo, E'\\s+') ARR_COL 
                  FROM pg_stat_wal_receiver) ARR2 WHERE ARR_COL LIKE 'host=%' ORDER BY arr_col) Host, 
            (SELECT substring(ARR_COL, length('port=')+1)
              FROM 
                (SELECT regexp_split_to_table(conninfo, E'\\s+') ARR_COL 
                  FROM pg_stat_wal_receiver) ARR2 WHERE ARR_COL LIKE 'port=%' ORDER BY arr_col) Port
        ]]>
  </DATA>
  </ROW>
    
  <ROW ID="SELECTSTATEMENTLIST" PARAMS="0">
    <DESC>PT_04_10_001(SELECTSTATEMENTLIST)</DESC>
    <DATA>
      <![CDATA[          
     WITH MAXD AS (   /* SELECTSTATEMENTLIST */  
 				    SELECT T.INSTANCE_ID, T.REG_DATE, T.COLLECT_DT,AA.* 
							FROM TB_PG_STAT_STATEMENTS T
							LEFT   JOIN LATERAL (
								   SELECT 	elem->>'userid' AS USERID 
											,elem->>'dbid'AS DBID 
											,(elem->>'queryid')::int8 AS QUERYID
											,(elem->>'cqueryid')::varchar AS CQUERYID
                      ,(elem->>'calls')::int8 AS CALLS
											,(elem->>'total_time')::float8 AS TOTAL_TIME 
											,(elem->>'min_time')::float8 AS MIN_TIME 
											,(elem->>'max_time')::float8 AS MAX_TIME 
											,(elem->>'mean_time')::float8 AS MEAN_TIME
											,(elem->>'stddev_time')::float8 AS STDDEV_TIME
											,(elem->>'rows')::int8 AS ROWS 
											,(elem->>'shared_blks_hit')::int8 AS SHARED_BLKS_HIT
											,(elem->>'shared_blks_read')::int8 AS SHARED_BLKS_READ 
											,(elem->>'shared_blks_dirtied')::int8 AS SHARED_BLKS_DIRTIED
											,(elem->>'shared_blks_written')::int8 AS SHARED_BLKS_WRITTEN
											,(elem->>'local_blks_hit')::int8 AS LOCAL_BLKS_HIT 
											,(elem->>'local_blks_read')::int8 AS LOCAL_BLKS_READ
											,(elem->>'local_blks_dirtied')::int8 AS LOCAL_BLKS_DIRTIED 
											,(elem->>'local_blks_written')::int8 AS LOCAL_BLKS_WRITTEN 
											,(elem->>'temp_blks_read')::int8 AS TEMP_BLKS_READ 
											,(elem->>'temp_blks_written')::int8 AS TEMP_BLKS_WRITTEN
											,(elem->>'blk_read_time')::float8 AS BLK_READ_TIME
											,(elem->>'blk_write_time')::float8 AS BLK_WRITE_TIME 
								   FROM   JSONB_ARRAY_ELEMENTS(T.PGSS) A(ELEM)   
							   ) AA ON TRUE                              -- PRESERVE ALL ROWS FROM T
           WHERE COLLECT_DT {1} 
             AND REG_DATE {2}
					   AND T.INSTANCE_ID IN ({0})
       )
     , STATS AS (
           	SELECT  
	          		MAXD.INSTANCE_ID, 
	          		MAXD.REG_DATE, 
	          		MAXD.COLLECT_DT,
					      --MAXD.DBID,
                SUM(MAXD.CALLS) AS SUM_CALLS,
                SUM(MAXD.TOTAL_TIME) AS SUM_TOTAL_TIME,
                SUM(MAXD.BLK_READ_TIME+MAXD.BLK_WRITE_TIME) AS IO_TIME,
                SUM(MAXD.TOTAL_TIME-MAXD.BLK_READ_TIME-MAXD.BLK_WRITE_TIME) AS CPU_TIME,
                SUM(MAXD.ROWS)  AS SUM_ROWS
	         FROM   MAXD
	         --GROUP BY INSTANCE_ID, REG_DATE, COLLECT_DT, DBID
	         GROUP BY INSTANCE_ID, REG_DATE, COLLECT_DT
     )
	   SELECT  
	      	 MAXD.USERID
					,MAXD.DBID
					,MAXD.QUERYID
          ,MAX(CALLS) - MIN(CALLS)             AS CALLS  
					,TO_CHAR((CASE WHEN (MAX(CALLS)-MIN(CALLS)) = 0 
                    THEN 0 || ' millisecond' ELSE ROUND(((MAX(TOTAL_TIME)-MIN(TOTAL_TIME))/(MAX(CALLS)-MIN(CALLS)))::NUMERIC,4)  || ' millisecond' 
                    END)::INTERVAL, 'DD.HH24:MI:SS.US') AVG_TIME
					,TO_CHAR((ROUND((MAX(TOTAL_TIME) - MIN(TOTAL_TIME))::numeric, 4) || ' millisecond')::interval, 'DD.HH24:MI:SS.US')  AS TOTAL_TIME
          			,ROUND((MAX(MIN_TIME) / 1000)::numeric,4)    AS WHOLE_MIN_TIME           
					,ROUND((MAX(MAX_TIME) / 1000)::numeric,4)    AS WHOLE_MAX_TIME           
					,ROUND((MAX(MEAN_TIME) / 1000)::numeric,4)   AS WHOLE_MEAN_TIME          
					,ROUND((MAX(STDDEV_TIME) / 1000)::numeric,4) AS WHOLE_STDDEV_TIME          
					,ROUND((MAX(TOTAL_TIME) / 1000)::numeric,4)  AS WHOLE_TOTAL_TIME          
					,MAX(ROWS)                - MIN(ROWS)                AS ROWS               
					,MAX(SHARED_BLKS_HIT)     - MIN(SHARED_BLKS_HIT)     AS SHARED_BLKS_HIT    
					,MAX(SHARED_BLKS_READ)    - MIN(SHARED_BLKS_READ)    AS SHARED_BLKS_READ   
					,MAX(SHARED_BLKS_DIRTIED) - MIN(SHARED_BLKS_DIRTIED) AS SHARED_BLKS_DIRTIED
					,MAX(SHARED_BLKS_WRITTEN) - MIN(SHARED_BLKS_WRITTEN) AS SHARED_BLKS_WRITTEN
					,MAX(LOCAL_BLKS_HIT)      - MIN(LOCAL_BLKS_HIT)      AS LOCAL_BLKS_HIT
					,MAX(LOCAL_BLKS_READ)     - MIN(LOCAL_BLKS_READ)     AS LOCAL_BLKS_READ
					,MAX(LOCAL_BLKS_DIRTIED)  - MIN(LOCAL_BLKS_DIRTIED)  AS LOCAL_BLKS_DIRTIED
					,MAX(LOCAL_BLKS_WRITTEN)  - MIN(LOCAL_BLKS_WRITTEN)  AS LOCAL_BLKS_WRITTEN
					,MAX(TEMP_BLKS_READ)      - MIN(TEMP_BLKS_READ)      AS TEMP_BLKS_READ
					,MAX(TEMP_BLKS_WRITTEN)   - MIN(TEMP_BLKS_WRITTEN)   AS TEMP_BLKS_WRITTEN  
					,MAX(BLK_READ_TIME)       - MIN(BLK_READ_TIME)       AS BLK_READ_TIME
					,MAX(BLK_WRITE_TIME)      - MIN(BLK_WRITE_TIME)      AS BLK_WRITE_TIME
					--,ROUND((100*(MAX(TOTAL_TIME)-MIN(TOTAL_TIME))/(select GREATEST(MAX(SUM_TOTAL_TIME)-MIN(SUM_TOTAL_TIME),1) FROM STATS WHERE STATS.DBID = MAXD.DBID))::numeric,2) AS TIME_PERCENT
					--,ROUND((100*(MAX(BLK_READ_TIME)-MIN(BLK_READ_TIME)+MAX(BLK_WRITE_TIME)-MIN(BLK_WRITE_TIME))/(SELECT GREATEST(MAX(IO_TIME)-MIN(IO_TIME),1) FROM STATS WHERE STATS.DBID = MAXD.DBID))::numeric,2) AS IO_TIME_PERCENT
					--,ROUND((100*((MAX(TOTAL_TIME)-MIN(TOTAL_TIME))-(MAX(BLK_READ_TIME)-MIN(BLK_READ_TIME))-(MAX(BLK_WRITE_TIME)-MIN(BLK_WRITE_TIME)))/(SELECT GREATEST(MAX(CPU_TIME)-MIN(CPU_TIME),1) FROM STATS WHERE STATS.DBID = MAXD.DBID))::numeric,2) AS CPU_TIME_PERCENT
					--,(100*(MAX(CALLS)-MIN(CALLS))/(SELECT GREATEST(MAX(SUM_CALLS)-MIN(SUM_CALLS),1) FROM STATS WHERE STATS.DBID = MAXD.DBID))::numeric(20, 2) AS CALLS_PERCENT
					--,(100*(MAX(ROWS)-MIN(ROWS))/(SELECT GREATEST(MAX(SUM_ROWS)-MIN(SUM_ROWS),1) FROM STATS WHERE STATS.DBID = MAXD.DBID))::numeric(20, 2) AS ROW_PERCENT
					,ROUND((100*(MAX(TOTAL_TIME)-MIN(TOTAL_TIME))/(select GREATEST(MAX(SUM_TOTAL_TIME)-MIN(SUM_TOTAL_TIME),1) FROM STATS))::numeric,2) AS TIME_PERCENT
					,ROUND((100*(MAX(BLK_READ_TIME)-MIN(BLK_READ_TIME)+MAX(BLK_WRITE_TIME)-MIN(BLK_WRITE_TIME))/(SELECT GREATEST(MAX(IO_TIME)-MIN(IO_TIME),1) FROM STATS))::numeric,2) AS IO_TIME_PERCENT
					,ROUND((100*((MAX(TOTAL_TIME)-MIN(TOTAL_TIME))-(MAX(BLK_READ_TIME)-MIN(BLK_READ_TIME))-(MAX(BLK_WRITE_TIME)-MIN(BLK_WRITE_TIME)))/(SELECT GREATEST(MAX(CPU_TIME)-MIN(CPU_TIME),1) FROM STATS))::numeric,2) AS CPU_TIME_PERCENT
					,(100*(MAX(CALLS)-MIN(CALLS))/(SELECT GREATEST(MAX(SUM_CALLS)-MIN(SUM_CALLS),1) FROM STATS))::numeric(20, 2) AS CALLS_PERCENT
					,(100*(MAX(ROWS)-MIN(ROWS))/(SELECT GREATEST(MAX(SUM_ROWS)-MIN(SUM_ROWS),1) FROM STATS))::numeric(20, 2) AS ROW_PERCENT
	      	 ,MAX(QI.QUERY) AS QUERY
	     FROM MAXD
	          LEFT OUTER JOIN TB_PGSS_QUERY_INFO QI
	           ON QI.INSTANCE_ID = MAXD.INSTANCE_ID AND QI.QUERYID = MAXD.CQUERYID
--	      GROUP BY MAXD.INSTANCE_ID, MAXD.REG_DATE,MAXD.DBID, MAXD.USERID,MAXD.QUERYID 
	      GROUP BY MAXD.INSTANCE_ID, MAXD.DBID, MAXD.USERID,MAXD.QUERYID,MAXD.CQUERYID
        HAVING MAX(CALLS) - MIN(CALLS) > 0
		  ORDER BY CALLS DESC, TOTAL_TIME DESC;
     ]]>
    </DATA>
  </ROW>
    <ROW ID="SELECTSTATEMENTSTOP" PARAMS="0">
    <DESC>PT_04_10_001(SELECTSTATEMENTSTOP)</DESC>
    <DATA>
      <![CDATA[               
WITH MAXD AS (   /* SELECTSTATEMENTSTOP */  
	    SELECT T.INSTANCE_ID, T.COLLECT_DT
      	     	,AA.DBID
	   				  ,AA.QUERYID
							,SUM(AA.CALLS)					CALLS              
							,SUM(AA.TOTAL_TIME)             TOTAL_TIME         
							,MIN(AA.MIN_TIME)               MIN_TIME           
							,MAX(AA.MAX_TIME )              MAX_TIME           
							,AVG(AA.MEAN_TIME)              MEAN_TIME          
							,SUM(AA.STDDEV_TIME)            STDDEV_TIME        
							,SUM(AA.ROWS)                AS ROWS               
							,SUM(AA.SHARED_BLKS_HIT)        SHARED_BLKS_HIT    
							,SUM(AA.SHARED_BLKS_READ)       SHARED_BLKS_READ   
							,SUM(AA.SHARED_BLKS_DIRTIED)    SHARED_BLKS_DIRTIED
							,SUM(AA.SHARED_BLKS_WRITTEN)    SHARED_BLKS_WRITTEN
							,SUM(AA.LOCAL_BLKS_HIT)         LOCAL_BLKS_HIT     
							,SUM(AA.LOCAL_BLKS_READ)        LOCAL_BLKS_READ    
							,SUM(AA.LOCAL_BLKS_DIRTIED)     LOCAL_BLKS_DIRTIED 
							,SUM(AA.LOCAL_BLKS_WRITTEN)     LOCAL_BLKS_WRITTEN 
							,SUM(AA.TEMP_BLKS_READ)         TEMP_BLKS_READ     
							,SUM(AA.TEMP_BLKS_WRITTEN)      TEMP_BLKS_WRITTEN  
							,SUM(AA.BLK_READ_TIME)          BLK_READ_TIME      
							,SUM(AA.BLK_WRITE_TIME)         BLK_WRITE_TIME
				FROM TB_PG_STAT_STATEMENTS T
				LEFT   JOIN LATERAL (
					  SELECT 	elem->>'userid' AS USERID 
								,elem->>'dbid' AS DBID 
								,(elem->>'queryid')::int8 AS QUERYID
								,(elem->>'calls')::int8 AS CALLS
								,(elem->>'total_time')::float8 AS TOTAL_TIME 
								,(elem->>'min_time')::float8 AS MIN_TIME 
								,(elem->>'max_time')::float8 AS MAX_TIME 
								,(elem->>'mean_time')::float8 AS MEAN_TIME
								,(elem->>'stddev_time')::float8 AS STDDEV_TIME
								,(elem->>'rows')::int8 AS ROWS 
								,(elem->>'shared_blks_hit')::int8 AS SHARED_BLKS_HIT
								,(elem->>'shared_blks_read')::int8 AS SHARED_BLKS_READ 
								,(elem->>'shared_blks_dirtied')::int8 AS SHARED_BLKS_DIRTIED
								,(elem->>'shared_blks_written')::int8 AS SHARED_BLKS_WRITTEN
								,(elem->>'local_blks_hit')::int8 AS LOCAL_BLKS_HIT 
								,(elem->>'local_blks_read')::int8 AS LOCAL_BLKS_READ
								,(elem->>'local_blks_dirtied')::int8 AS LOCAL_BLKS_DIRTIED 
								,(elem->>'local_blks_written')::int8 AS LOCAL_BLKS_WRITTEN 
								,(elem->>'temp_blks_read')::int8 AS TEMP_BLKS_READ 
								,(elem->>'temp_blks_written')::int8 AS TEMP_BLKS_WRITTEN
								,(elem->>'blk_read_time')::float8 AS BLK_READ_TIME
								,(elem->>'blk_write_time')::float8 AS BLK_WRITE_TIME 
					   FROM   JSONB_ARRAY_ELEMENTS(T.PGSS) A(ELEM)   
				   ) AA ON TRUE                              -- PRESERVE ALL ROWS FROM T
		        WHERE COLLECT_DT {1}
				      AND REG_DATE {2}
	            AND T.INSTANCE_ID IN ({0})  
            GROUP BY T.INSTANCE_ID, T.COLLECT_DT, AA.DBID, AA.QUERYID
     )
    , STATS AS (
           	SELECT  
	          		MAXD.INSTANCE_ID,
	          		MAXD.COLLECT_DT,
					      --MAXD.DBID,
                GREATEST(SUM(MAXD.CALLS),1) AS SUM_CALLS,
                GREATEST(SUM(MAXD.TOTAL_TIME),1) AS SUM_TOTAL_TIME,
                GREATEST(SUM(MAXD.BLK_READ_TIME+MAXD.BLK_WRITE_TIME),1) AS IO_TIME,
                GREATEST(SUM(MAXD.TOTAL_TIME-MAXD.BLK_READ_TIME-MAXD.BLK_WRITE_TIME),1) AS CPU_TIME,
                GREATEST(SUM(MAXD.ROWS),1)  AS SUM_ROWS
	         FROM   MAXD
	         --GROUP BY INSTANCE_ID, COLLECT_DT, DBID
	         GROUP BY INSTANCE_ID, COLLECT_DT--, DBID
   )    
      SELECT
  		         PGS.DBID, PGS.QUERYID 
		          ,MAX(PGS.CALLS)          - MIN(PGS.CALLS)               AS CALLS    
		          ,ROUND(((MAX(TOTAL_TIME) - MIN(TOTAL_TIME)) / 1000)::NUMERIC,4)  AS TOTAL_TIME         
		          ,MAX(ROWS)               - MIN(ROWS)                AS ROWS               
		          --,ROUND((100*(MAX(BLK_READ_TIME)-MIN(BLK_READ_TIME)+MAX(BLK_WRITE_TIME)-MIN(BLK_WRITE_TIME))/(SELECT GREATEST(MAX(IO_TIME)-MIN(IO_TIME),1) FROM STATS WHERE STATS.DBID = PGS.DBID))::NUMERIC,2) AS IO_TIME
		          --,ROUND((100*((MAX(TOTAL_TIME)-MIN(TOTAL_TIME))-(MAX(BLK_READ_TIME)-MIN(BLK_READ_TIME))-(MAX(BLK_WRITE_TIME)-MIN(BLK_WRITE_TIME)))/(SELECT GREATEST(MAX(CPU_TIME)-MIN(CPU_TIME),1) FROM STATS WHERE STATS.DBID = PGS.DBID))::NUMERIC,2) AS CPU_TIME
		          ,ROUND((100*(MAX(BLK_READ_TIME)-MIN(BLK_READ_TIME)+MAX(BLK_WRITE_TIME)-MIN(BLK_WRITE_TIME))/(SELECT GREATEST(MAX(IO_TIME)-MIN(IO_TIME),1) FROM STATS))::NUMERIC,2) AS IO_TIME
		          ,ROUND((100*((MAX(TOTAL_TIME)-MIN(TOTAL_TIME))-(MAX(BLK_READ_TIME)-MIN(BLK_READ_TIME))-(MAX(BLK_WRITE_TIME)-MIN(BLK_WRITE_TIME)))/(SELECT GREATEST(MAX(CPU_TIME)-MIN(CPU_TIME),1) FROM STATS))::NUMERIC,2) AS CPU_TIME
	      --FROM MAXD PGS JOIN STATS ON PGS.COLLECT_DT = STATS.COLLECT_DT AND PGS.DBID = STATS.DBID
	      FROM MAXD PGS JOIN STATS ON PGS.COLLECT_DT = STATS.COLLECT_DT
	     GROUP BY PGS.INSTANCE_ID, PGS.DBID, PGS.QUERYID
	     ORDER BY {3}
        LIMIT {4}
     ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTSTATEMENTSCALLS" PARAMS="0">
    <DESC>PT_04_10_001(SELECTSTATEMENTSCALLS)</DESC>
    <DATA>
      <![CDATA[
      WITH MAXD AS (   /* SELECTSTATEMENTSCALLS */  
 				        SELECT T.INSTANCE_ID, T.COLLECT_DT
 				    			  ,AA.DBID
	   				        ,AA.QUERYID
								    ,SUM(AA.CALLS)					CALLS              
								    ,SUM(AA.TOTAL_TIME)             TOTAL_TIME         
								    ,MIN(AA.MIN_TIME)               MIN_TIME           
								    ,MAX(AA.MAX_TIME )              MAX_TIME           
								    ,AVG(AA.MEAN_TIME)              MEAN_TIME          
								    ,SUM(AA.STDDEV_TIME)            STDDEV_TIME        
								    ,SUM(AA.ROWS)                AS ROWS               
								    ,SUM(AA.SHARED_BLKS_HIT)        SHARED_BLKS_HIT    
								    ,SUM(AA.SHARED_BLKS_READ)       SHARED_BLKS_READ   
								    ,SUM(AA.SHARED_BLKS_DIRTIED)    SHARED_BLKS_DIRTIED
								    ,SUM(AA.SHARED_BLKS_WRITTEN)    SHARED_BLKS_WRITTEN
								    ,SUM(AA.LOCAL_BLKS_HIT)         LOCAL_BLKS_HIT     
								    ,SUM(AA.LOCAL_BLKS_READ)        LOCAL_BLKS_READ    
								    ,SUM(AA.LOCAL_BLKS_DIRTIED)     LOCAL_BLKS_DIRTIED 
								    ,SUM(AA.LOCAL_BLKS_WRITTEN)     LOCAL_BLKS_WRITTEN 
								    ,SUM(AA.TEMP_BLKS_READ)         TEMP_BLKS_READ     
								    ,SUM(AA.TEMP_BLKS_WRITTEN)      TEMP_BLKS_WRITTEN  
								    ,SUM(AA.BLK_READ_TIME)          BLK_READ_TIME      
								    ,SUM(AA.BLK_WRITE_TIME)         BLK_WRITE_TIME     
							    FROM TB_PG_STAT_STATEMENTS T
							    LEFT   JOIN LATERAL (
								       SELECT 	elem->>'userid' AS USERID 
											    ,elem->>'dbid'AS DBID 
											    ,(elem->>'queryid')::int8 AS QUERYID
											    ,(elem->>'calls')::int8 AS CALLS
											    ,(elem->>'total_time')::NUMERIC(20,2) AS TOTAL_TIME 
											    ,(elem->>'min_time')::NUMERIC(20,2) AS MIN_TIME 
											    ,(elem->>'max_time')::NUMERIC(20,2) AS MAX_TIME 
											    ,(elem->>'mean_time')::NUMERIC(20,2) AS MEAN_TIME
											    ,(elem->>'stddev_time')::NUMERIC(20,2) AS STDDEV_TIME
											    ,(elem->>'rows')::int8 AS ROWS 
											    ,(elem->>'shared_blks_hit')::int8 AS SHARED_BLKS_HIT
											    ,(elem->>'shared_blks_read')::int8 AS SHARED_BLKS_READ 
											    ,(elem->>'shared_blks_dirtied')::int8 AS SHARED_BLKS_DIRTIED
											    ,(elem->>'shared_blks_written')::int8 AS SHARED_BLKS_WRITTEN
											    ,(elem->>'local_blks_hit')::int8 AS LOCAL_BLKS_HIT 
											    ,(elem->>'local_blks_read')::int8 AS LOCAL_BLKS_READ
											    ,(elem->>'local_blks_dirtied')::int8 AS LOCAL_BLKS_DIRTIED 
											    ,(elem->>'local_blks_written')::int8 AS LOCAL_BLKS_WRITTEN 
											    ,(elem->>'temp_blks_read')::int8 AS TEMP_BLKS_READ 
											    ,(elem->>'temp_blks_written')::int8 AS TEMP_BLKS_WRITTEN
											    ,(elem->>'blk_read_time')::NUMERIC(20,2) AS BLK_READ_TIME
											    ,(elem->>'blk_write_time')::NUMERIC(20,2) AS BLK_WRITE_TIME 
								       FROM   JSONB_ARRAY_ELEMENTS(T.PGSS) A(ELEM)   
							       ) AA ON TRUE
					     WHERE COLLECT_DT {1}
                 AND REG_DATE {2}
                 AND T.INSTANCE_ID IN ({0})
               GROUP BY T.INSTANCE_ID, T.COLLECT_DT, AA.DBID, AA.QUERYID
     )
     , STATS AS (
           	SELECT  
	          		MAXD.INSTANCE_ID, 
	          		MAXD.COLLECT_DT,
					      --MAXD.DBID,
                GREATEST(SUM(MAXD.CALLS),1) AS SUM_CALLS,
                GREATEST(SUM(MAXD.TOTAL_TIME),1) AS SUM_TOTAL_TIME,
                GREATEST(SUM(MAXD.BLK_READ_TIME+MAXD.BLK_WRITE_TIME),1) AS IO_TIME,
                GREATEST(SUM(MAXD.TOTAL_TIME-MAXD.BLK_READ_TIME-MAXD.BLK_WRITE_TIME),1) AS CPU_TIME,
                GREATEST(SUM(MAXD.ROWS),1)  AS SUM_ROWS
	         FROM   MAXD
	         --GROUP BY INSTANCE_ID, COLLECT_DT, DBID
	         GROUP BY INSTANCE_ID, COLLECT_DT
    )    
	  SELECT 
	           PGS.COLLECT_DT, PGS.DBID, PGS.QUERYID, 
	           PGS.CALLS, 
	           STATS.SUM_CALLS,
	           PGS.TOTAL_TIME,
	           ROUND(100*(PGS.TOTAL_TIME-PGS.BLK_READ_TIME-PGS.BLK_WRITE_TIME)/STATS.CPU_TIME,2) AS CPU_TIME,
	           (100*(PGS.BLK_READ_TIME+PGS.BLK_WRITE_TIME)/STATS.IO_TIME) AS IO_TIME,
	           ROUND(100*PGS.ROWS/SUM_ROWS,2) AS ROWS
					  --FROM MAXD PGS JOIN STATS ON PGS.COLLECT_DT = STATS.COLLECT_DT AND PGS.DBID = STATS.DBID
            FROM MAXD PGS JOIN STATS ON PGS.COLLECT_DT = STATS.COLLECT_DT
	  WHERE PGS.DBID::TEXT || QUERYID::TEXT IN ({3})
	  ORDER BY PGS.COLLECT_DT, {4}
      ]]>
    </DATA>
  </ROW>  
  <ROW ID="SELECTAUTOVACUUMWORKER" PARAMS="0">
    <DESC>PT_04_10_001(SELECTAUTOVACUUMWORKER)</DESC>
    <DATA>
      <![CDATA[
--      SELECT COLLECT_DT, COUNT(AVA.COMMON) AS COMMON, SUM(AVA.WRAPAROUND) AS WRAPAROUND
--        FROM (
--              SELECT	/* SELECTAUTOVACUUMWORKER */ 
--       			         C.COLLECT_DT AS COLLECT_DT,
--        		         C.SQL AS SQL,
--        		         CASE WHEN C.SQL LIKE 'prevent wraparound' THEN 1 ELSE 0 END AS WRAPAROUND,
--        		         C.SQL AS COMMON
--                FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B, TB_BACKEND_RSC C
--               WHERE B.REG_DATE {1}
--                 AND A.INSTANCE_ID = B.INSTANCE_ID       
--                 AND A.INSTANCE_ID IN ({0})
--                 AND A.COLLECT_YN = 'Y'
--                 AND A.DELETE_YN = 'N'
--                 AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
--                 AND B.REG_DATE = C.REG_DATE
--                 AND C.SQL LIKE 'autovacuum:%'
--                 AND C.COLLECT_DT {2}
--              ) AS AVA
--        GROUP BY COLLECT_DT
--        ORDER BY COLLECT_DT        
--      SELECT  COLLECT_DATE,
--  	      MAX(COMMON) COMMON,
--  	      MAX(WRAPAROUND) WRAPAROUND
--        FROM (
--                SELECT 
--      		    --COLLECT_DT,
--      		    TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {3} )) * {3}) AT TIME ZONE 'UTC' AS COLLECT_DATE,
--      		    COUNT(AVA.COMMON) AS COMMON, SUM(AVA.WRAPAROUND) AS WRAPAROUND
--                  FROM (
--              		    SELECT	/* SELECTAUTOVACUUMWORKER */ 
--       			             C.COLLECT_DT AS COLLECT_DT,
--        		             C.SQL AS SQL,
--        		             CASE WHEN C.SQL LIKE 'prevent wraparound' THEN 1 ELSE 0 END AS WRAPAROUND,
--        		             C.SQL AS COMMON
--	                     FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B, TB_BACKEND_RSC C
--	                    WHERE B.REG_DATE {1}
--	                      AND A.INSTANCE_ID = B.INSTANCE_ID       
--	                      AND A.INSTANCE_ID IN ({0})
--	                      AND A.COLLECT_YN = 'Y'
--	                      AND A.DELETE_YN = 'N'
--	                      AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
--	                      AND B.REG_DATE = C.REG_DATE
--	                      AND C.SQL LIKE 'autovacuum:%'
--	                      AND C.COLLECT_DT {2}
--                  ) AS AVA
--                  GROUP BY COLLECT_DT
--	                ORDER BY COLLECT_DT
--            ) ROLL
--      GROUP BY COLLECT_DATE
--      ORDER BY COLLECT_DATE

--	   SELECT  COLLECT_DATE,
--  	      MAX(COMMON) COMMON,
--  	      MAX(WRAPAROUND) WRAPAROUND
--        FROM (
--                SELECT 
--      		    --COLLECT_DT,
--      		    TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {3} )) * {3}) AT TIME ZONE 'UTC' AS COLLECT_DATE,
--      		    COUNT(AVA.COMMON) AS COMMON, SUM(AVA.WRAPAROUND) AS WRAPAROUND
--                  FROM (
--              		    SELECT	/* SELECTAUTOVACUUMWORKER */ 
--       			             C.COLLECT_DT AS COLLECT_DT,
--        		             C.SQL AS SQL,
--        		             CASE WHEN C.SQL LIKE 'prevent wraparound' THEN 1 ELSE 0 END AS WRAPAROUND,
--        		             C.SQL AS COMMON
--	                     FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B, TB_BACKEND_RSC C
--	                    WHERE B.REG_DATE {1}
--	                      AND A.INSTANCE_ID = B.INSTANCE_ID       
--	                      AND A.INSTANCE_ID IN ({0})
--	                      AND A.COLLECT_YN = 'Y'
--	                      AND A.DELETE_YN = 'N'
--	                      AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
--	                      AND B.REG_DATE = C.REG_DATE
--	                      AND C.SQL LIKE 'autovacuum:%'
--	                      AND C.COLLECT_DT {2}
--	                UNION ALL
--	                    SELECT	 
--       			            (TO_CHAR(TO_DATE(B.REG_DATE, 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || B.REG_TIME)::timestamp AS COLLECT_DT,
--        		             NULL AS SQL,
--        		             0 AS WRAPAROUND,
--        		             NULL AS COMMON
--	                     FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B
--	                    WHERE B.REG_DATE  {1}
--	                      AND A.INSTANCE_ID = B.INSTANCE_ID       
--	                      AND A.INSTANCE_ID IN ({0})
--	                      AND A.COLLECT_YN = 'Y'
--	                      AND A.DELETE_YN = 'N'
--	                      AND TO_CHAR(TO_DATE(B.REG_DATE, 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || B.REG_TIME {2}
--                  ) AS AVA
--                  GROUP BY COLLECT_DT
--	                ORDER BY COLLECT_DT
--            ) ROLL
--      GROUP BY COLLECT_DATE
--      ORDER BY COLLECT_DATE

SELECT  COLLECT_DATE,
  MAX(COMMON) COMMON,
  MAX(WRAPAROUND) WRAPAROUND
FROM (
        SELECT 
	    TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {3} )) * {3}) AT TIME ZONE 'UTC' AS COLLECT_DATE,
	    COUNT(AVA.COMMON) AS COMMON, SUM(AVA.WRAPAROUND) AS WRAPAROUND
          FROM (       
                 WITH Q AS
                 (
                  SELECT QUERYID, QUERY FROM TB_QUERY_INFO 
                  WHERE REG_DATE {1}
                    AND INSTANCE_ID IN ({0})
                    AND QUERY LIKE '%autovacuum:%'
                 )
                 SELECT	/* SELECTAUTOVACUUMWORKER */ 
		             C.COLLECT_DT AS COLLECT_DT,
		             Q.QUERY AS SQL,
		             CASE WHEN Q.QUERY LIKE '%prevent wraparound%' THEN 1 ELSE 0 END AS WRAPAROUND,
		             Q.QUERY AS COMMON        		             
                 FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B, TB_BACKEND_RSC C, q
                WHERE B.REG_DATE {1}
                  and C.REG_DATE {1}
                  AND B.REG_DATE = C.REG_DATE
                  AND B.ACTV_REG_SEQ = C.ACTV_REG_SEQ
                  AND A.INSTANCE_ID = B.INSTANCE_ID       
                  AND A.INSTANCE_ID IN ({0})
                  AND A.COLLECT_YN = 'Y'
                  AND A.DELETE_YN = 'N'
                  AND (TO_CHAR(TO_DATE(B.REG_DATE, 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || B.REG_TIME)::timestamp {2}
                  AND C.QUERYID = Q.QUERYID	                      
            UNION ALL
                SELECT	 
		            (TO_CHAR(TO_DATE(B.REG_DATE, 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || B.REG_TIME)::timestamp AS COLLECT_DT,
		             NULL AS SQL,
		             0 AS WRAPAROUND,
		             NULL AS COMMON
                 FROM TB_INSTANCE_INFO A, TB_ACTV_COLLECT_INFO B
                WHERE B.REG_DATE {1}
                  AND A.INSTANCE_ID = B.INSTANCE_ID       
                  AND A.INSTANCE_ID IN ({0})
                  AND A.COLLECT_YN = 'Y'
                  AND A.DELETE_YN = 'N'
                  AND TO_CHAR(TO_DATE(B.REG_DATE, 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || B.REG_TIME {2}
              ) AS AVA
              GROUP BY COLLECT_DT
                ORDER BY COLLECT_DT
        ) ROLL
GROUP BY COLLECT_DATE
ORDER BY COLLECT_DATE
      ]]>
    </DATA>
  </ROW>  
  <ROW ID="SELECTAUTOVACUUMTOP" PARAMS="0">
    <DESC>PT_04_10_001(SELECTAUTOVACUUMTOP)</DESC>
    <DATA>
      <![CDATA[               
	    WITH 
	    INS AS (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N' ),
	    STARTSEQ AS (				                  
	    		SELECT min(C.objt_reg_seq) objt_reg_seq
                  FROM INS A, TB_OBJT_COLLECT_INFO B, TB_TABLE_EXT_INFO C
	             WHERE A.INSTANCE_ID = B.INSTANCE_ID
				   AND A.INSTANCE_ID = C.INSTANCE_ID
	               AND A.INSTANCE_ID IN ({0})
	               AND B.OBJT_REG_SEQ = C.OBJT_REG_SEQ
	               AND B.REG_DATE = to_char('{1}'::date, 'YYYYMMDD')
	               AND B.REG_DATE = C.REG_DATE
				   AND B.REG_TIME >= '{1}'::time
		),
		ENDSEQ AS (
	            SELECT max(C.objt_reg_seq) objt_reg_seq
                  FROM INS A, TB_OBJT_COLLECT_INFO B, TB_TABLE_EXT_INFO C
			     WHERE A.INSTANCE_ID = B.INSTANCE_ID
   				   AND A.INSTANCE_ID = C.INSTANCE_ID
			       AND A.INSTANCE_ID IN ({0})
		           AND B.OBJT_REG_SEQ = C.OBJT_REG_SEQ
		           AND B.REG_DATE = to_char('{2}'::date, 'YYYYMMDD')
		           AND B.REG_DATE = C.REG_DATE
		           AND B.REG_TIME <= '{2}'::time
		),
		TBLSEQ AS (
          SELECT max(C.objt_reg_seq) objt_reg_seq
            FROM INS A, TB_OBJT_COLLECT_INFO B, TB_TABLE_EXT_INFO C
			             WHERE A.INSTANCE_ID = B.INSTANCE_ID
			               AND A.INSTANCE_ID = C.INSTANCE_ID
			               AND A.INSTANCE_ID IN ({0})
			               AND B.OBJT_REG_SEQ = C.OBJT_REG_SEQ
			               AND B.REG_DATE = to_char('{1}'::date, 'YYYYMMDD')
			               AND B.REG_DATE = C.REG_DATE
			               AND B.REG_TIME >= '{1}'::time
			             GROUP BY A.INSTANCE_ID
		),
		OLDEST AS (
		        SELECT OBJT_REG_SEQ, COLLECT_DT, RELID, AUTOVACUUM_COUNT, AUTOANALYZE_COUNT
			      FROM tb_table_ext_info
				 WHERE REG_DATE = to_char('{1}'::date, 'YYYYMMDD')
				   AND objt_reg_seq = (SELECT * FROM STARTSEQ)
            	   AND COLLECT_DT::date = '{1}'::date
		),
		RECENT AS (
				SELECT OBJT_REG_SEQ, COLLECT_DT, RELID, AUTOVACUUM_COUNT, AUTOANALYZE_COUNT
	              FROM tb_table_ext_info
				 WHERE REG_DATE = to_char('{2}'::date, 'YYYYMMDD')
				   AND objt_reg_seq = (SELECT * FROM ENDSEQ)
				   AND COLLECT_DT::date = '{2}'::date
				),
		TBI AS (
				SELECT DB_NAME, SCHEMA_NAME, TABLE_NAME, RELID
			        FROM TB_TABLE_INFO
			       WHERE objt_reg_seq in (SELECT * FROM TBLSEQ)
			    )
		SELECT /*SELECTAUTOVACUUMTOP*/ 
               DB_NAME, SCHEMA_NAME, TABLE_NAME, R.RELID,
			   (COALESCE(R.autovacuum_count,0) - COALESCE(O.autovacuum_count,0)) ROV,
			   (COALESCE(R.autovacuum_count,0) - COALESCE(O.autovacuum_count,0)) ROA
          FROM RECENT R LEFT OUTER JOIN OLDEST O ON R.relid = O.relid, TBI TI
         WHERE TI.RELID = R.RELID
         ORDER BY ROV DESC, R.autovacuum_count DESC, ROA DESC, RELID
	     LIMIT {3}
     ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTAUTOVACUUMCOUNT" PARAMS="0">
    <DESC>PT_04_10_001(SELECTAUTOVACUUMTOP)</DESC>
    <DATA>
      <![CDATA[    
      	WITH TTI AS (
			    SELECT RELID, db_name || '.' || schema_name || '.' || table_name AS table_name
			      FROM TB_TABLE_INFO
			     WHERE RELID IN ({3})
             AND REG_DATE {1}
			     ORDER BY OBJT_REG_SEQ DESC
			     LIMIT (SELECT count(*)+1 FROM regexp_matches('{3}', ',', 'g'))
		    )
        SELECT COLLECT_DATE, relid, AUTOVACUUM_COUNT,
	           COALESCE(AUTOVACUUM_COUNT - LAG(AUTOVACUUM_COUNT) over (PARTITION BY relid ORDER BY COLLECT_DATE), 0) as DIFF, TABLE_NAME
          FROM (
			            SELECT TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {4} )) * {4}) AT TIME ZONE 'UTC' AS COLLECT_DATE, 
					            RELID, 
					            max(AUTOVACUUM_COUNT) AUTOVACUUM_COUNT, TABLE_NAME
			              FROM	(
				                     SELECT TTEI.COLLECT_DT, TTEI.RELID, TTEI.AUTOVACUUM_COUNT AS AUTOVACUUM_COUNT, TTI.TABLE_NAME
				                       FROM TB_INSTANCE_INFO TII, TB_OBJT_COLLECT_INFO TOC, TB_TABLE_EXT_INFO TTEI, TTI
				                      WHERE TII.COLLECT_YN = 'Y'
				                        AND TII.DELETE_YN = 'N'
				                        AND TII.INSTANCE_ID IN ({0})
                                AND TII.INSTANCE_ID = TTEI.INSTANCE_ID 
				                        AND TII.INSTANCE_ID = TOC.INSTANCE_ID
				                        AND TOC.REG_DATE {1}
                                AND TTEI.COLLECT_DT {2}
			     		                  AND TOC.OBJT_REG_SEQ = TTEI.OBJT_REG_SEQ
			     		                  AND TTEI.RELID IN ({3})
                                AND TTEI.RELID = TTI.RELID
                            UNION ALL
                             SELECT (TO_CHAR(TO_DATE(TOC.REG_DATE, 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || TOC.REG_TIME)::timestamp as COLLECT_DT, 
						                        null AS RELID, 0 AS AUTOVACUUM_COUNT, null AS TABLE_NAME
					                     FROM TB_INSTANCE_INFO TII, TB_OBJT_COLLECT_INFO TOC
					                    WHERE TII.COLLECT_YN = 'Y'
					                      AND TII.DELETE_YN = 'N'
					                      AND TII.INSTANCE_ID IN ({0})
					                      AND TII.INSTANCE_ID = TOC.INSTANCE_ID
					                      AND TOC.REG_DATE {1}
					            		      AND (TO_CHAR(TO_DATE(TOC.REG_DATE, 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || TOC.REG_TIME)::timestamp {2}
						                ORDER BY COLLECT_DT, RELID
					            ) AS COLLECTION
			              GROUP BY COLLECT_DATE, RELID, TABLE_NAME
			              ORDER BY COLLECT_DATE, RELID
		           ) AS DIFF
               ORDER BY COLLECT_DATE, RELID
     ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTDATABASES" PARAMS="0">
    <DESC>PT_04_10_001(SELECTDATABASES)</DESC>
    <DATA>
      <![CDATA[               
	       SELECT db_name
			     FROM TB_TABLE_INFO TTI
			    WHERE TTI.OBJT_REG_SEQ = (SELECT max(OBJT_REG_SEQ) OBJT_REG_SEQ FROM TB_OBJT_COLLECT_INFO WHERE INSTANCE_ID = {0} AND REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD'))
			      AND REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
			    GROUP BY db_name;
     ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTAUTOVACUUMWRAPAROUND" PARAMS="0">
    <DESC>PT_04_10_001(SELECTAUTOVACUUMWRAPAROUND)</DESC>
    <DATA>
      <![CDATA[               
     WITH TTI AS	(
	         SELECT db_name, max(relid) relid
		        FROM TB_TABLE_INFO TTI
		       WHERE TTI.OBJT_REG_SEQ = (SELECT max(OBJT_REG_SEQ) OBJT_REG_SEQ FROM TB_OBJT_COLLECT_INFO WHERE INSTANCE_ID = {0} AND REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD'))
		         AND REG_DATE = TO_CHAR(NOW(), 'YYYYMMDD')
		       GROUP BY db_name
     )
      SELECT COLLECT_DATE, DB_NAME, MAXAGE
        FROM (
		          SELECT --TTEI.COLLECT_DT, 
		    	         TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {2} )) * {2}) AT TIME ZONE 'UTC' AS COLLECT_DATE,
		                 TTI.DB_NAME, MAX(TTEI.MAXAGE)/(1024*1024) MAXAGE
		            FROM TB_TABLE_EXT_INFO TTEI, TTI
		           WHERE TTEI.INSTANCE_ID = {0} 
		             AND TTEI.COLLECT_DT {1} --BETWEEN '2018-12-21 14:17:26'::timestamp AND '2018-12-21 20:17:26'::timestamp 
		             AND TTI.RELID = TTEI.RELID
		           GROUP BY COLLECT_DATE, TTEI.RELID, TTI.DB_NAME
		           ORDER BY COLLECT_DATE, TTEI.RELID
		      ) AS ROLL
     ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTCURRENTSTATEMENTS" PARAMS="0">
    <DESC>PT_04_09_001(OBJECT 정보)</DESC>
    <DATA>
      <![CDATA[
  		  WITH L AS
        (
         SELECT MAX(COLLECT_DT) COLLECTDT
	          FROM TB_REALTIME_STATEMENTS 
	         WHERE COLLECT_DT > NOW() - INTERVAL '120' and reg_time >= TO_CHAR(NOW() - INTERVAL '120', 'YYYYMMDDHH24')
        ),
        R AS
        (
         SELECT *
	          FROM TB_REALTIME_STATEMENTS T JOIN L ON T.COLLECT_DT = L.COLLECTDT
        )
        SELECT /*SELECTCURRENTSTATEMENTS*/
                R.INSTANCE_ID, R.CQUERYID,
                U.USER_NAME, 
                D.DATABASE_NAME, 
                COALESCE(Q.QUERY, '') QUERY, 
                CALLS, 
                TOTAL_TIME AS TOTAL_TIME, 
                TOTAL_TIME  / CALLS AS AVG_TIME, 
                R.COLLECT_DT
        FROM R
        JOIN TB_PGSS_QUERY_INFO Q ON R.INSTANCE_ID = Q.INSTANCE_ID AND R.CQUERYID = Q.QUERYID
        JOIN TB_USER_INFO U ON R.INSTANCE_ID = U.INSTANCE_ID AND R.USERID = U.USER_ID
        JOIN TB_DATABASE_INFO D ON R.INSTANCE_ID = D.INSTANCE_ID AND R.DBID = D.DATID 
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTCURRENTSTATEMENTSDURATION" PARAMS="0">
    <DESC>PT_04_09_001(OBJECT 정보)</DESC>
    <DATA>
      <![CDATA[
        SELECT /*SELECTCURRENTSTATEMENTSDURATION*/
                R.INSTANCE_ID, 
                U.USER_NAME, 
                D.DATABASE_NAME, 
                Q.QUERY, 
                CALLS, 
                TOTAL_TIME AS TOTAL_TIME, 
                TOTAL_TIME  / CALLS AS AVG_TIME
        FROM
         (
	        SELECT instance_id, dbid, userid, queryid, sum(calls) calls, max(TOTAL_TIME) total_time, CQUERYID
	          FROM TB_REALTIME_STATEMENTS 
	         WHERE COLLECT_DT BETWEEN '{1}' AND '{2}' and INSTANCE_ID = {0}
			GROUP BY instance_id, dbid, userid, QUERYID, CQUERYID
         ) AS R
        --JOIN TB_QUERY_INFO Q ON R.INSTANCE_ID = Q.INSTANCE_ID AND R.CQUERYID = Q.QUERYID
        JOIN TB_PGSS_QUERY_INFO Q ON R.INSTANCE_ID = Q.INSTANCE_ID and R.CQUERYID = Q.QUERYID 
        JOIN TB_USER_INFO U ON R.INSTANCE_ID = U.INSTANCE_ID AND R.USERID = U.USER_ID
        JOIN TB_DATABASE_INFO D ON R.INSTANCE_ID = D.INSTANCE_ID AND R.DBID = D.DATID
        ORDER BY CALLS DESC
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTALERTLINKCONFIG" PARAMS="1">
    <DATA>
    <![CDATA[
      SELECT * FROM TB_ALERT_LINK_CONFIG {0} ORDER BY LAST_MOD_DT DESC;
    ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTALERTLINKCONFIG" PARAMS="12">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
		  INSERT INTO TB_ALERT_LINK_CONFIG
      (
      link_type
      ,link_ip
      ,link_port
      ,link_id
      ,link_password
      ,link_database
      ,link_statements
      ,notification_sender
      ,last_mod_dt
      ,last_mod_ip
      )(SELECT 
		   {0}
		   ,'{1}'
		   ,{2}
		   ,'{3}'
		   ,'{4}'
		   ,'{5}'
		   ,'{6}'
       ,'{7}'
		   ,now()
		   ,'{8}'
		  ) ON CONFLICT (link_type) 
      DO UPDATE SET 
		   link_ip = '{1}'
		   ,link_port = {2}
	     ,link_id = '{3}'
	     ,link_password = '{4}'
	     ,link_database ='{5}'
	     ,link_statements = '{6}'
       ,notification_sender = '{7}'
	     ,last_mod_dt = now()
	     ,last_mod_ip = '{8}'
    ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTMONUSERGROUP" PARAMS="0">
    <DATA>
    <![CDATA[
      SELECT * FROM TB_MON_GROUP
      ORDER BY GROUP_ID
    ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTMONUSERGROUP" PARAMS="3">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
		  INSERT INTO TB_MON_GROUP
      (
       group_name
      ,last_mod_user_id
      ,last_mod_dt
      ,last_mod_ip
      )(SELECT 
		    '{0}'
		   ,'{1}'
		   ,now()
		   ,'{2}'
		  );
    ]]>
    </DATA>
  </ROW>
  <ROW ID="UPDATEMONUSERGROUP" PARAMS="4">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
        UPDATE TB_MON_GROUP SET
         group_name = '{1}'
        ,last_mod_user_id = '{2}'
        ,last_mod_dt = now()
        ,last_mod_ip = '{3}'
        WHERE group_id = {0}
    ]]>
    </DATA>
  </ROW>  
  <ROW ID="DELETEMONUSERGROUP" PARAMS="1">
    <DESC>필수입력 사항이 누락 되었을때 사용</DESC>
    <DATA>
      <![CDATA[
        DELETE FROM TB_MON_GROUP 
        WHERE group_id = {0}
    ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTUSERBYGROUP" PARAMS="0">
    <DATA>
    <![CDATA[
      SELECT U.*, CASE WHEN USER_NOTI_PHONE = 0 THEN USER_PHONE ELSE USER_PHONE2 END USER_SEL_PHONE
        FROM TB_MON_USER_BY_GROUP G JOIN TB_MON_USER U ON G.USER_ID = U.USER_ID
       WHERE G.GROUP_ID = {0};
    ]]>
    </DATA>
  </ROW>
  <ROW ID="DELETEUSERBYGROUP" PARAMS="2">
    <DESC></DESC>
    <DATA>
      <![CDATA[
     DELETE FROM TB_MON_USER_BY_GROUP 
      WHERE user_id in ({0})
        AND group_id = {1}
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="INSERTUSER" PARAMS="13">
    <DESC></DESC>
    <DATA>
      <![CDATA[
		  INSERT INTO TB_MON_USER 
      (user_id,
      user_name,
      user_password,
      user_phone,
      user_phone2,
      user_noti_phone,
      user_email,
      user_empnum,
      user_dept_name,
      is_admin_tf, 
      is_locked_tf, 
      set_pw_dt,
      last_mod_user_id,
      last_mod_ip,
      last_mod_dt
      )
      values
      ('{0}'
		   ,'{1}'
		   ,'{2}'
		   ,'{3}'
		   ,'{4}'
		   ,{5}
       ,'{6}'
       ,'{7}'
       ,'{8}'
       ,{9}
       ,{10}
       ,now()
       ,'{11}'
       ,'{12}'
		   ,now()
		  ) 
    ]]>
    </DATA>
  </ROW>
  <ROW ID="UPDATEUSER" PARAMS="8">
    <DESC></DESC>
    <DATA>
      <![CDATA[
     UPDATE TB_MON_USER SET 
          USER_NAME = '{1}',
          USER_PHONE = '{2}',
          USER_PHONE2 = '{3}',
          user_noti_phone = {4},
          USER_EMAIL = '{5}',
          USER_EMPNUM = '{6}',
          USER_DEPT_NAME = '{7}',
          LAST_MOD_IP = '{8}',
          LAST_MOD_DT = now()
      WHERE USER_ID = '{0}'
    ]]>
    </DATA>
  </ROW>

  <ROW ID="UPDATEUSERADMIN" PARAMS="10">
    <DESC></DESC>
    <DATA>
      <![CDATA[
     UPDATE TB_MON_USER SET 
          USER_NAME = '{1}',
          USER_PHONE = '{2}',
          USER_PHONE2 = '{3}',
          user_noti_phone = {4},
          USER_EMAIL = '{5}',
          USER_EMPNUM = '{6}',
          USER_DEPT_NAME = '{7}',
          IS_ADMIN_TF = {8}::BOOL,
          IS_LOCKED_TF = {9}::BOOL,
          LAST_MOD_IP = '{10}',
          LAST_MOD_DT = now()
      WHERE USER_ID = '{0}'
    ]]>
    </DATA>
  </ROW>

  <ROW ID="DELETEUSER" PARAMS="1">
    <DESC></DESC>
    <DATA>
      <![CDATA[
     UPDATE TB_MON_USER SET 
          IS_DELETED = true,
          LAST_MOD_IP = '{1}',
          LAST_MOD_DT = now()
      WHERE user_id = '{0}'
    ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTUSER" PARAMS="1">
    <DATA>
    <![CDATA[
      SELECT  USER_ID,
              USER_NAME,
              USER_PASSWORD,
              USER_PHONE,
	            USER_PHONE2,
              CASE WHEN USER_NOTI_PHONE = 0 THEN USER_PHONE ELSE USER_PHONE2 END USER_SEL_PHONE,
	            USER_NOTI_PHONE,
	            USER_EMAIL,
	            USER_EMPNUM,
	            USER_DEPT_NAME,
	            CASE WHEN IS_ADMIN_TF THEN 'Admin' ELSE '' END AS USER_ADMIN,
	            LAST_LOGIN_DT,
	            SET_PW_DT,
              CASE WHEN IS_LOCKED_TF THEN 'Locked' ELSE '' END IS_LOCKED_TF
      FROM TB_MON_USER U
       WHERE IS_DELETED = FALSE
         AND USER_ID NOT in (SELECT USER_ID FROM TB_MON_USER_BY_GROUP WHERE GROUP_ID = {0})
         ORDER BY USER_SEQ
    ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTUSERGROUP" PARAMS="4">
    <DESC></DESC>
    <DATA>
      <![CDATA[
		  INSERT INTO TB_MON_USER_BY_GROUP 
      (
      user_id,
      group_id,
      last_mod_user_id,
      last_mod_ip,
      last_mod_dt
      )
      values
      ('{0}'
		   ,'{1}'
		   ,'{2}'
		   ,'{3}'
       ,now()
		  ) 
    ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTNOTIFICATIONHISTORY" PARAMS="4">
    <DATA>
    <![CDATA[
      SELECT EXPORT_TYPE, 
	         TA.INSTANCE_ID,
	         CASE WHEN {0}=0 THEN IST.HOST_NAME ELSE IST.CONN_NAME END AS SERVER_NAME, 
	         SENDER,
	         RECIEVER,
	         EXPORT_LEVEL,
	         MESSAGES,
	         COLLECT_DT,
	         CASE WHEN ISSUCCESS THEN 'Success' ELSE 'Failure' END AS ISSUCCESS,
	         ERROR,
	         TU.USER_NAME
        FROM TB_ALERT_EXPORT_INFO TA, TB_INSTANCE_INFO IST, TB_MON_USER TU
       WHERE TA.INSTANCE_ID = IST.INSTANCE_ID
         AND TU.USER_ID = TA.USER_ID
         AND TA.COLLECT_DT BETWEEN '{1}' AND '{2}'
         AND IST.INSTANCE_ID IN ({3})
         AND TA.EXPORT_LEVEL >= {4}
    ]]>
    </DATA>
  </ROW>  
  <ROW ID="SELECTPRIVILEGES" PARAMS="0">
    <DATA>
      <![CDATA[
      SELECT *
        FROM TB_MON_PERM
    ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTPRIVILEGESBYUSER" PARAMS="1">
    <DATA>
      <![CDATA[
      SELECT re.*, group_name 
        FROM crosstab(' SELECT l.group_id, l.perm_id, CASE WHEN pu.USER_ID = ''{0}'' THEN 1 ELSE 0 END privilege 
  					              FROM (SELECT group_id, perm_id FROM tb_group_info g, tb_mon_perm p ORDER BY group_id, perm_id) l 
                                LEFT OUTER JOIN TB_MON_PERM_BY_USER pu ON pu.GROUP_ID = l.group_id AND pu.PERM_ID = l.perm_id AND pu.USER_ID = ''{0}''
 				                 ORDER BY l.group_id, l.perm_id') AS re (GROUP_id integer, Detailed_Monitoring int, SQL_plan int, Cancel_query int, Kill_session int)
        JOIN tb_group_info g ON re.group_id = g.group_id;
    ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTALLOWIP" PARAMS="0">
    <DATA>
      <![CDATA[
      SELECT I.USER_ID, U.USER_NAME, I.ALLOW_IP, -1 AS TAG
        FROM TB_MON_USER_ALLOW_IP I JOIN TB_MON_USER U ON I.USER_ID =  U.USER_ID;
    ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTSECURITYCONFIG" PARAMS="0">
    <DATA>
      <![CDATA[
      SELECT * FROM TB_MON_USER_POLICY;
    ]]>
    </DATA>
  </ROW>
  <ROW ID="UPDATESECURITYCONFIG" PARAMS="5">
    <DATA>
      <![CDATA[
        UPDATE TB_MON_USER_POLICY SET
          LOGIN_FAIL_CNT = {0}
	        ,LOCK_TIMEOUT = {1}
	        ,LOCK_INACT_PERIOD = {2}
	        ,NONALPHANUMERIC_TF = {3}
	        ,ALLOW_DUP_LOGIN_TF = {4}
	        ,PW_MIN_LENGTH = {5}
	        ,PW_EXPR_DAYS = {6}
	        ,PW_EXPR_NOTI_DAYS = {7}
	        ,LAST_MOD_IP = '{8}'
	        ,LAST_MOD_DT = NOW()
      ]]>
    </DATA>
  </ROW>

  <ROW ID="CHECKLOGINFAILCOUNT" PARAMS="1">
    <DESC>Check Prev Login</DESC>
    <DATA>
      <![CDATA[
      SELECT ((SELECT LOCK_TIMEOUT * 60 FROM TB_MON_USER_POLICY) - EXTRACT('epoch' FROM (NOW() - ATTEMPT_DT))::NUMERIC(10,0))   AS TIMEOUT
        FROM TB_MON_LOGIN_ATTEMPTS 
       WHERE ATTEMPT_IP = '{0}' 
         AND ATTEMPT_CNT > (SELECT LOGIN_FAIL_CNT FROM TB_MON_USER_POLICY)
      ]]>
    </DATA>
  </ROW>
  
  <ROW ID="CHECKLOGIN" PARAMS="2">
    <DESC>Check Login</DESC>
    <DATA>
      <![CDATA[
      SELECT *,
            (set_pw_dt::date + (SELECT PW_EXPR_DAYS FROM TB_MON_USER_POLICY) < now()::date) isExpired,
	          (set_pw_dt::date + (SELECT PW_EXPR_DAYS-PW_EXPR_NOTI_DAYS FROM TB_MON_USER_POLICY) < now()::date) isExpiredNear,
            (set_pw_dt::date + (SELECT PW_EXPR_DAYS FROM TB_MON_USER_POLICY) - now()::date) UntilExpireDays,
            CASE WHEN USER_PASSWORD = '{1}' THEN 1 ELSE 0 END AS MATCHED
        FROM TB_MON_USER WHERE USER_ID = '{0}'
      ]]>
    </DATA>
  </ROW>

  <ROW ID="DOLOGIN" PARAMS="5">
    <DATA>
      <![CDATA[
        UPDATE TB_MON_USER 
           SET CURRENT_LOGIN_CNT = (SELECT CURRENT_LOGIN_CNT + 1 FROM TB_MON_USER WHERE USER_ID = '{0}'),
               LAST_LOGIN_DT = '{1}',
               LAST_MOD_IP = '{2}',
               LAST_MOD_DT = NOW()
          WHERE USER_ID = '{0}'
      ]]>
    </DATA>
  </ROW>

  <ROW ID="DOLOGOUT" PARAMS="2">
    <DATA>
      <![CDATA[
        UPDATE TB_MON_USER 
           SET LAST_LOGOUT_DT = CURRENT_TIMESTAMP,
               LAST_MOD_IP = '{1}',
               LAST_MOD_DT = CURRENT_TIMESTAMP
          WHERE USER_ID = '{0}'
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SETLOGINFAIL" PARAMS="1">
    <DATA>
      <![CDATA[
        INSERT INTO TB_MON_LOGIN_ATTEMPTS
        (
	        attempt_ip,
	        attempt_cnt,
	        attempt_dt
        ) VALUES 
        (
	        '{0}',
	        1,
	        now()
        ) ON CONFLICT(attempt_ip) DO UPDATE SET
	        attempt_cnt = (SELECT attempt_cnt + 1 FROM TB_MON_LOGIN_ATTEMPTS WHERE attempt_ip = '{0}'),
	        attempt_dt = now()
      ]]>
    </DATA>
  </ROW>
  <ROW ID="CLEARLOGINFAIL" PARAMS="1">
    <DATA>
      <![CDATA[
        DELETE FROM TB_MON_LOGIN_ATTEMPTS
        WHERE ATTEMPT_IP = '{0}'
      ]]>
    </DATA>
  </ROW>
  
  <ROW ID="SELECTUSERPERMISSION" PARAMS="1">
    <DESC>select user permission</DESC>
    <DATA>
      <![CDATA[
      SELECT * FROM TB_MON_PERM_BY_USER WHERE USER_ID = '{0}' ORDER BY GROUP_ID, PERM_ID
      ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTUSERPERMISSION" PARAMS="5">
    <DESC>select user permission</DESC>
    <DATA>
      <![CDATA[
      INSERT INTO TB_MON_PERM_BY_USER 
      (
	      USER_ID,
	      GROUP_ID,
	      PERM_ID,
	      LAST_MOD_USER_ID,
	      LAST_MOD_IP,
	      LAST_MOD_DT
      )
      VALUES 
      (
	      '{0}',
	      {1},
	      {2},
	      '{3}',
	      '{4}',
	      NOW()
      ) ON CONFLICT DO NOTHING
      ]]>
    </DATA>
  </ROW>  
  <ROW ID="DELETEUSERPERMISSION" PARAMS="3">
    <DESC>delte user permission</DESC>
    <DATA>
      <![CDATA[
      DELETE FROM TB_MON_PERM_BY_USER 
       WHERE USER_ID = '{0}' AND GROUP_ID = {1} AND PERM_ID = {2}; 
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  <ROW ID="SELECTMONUSERINFO" PARAMS="1">
    <DESC>PT_05_03_001(SELECTMONUSERINFO)</DESC>
    <DATA>
      <![CDATA[
        SELECT * FROM TB_MON_USER WHERE user_id = '{0}'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTMONUSERCONFIG" PARAMS="10">
    <DESC>INSERTMONUSERCONFIG</DESC>
    <DATA>
      <![CDATA[
      INSERT INTO TB_MON_USER_CONFIG
      (
        USER_ID,
        LANGUAGE,
        REFRESH_PERIOD,
        SOUND_PATH,
        SHOW_ALIAS_TF,
        REG_ACCOUNT_SQLPLAN_TF,
        STYLE_CPU,
        STYLE_CPU_DIRECTION_TF,
        STYLE_MEM,
        STYLE_MEM_DIRECTION_TF,
        STYLE_CPU_DSP,
        STYLE_MEM_DSP
      )
      VALUES 
      (
	      '{0}',
	      {1},
	      {2},
	      '{3}',
	      {4}::BOOL,
	      {5}::BOOL,
	      {6},
	      {7}::BOOL,
	      {8},
	      {9}::BOOL,
	      {10}::BOOL,
	      {11}::BOOL
      ) ON CONFLICT(USER_ID) DO UPDATE SET
        LANGUAGE = {1},
        REFRESH_PERIOD = {2},
        SOUND_PATH = '{3}',
        SHOW_ALIAS_TF = {4}::BOOL,
        REG_ACCOUNT_SQLPLAN_TF = {5}::BOOL,
        STYLE_CPU = {6},
        STYLE_CPU_DIRECTION_TF = {7}::BOOL,
        STYLE_MEM = {8},
        STYLE_MEM_DIRECTION_TF = {9}::BOOL,
        STYLE_CPU_DSP = {10}::BOOL,
        STYLE_MEM_DSP = {11}::BOOL
      ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTMONUSERCONFIGDEFAULT" PARAMS="1">
    <DESC>INSERTMONUSERCONFIGDEFAULT</DESC>
    <DATA>
      <![CDATA[
      INSERT INTO TB_MON_USER_CONFIG
      (
        USER_ID
      )
      VALUES 
      (
	      '{0}'
      )
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTMONUSERCONFIG" PARAMS="1">
    <DESC>PT_05_03_001(SELECTMONUSERCONFIG)</DESC>
    <DATA>
      <![CDATA[
        SELECT * FROM TB_MON_USER_CONFIG WHERE USER_ID = '{0}'
      ]]>
    </DATA>
  </ROW>

  <ROW ID="INSERTALLOWIP" PARAMS="2">
    <DESC>INSERTALLOWIP</DESC>
    <DATA>
      <![CDATA[
      INSERT INTO TB_MON_USER_ALLOW_IP 
      (
	      USER_ID,
	      ALLOW_IP
      )
      VALUES 
      (
	      '{0}',
	      '{1}'
      ) ON CONFLICT DO NOTHING
      ]]>
    </DATA>
  </ROW>
  <ROW ID="DELETEALLOWIP" PARAMS="2">
    <DESC>DELETEALLOWIP</DESC>
    <DATA>
      <![CDATA[
      DELETE FROM TB_MON_USER_ALLOW_IP 
       WHERE USER_ID = '{0}' AND ALLOW_IP = '{1}' 
      ]]>
    </DATA>
    <COMMENTS />
  </ROW>
  
  <ROW ID="CHECKALLOWIP" PARAMS="1">
    <DESC>PT_05_03_001(CHECKALLOWIP)</DESC>
    <DATA>
      <![CDATA[
        SELECT * FROM TB_MON_USER_ALLOW_IP WHERE USER_ID = '{0}'
      ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTUSERACCESSINFO" PARAMS="6">
    <DESC>INSERTUSERACCESSINFO</DESC>
    <DATA>
      <![CDATA[
      INSERT INTO TB_MON_USER_AUDIT 
      (
	      USER_ID,
	      ACCESS_DT,
	      ACCESS_TYPE,
	      INSTANCE_ID,
	      ACCESS_STATUS,
	      ACCESS_LOG,
	      ACCESS_IP
      ) VALUES (
	      '{0}',
	       NOW(),
	      '{1}',
	       {2},
	       {3},
	      '{4}',
	      '{5}'
      );
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTUSERACCESSINFO" PARAMS="3">
    <DESC>PT_05_03_001(SELECTUSERACCESSINFO)</DESC>
    <DATA>
      <![CDATA[
         SELECT A.USER_ID, U.USER_NAME, 
               A.ACCESS_DT, ACCESS_TYPE,
               A.ACCESS_IP, I.HOST_NAME, I.SERVER_IP,
               CASE WHEN A.ACCESS_STATUS = 0 THEN 'Success' ELSE 'Error' END ACCESS_STATUS,
               A.ACCESS_LOG
          FROM TB_MON_USER_AUDIT A JOIN TB_MON_USER U ON U.USER_ID = A.USER_ID LEFT OUTER JOIN TB_INSTANCE_INFO I ON A.INSTANCE_ID = I.INSTANCE_ID
        WHERE A.ACCESS_DT BETWEEN '{0}' AND '{1}'
        {2} ORDER BY A.ACCESS_DT DESC
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SETOPTIONS" PARAMS="2">
    <DESC>PT_05_03_001(SETOPTIONS)</DESC>
    <DATA>
      <![CDATA[
        set {0} to {1};
      ]]>
    </DATA>
  </ROW>
  <ROW ID="GETOPTIONS" PARAMS="1">
    <DESC>PT_05_03_002(GETOPTIONS)</DESC>
    <DATA>
      <![CDATA[
        SELECT current_setting('{0}') as {0};
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTSNAPSHOTPERIOD" PARAMS="1">
    <DESC>(SELECTSNAPSHOTPERIOD)</DESC>
    <DATA>
      <![CDATA[
        SELECT SNAP_PERIOD_MIN FROM TB_INSTANCE_INFO WHERE INSTANCE_ID = {0}
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTSNAPSHOTLIST" PARAMS="1">
    <DESC>(SELECTSNAPSHOTLIST)</DESC>
    <DATA>
      <![CDATA[
        SELECT snapshot, snapshot_time as date_time FROM SNAPSHOT_SHOW('{0}');
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTBASELINELIST" PARAMS="1">
    <DESC>(SELECTBASELINELIST)</DESC>
    <DATA>
      <![CDATA[
        SELECT BASELINE, 
              MIN_SNAP,
		      (SELECT SNAPSHOT_TIME FROM SNAPSHOT_SHOW('{0}') WHERE SNAPSHOT = MIN_SNAP) MIN_SNAP_TIME,
              MAX_SNAP,
		      (SELECT SNAPSHOT_TIME FROM SNAPSHOT_SHOW('{0}') WHERE SNAPSHOT = MAX_SNAP) MAX_SNAP_TIME,
          KEEP_UNTIL_TIME::date KEEP_UNTIL_TIME
		      --MIN_SNAP, MAX_SNAP,  
        FROM BASELINE_SHOW('{0}')
      ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTSNAPSHOT" PARAMS="1">
    <DESC>INSERTSNAPSHOT</DESC>
    <DATA>
      <![CDATA[
        SELECT 1 FROM snapshot('{0}');
      ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTBASELINE" PARAMS="5">
    <DESC>INSERTBASELINE</DESC>
    <DATA>
      <![CDATA[
        SELECT 1 FROM BASELINE_NEW('{0}','{1}',{2},{3},{4});
      ]]>
    </DATA>
  </ROW>  
  <ROW ID="UPDATEBASELINE" PARAMS="3">
    <DESC>UPDATEBASELINE</DESC>
    <DATA>
      <![CDATA[
        SELECT 1 FROM BASELINE_KEEP('{0}','{1}', {2}) ;
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTCHECKBASELINE" PARAMS="2">
    <DESC>(SELECTCHECKBASELINE)</DESC>
    <DATA>
      <![CDATA[
        SELECT 1 FROM BASELINE_SHOW('{0}')  WHERE BASELINE = '{1}' 
      ]]>
    </DATA>
  </ROW>

  <ROW ID="DELETEBASELINE" PARAMS="2">
    <DESC>DELETEBASELINE</DESC>
    <DATA>
      <![CDATA[
        SELECT BASELINE_DROP('{0}', '{1}');
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTSNAPSHOTREPORTSINGLESNAP" PARAMS="3">
    <DESC>(SELECTSNAPSHOTREPORTSINGLESNAP)</DESC>
    <DATA>
      <![CDATA[
        SELECT REPORT FROM REPORT('{0}',{1},{2});
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTSNAPSHOTREPORTSINGLEBL" PARAMS="2">
    <DESC>(SELECTSNAPSHOTREPORTSINGLEBL)</DESC>
    <DATA>
      <![CDATA[
        SELECT REPORT FROM REPORT('{0}','{1}', '');
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTSNAPSHOTREPORTCOMPSNAPSNAP" PARAMS="5">
    <DESC>(SELECTSNAPSHOTREPORTCOMPSNAPSNAP)</DESC>
    <DATA>
      <![CDATA[
        SELECT REPORT_DIFF AS REPORT FROM REPORT_DIFF('{0}',{1},{2},{3},{4});
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTSNAPSHOTREPORTCOMPSNAPBL" PARAMS="4">
    <DESC>(SELECTSNAPSHOTREPORTCOMPSNAPBL)</DESC>
    <DATA>
      <![CDATA[
        SELECT REPORT_DIFF AS REPORT FROM REPORT_DIFF('{0}',{1},{2},'{3}', '');
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTSNAPSHOTREPORTCOMPBLSNAP" PARAMS="4">
    <DESC>(SELECTSNAPSHOTREPORTCOMPBLSNAP)</DESC>
    <DATA>
      <![CDATA[
        SELECT REPORT_DIFF AS REPORT FROM REPORT_DIFF('{0}','{1}',{2},{3}, '');
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTSNAPSHOTREPORTCOMPBLBL" PARAMS="3">
    <DESC>(SELECTSNAPSHOTREPORTCOMPBLBL)</DESC>
    <DATA>
      <![CDATA[
        SELECT REPORT_DIFF AS REPORT FROM REPORT_DIFF('{0}','{1}','{2}', '');
      ]]>
    </DATA>
  </ROW>
  
  <ROW ID="UPDATESNAPSHOTCONFIGTOPN" PARAMS="1">
    <DESC>Snap config</DESC>
    <DATA>
      <![CDATA[
        ALTER SYSTEM SET pg_profile.topn = {0};
      ]]>
    </DATA>
  </ROW>

  <ROW ID="UPDATESNAPSHOTCONFIGRETENTION" PARAMS="1">
    <DESC>Snap config</DESC>
    <DATA>
      <![CDATA[
        ALTER SYSTEM SET pg_profile.retention = {0};
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTAPPLYCONF" PARAMS="1">
    <DESC>Snap config</DESC>
    <DATA>
      <![CDATA[
         SELECT PG_RELOAD_CONF();
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTREPORTITEMS" PARAMS="0">
    <DESC>trend report config</DESC>
    <DATA>
      <![CDATA[
        SELECT CODE, CODE_NAME FROM TB_SYS_CODE WHERE CODE BETWEEN 300 AND 399 AND CODE_NAME <> 'R' ORDER BY CODE
      ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTTRENDREPORT" PARAMS="5">
    <DESC>trend report config</DESC>
    <DATA>
      <![CDATA[
      SELECT MIN(INSTANCE_ID) INSTANCE_ID, MIN(HOST_NAME) HOST_NAME, TREND_TYPE, REG_DATE, CODE_NAME, ROUND(MAX(MAX_VALUE), 2) MAX_VALUE, ROUND(AVG(AVG_VALUE), 2) AVG_VALUE, A.collect_date, A.collect_datetime   from 
      (  
            SELECT TREND_TYPE, REG_DATE, A.INSTANCE_ID, A.HOST_NAME, CODE_NAME, ROUND(MAX(MAX_VALUE), 2) MAX_VALUE, ROUND(AVG(AVG_VALUE), 2) AVG_VALUE
            , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {4} )) * {4} ) AT TIME ZONE 'UTC' AS COLLECT_DATE
           , TO_CHAR(TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {4} )) * {4} ) AT TIME ZONE 'UTC', 'YYYYMMDDHH24MI') COLLECT_DATETIME
              FROM (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N') A JOIN TB_RPT_TREND B ON A.INSTANCE_ID = B.INSTANCE_ID JOIN TB_SYS_CODE C ON B.TREND_TYPE = C.CODE
             WHERE REG_DATE BETWEEN to_char('{1}'::TIMESTAMP, 'YYYYMMDD') AND to_char('{2}'::TIMESTAMP, 'YYYYMMDD')
               AND A.INSTANCE_ID in ({0})
               AND TREND_TYPE IN ({3})
               AND COLLECT_DT BETWEEN '{1}'::TIMESTAMP AND '{2}'::TIMESTAMP
             GROUP BY COLLECT_DATE, TREND_TYPE, REG_DATE, A.INSTANCE_ID, A.HOST_NAME, CODE_NAME
             ORDER BY TREND_TYPE, COLLECT_DATE
       ) A
      GROUP BY A.COLLECT_DATE, A.COLLECT_DATETIME, REG_DATE, CODE_NAME, TREND_TYPE
      ORDER BY A.TREND_TYPE, A.COLLECT_DATE
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTTRENDREPORT_SINGLE" PARAMS="5">
    <DESC>trend report config</DESC>
    <DATA>
      <![CDATA[
        SELECT TREND_TYPE, REG_DATE, A.INSTANCE_ID, A.HOST_NAME, CODE_NAME, ROUND(MAX(MAX_VALUE), 2) MAX_VALUE, ROUND(AVG(AVG_VALUE), 2) AVG_VALUE
        , TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {4} )) * {4} ) AT TIME ZONE 'UTC' AS COLLECT_DATE
       , TO_CHAR(TO_TIMESTAMP(FLOOR((EXTRACT('epoch' FROM COLLECT_DT) / {4} )) * {4} ) AT TIME ZONE 'UTC', 'YYYYMMDDHH24MI') COLLECT_DATETIME
          FROM (SELECT * FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN = 'N') A JOIN TB_RPT_TREND B ON A.INSTANCE_ID = B.INSTANCE_ID JOIN TB_SYS_CODE C ON B.TREND_TYPE = C.CODE
         WHERE REG_DATE BETWEEN to_char('{1}'::TIMESTAMP, 'YYYYMMDD') AND to_char('{2}'::TIMESTAMP, 'YYYYMMDD')
           AND A.INSTANCE_ID in ({0})
           AND TREND_TYPE IN ({3})
           AND COLLECT_DT BETWEEN '{1}'::TIMESTAMP AND '{2}'::TIMESTAMP
         GROUP BY COLLECT_DATE, TREND_TYPE, REG_DATE, A.INSTANCE_ID, A.HOST_NAME, CODE_NAME
         ORDER BY TREND_TYPE, COLLECT_DATE
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTTRENDREPORTSTMTSTAT" PARAMS="4">
    <DESC>trend report config</DESC>
    <DATA>
      <![CDATA[
        WITH R AS (
            --SELECT instance_id, MAX(COLLECT_DT) COLLECT_DT FROM TB_RPT_LIST WHERE COLLECT_DT > CURRENT_TIMESTAMP - INTERVAL '10 hour' AND INSTANCE_ID IN (1,2) GROUP BY INSTANCE_ID
            SELECT INSTANCE_ID, MAX(COLLECT_DT) COLLECT_DT FROM TB_RPT_LIST 
             WHERE REG_DATE BETWEEN to_char('{1}'::TIMESTAMP, 'YYYYMMDD') AND to_char('{2}'::TIMESTAMP, 'YYYYMMDD')
               AND INSTANCE_ID in ({0})
               AND TREND_TYPE = {3}
               AND COLLECT_DT BETWEEN '{1}'::TIMESTAMP AND '{2}'::TIMESTAMP 
               GROUP BY INSTANCE_ID
        ),
        O AS (
            --SELECT instance_id, MIN(COLLECT_DT) COLLECT_DT FROM TB_RPT_LIST WHERE COLLECT_DT > CURRENT_TIMESTAMP - INTERVAL '10 hour' AND INSTANCE_ID IN (1,2) GROUP BY INSTANCE_ID
            SELECT INSTANCE_ID, MIN(COLLECT_DT) COLLECT_DT FROM TB_RPT_LIST 
             WHERE REG_DATE BETWEEN to_char('{1}'::TIMESTAMP, 'YYYYMMDD') AND to_char('{2}'::TIMESTAMP, 'YYYYMMDD')
               AND INSTANCE_ID in ({0})
               AND TREND_TYPE = {3}
               AND COLLECT_DT BETWEEN '{1}'::TIMESTAMP AND '{2}'::TIMESTAMP 
               GROUP BY INSTANCE_ID
        )
        ,OLDEST AS (
            SELECT T.INSTANCE_ID, T.REG_DATE, T.COLLECT_DT,AA.*
              FROM TB_RPT_LIST T
              LEFT JOIN LATERAL (
                  SELECT 	elem->>'userid' AS USERID
                  ,elem->>'dbid'AS DBID
                  ,(elem->>'queryid')::int8 AS QUERYID
                  ,(elem->>'cqueryid')::varchar AS CQUERYID
                  ,(elem->>'calls')::int8 AS CALLS
                  ,(elem->>'total_time')::float8 AS TOTAL_TIME
                  ,(elem->>'min_time')::float8 AS MIN_TIME
                  ,(elem->>'max_time')::float8 AS MAX_TIME
                  ,(elem->>'mean_time')::float8 AS MEAN_TIME
                  ,(elem->>'stddev_time')::float8 AS STDDEV_TIME
                  ,(elem->>'rows')::int8 AS ROWS
                  ,(elem->>'shared_blks_hit')::int8 AS SHARED_BLKS_HIT
                  ,(elem->>'shared_blks_read')::int8 AS SHARED_BLKS_READ
                  ,(elem->>'shared_blks_dirtied')::int8 AS SHARED_BLKS_DIRTIED
                  ,(elem->>'shared_blks_written')::int8 AS SHARED_BLKS_WRITTEN
                  ,(elem->>'local_blks_hit')::int8 AS LOCAL_BLKS_HIT
                  ,(elem->>'local_blks_read')::int8 AS LOCAL_BLKS_READ
                  ,(elem->>'local_blks_dirtied')::int8 AS LOCAL_BLKS_DIRTIED
                  ,(elem->>'local_blks_written')::int8 AS LOCAL_BLKS_WRITTEN
                  ,(elem->>'temp_blks_read')::int8 AS TEMP_BLKS_READ
                  ,(elem->>'temp_blks_written')::int8 AS TEMP_BLKS_WRITTEN
                  ,(elem->>'blk_read_time')::float8 AS BLK_READ_TIME
                  ,(elem->>'blk_write_time')::float8 AS BLK_WRITE_TIME
              FROM   JSONB_ARRAY_ELEMENTS(T.LIST_DATA) A(ELEM)
              ) AA ON TRUE                              -- PRESERVE ALL ROWS FROM T
            JOIN O ON T.COLLECT_DT = O.COLLECT_DT AND T.INSTANCE_ID = O.INSTANCE_ID
           WHERE REG_DATE BETWEEN to_char('{1}'::TIMESTAMP, 'YYYYMMDD') AND to_char('{2}'::TIMESTAMP, 'YYYYMMDD')
        )
        ,RECENT AS (
            SELECT T.INSTANCE_ID, T.REG_DATE, T.COLLECT_DT,AA.*
              FROM TB_RPT_LIST T
              LEFT   JOIN LATERAL (
              SELECT 	elem->>'userid' AS USERID
                  ,elem->>'dbid'AS DBID
                  ,(elem->>'queryid')::int8 AS QUERYID
                  ,(elem->>'cqueryid')::varchar AS CQUERYID
                  ,(elem->>'calls')::int8 AS CALLS
                  ,(elem->>'total_time')::float8 AS TOTAL_TIME
                  ,(elem->>'min_time')::float8 AS MIN_TIME
                  ,(elem->>'max_time')::float8 AS MAX_TIME
                  ,(elem->>'mean_time')::float8 AS MEAN_TIME
                  ,(elem->>'stddev_time')::float8 AS STDDEV_TIME
                  ,(elem->>'rows')::int8 AS ROWS
                  ,(elem->>'shared_blks_hit')::int8 AS SHARED_BLKS_HIT
                  ,(elem->>'shared_blks_read')::int8 AS SHARED_BLKS_READ
                  ,(elem->>'shared_blks_dirtied')::int8 AS SHARED_BLKS_DIRTIED
                  ,(elem->>'shared_blks_written')::int8 AS SHARED_BLKS_WRITTEN
                  ,(elem->>'local_blks_hit')::int8 AS LOCAL_BLKS_HIT
                  ,(elem->>'local_blks_read')::int8 AS LOCAL_BLKS_READ
                  ,(elem->>'local_blks_dirtied')::int8 AS LOCAL_BLKS_DIRTIED
                  ,(elem->>'local_blks_written')::int8 AS LOCAL_BLKS_WRITTEN
                  ,(elem->>'temp_blks_read')::int8 AS TEMP_BLKS_READ
                  ,(elem->>'temp_blks_written')::int8 AS TEMP_BLKS_WRITTEN
                  ,(elem->>'blk_read_time')::float8 AS BLK_READ_TIME
                  ,(elem->>'blk_write_time')::float8 AS BLK_WRITE_TIME
              FROM   JSONB_ARRAY_ELEMENTS(T.LIST_DATA) A(ELEM)
            ) AA ON TRUE                              -- PRESERVE ALL ROWS FROM T
            JOIN R ON T.COLLECT_DT = R.COLLECT_DT AND T.INSTANCE_ID = R.INSTANCE_ID
            WHERE REG_DATE BETWEEN to_char('{1}'::TIMESTAMP, 'YYYYMMDD') AND to_char('{2}'::TIMESTAMP, 'YYYYMMDD')
        )
        ,STATS AS (
            SELECT
                    RECENT.INSTANCE_ID,
                    RECENT.REG_DATE,
                    RECENT.COLLECT_DT,
                    SUM(RECENT.CALLS-OLDEST.CALLS) AS SUM_CALLS,
                    SUM(RECENT.TOTAL_TIME-OLDEST.TOTAL_TIME) AS SUM_TOTAL_TIME,
                    SUM(RECENT.BLK_READ_TIME-OLDEST.BLK_READ_TIME+RECENT.BLK_WRITE_TIME-OLDEST.BLK_WRITE_TIME) AS IO_TIME,
                    SUM((RECENT.TOTAL_TIME-OLDEST.TOTAL_TIME)-(RECENT.BLK_READ_TIME-OLDEST.BLK_READ_TIME)-(RECENT.BLK_WRITE_TIME-OLDEST.BLK_WRITE_TIME)) AS CPU_TIME,
                    SUM(RECENT.ROWS-OLDEST.ROWS)  AS SUM_ROWS
              FROM  RECENT FULL JOIN OLDEST ON RECENT.INSTANCE_ID = OLDEST.INSTANCE_ID AND RECENT.USERID = OLDEST.USERID AND RECENT.DBID = OLDEST.DBID AND RECENT.CQUERYID = OLDEST.CQUERYID
             GROUP BY RECENT.INSTANCE_ID, RECENT.REG_DATE, RECENT.COLLECT_DT
        )
        SELECT (SELECT CODE_NAME FROM TB_SYS_CODE WHERE CODE = 321) AS TREND_TYPE
              ,TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD') REG_DATE
              ,RECENT.INSTANCE_ID
              ,CASE WHEN {4}=0 THEN I.HOST_NAME ELSE I.CONN_NAME END AS CLUSTER
              ,(SELECT CODE_NAME FROM TB_SYS_CODE WHERE CODE = 321) CODE_NAME
              ,RECENT.USERID
              ,RECENT.DBID
              ,RECENT.QUERYID
              ,(RECENT.CALLS - coalesce(OLDEST.CALLS, 0)) AS "calls"
              ,ROUND((RECENT.TOTAL_TIME - coalesce(OLDEST.TOTAL_TIME, 0))::numeric, 6) AS "TOTAL_TIME" --ROUND(RECENT.TOTAL_TIME - OLDEST.TOTAL_TIME)::numeric, 4) AS "total_time"
              ,(RECENT.ROWS - coalesce(OLDEST.ROWS, 0)) AS "rows"
              ,(RECENT.SHARED_BLKS_HIT - coalesce(OLDEST.SHARED_BLKS_HIT, 0))         AS SHARED_BLKS_HIT
              ,(RECENT.SHARED_BLKS_READ - coalesce(OLDEST.SHARED_BLKS_READ, 0))       AS SHARED_BLKS_READ
              ,(RECENT.SHARED_BLKS_DIRTIED - coalesce(OLDEST.SHARED_BLKS_DIRTIED, 0)) AS SHARED_BLKS_DIRTIED
              ,(RECENT.SHARED_BLKS_WRITTEN - coalesce(OLDEST.SHARED_BLKS_WRITTEN, 0)) AS SHARED_BLKS_WRITTEN
              ,(RECENT.LOCAL_BLKS_HIT      - coalesce(OLDEST.LOCAL_BLKS_HIT, 0))      AS LOCAL_BLKS_HIT
              ,(RECENT.LOCAL_BLKS_READ     - coalesce(OLDEST.LOCAL_BLKS_READ, 0))     AS LOCAL_BLKS_READ
              ,(RECENT.LOCAL_BLKS_DIRTIED  - coalesce(OLDEST.LOCAL_BLKS_DIRTIED, 0))  AS LOCAL_BLKS_DIRTIED
              ,(RECENT.LOCAL_BLKS_WRITTEN  - coalesce(OLDEST.LOCAL_BLKS_WRITTEN, 0))  AS LOCAL_BLKS_WRITTEN
              ,(RECENT.TEMP_BLKS_READ      - coalesce(OLDEST.TEMP_BLKS_READ, 0))      AS TEMP_BLKS_READ
              ,(RECENT.TEMP_BLKS_WRITTEN   - coalesce(OLDEST.TEMP_BLKS_WRITTEN, 0))   AS TEMP_BLKS_WRITTEN
              ,(RECENT.BLK_READ_TIME       - coalesce(OLDEST.BLK_READ_TIME, 0))       AS BLK_READ_TIME
              ,(RECENT.BLK_WRITE_TIME      - coalesce(OLDEST.BLK_WRITE_TIME, 0))       AS BLK_WRITE_TIME
              ,ROUND((100*(RECENT.TOTAL_TIME-OLDEST.TOTAL_TIME)/(select GREATEST(SUM_TOTAL_TIME,1) FROM STATS WHERE STATS.INSTANCE_ID = RECENT.INSTANCE_ID))::numeric,2) AS "total_time(%)"
              ,ROUND((100*(RECENT.BLK_READ_TIME-OLDEST.BLK_READ_TIME+RECENT.BLK_WRITE_TIME-OLDEST.BLK_WRITE_TIME)/(SELECT GREATEST(IO_TIME,1) FROM STATS WHERE STATS.INSTANCE_ID = RECENT.INSTANCE_ID))::numeric,2) AS IO_TIME_PERCENT
              ,ROUND((100*(RECENT.TOTAL_TIME-OLDEST.TOTAL_TIME-RECENT.BLK_READ_TIME-OLDEST.BLK_READ_TIME-RECENT.BLK_WRITE_TIME-OLDEST.BLK_WRITE_TIME)/(SELECT GREATEST(CPU_TIME,1) FROM STATS WHERE STATS.INSTANCE_ID = RECENT.INSTANCE_ID))::numeric,2) AS "cpu(%)"
              ,(100*(RECENT.CALLS-OLDEST.CALLS)/(SELECT GREATEST(SUM_CALLS,1) FROM STATS WHERE STATS.INSTANCE_ID = RECENT.INSTANCE_ID))::numeric(20, 2) AS "calls(%)"
              ,(100*(RECENT.ROWS-OLDEST.ROWS)/(SELECT GREATEST(SUM_ROWS,1) FROM STATS WHERE STATS.INSTANCE_ID = RECENT.INSTANCE_ID))::numeric(20, 2) AS "rows(%)"
              ,LEFT(RECENT.CQUERYID,10) AS queryid_md5
          FROM RECENT LEFT OUTER JOIN OLDEST ON RECENT.INSTANCE_ID = OLDEST.INSTANCE_ID  AND RECENT.CQUERYID = OLDEST.CQUERYID AND RECENT.USERID = OLDEST.USERID AND RECENT.DBID = OLDEST.DBID, TB_INSTANCE_INFO I
         WHERE RECENT.INSTANCE_ID = I.INSTANCE_ID
          ORDER BY RECENT.INSTANCE_ID, RECENT.DBID, RECENT.USERID, RECENT.QUERYID, RECENT.CQUERYID
  ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTTRENDREPORTLOCK" PARAMS="3">
    <DESC>trend report config</DESC>
    <DATA>
      <![CDATA[
           SELECT (SELECT CODE_NAME FROM TB_SYS_CODE WHERE CODE = 320) AS TREND_TYPE
                  ,INSTANCE_ID
            	    ,DB_NAME DB
                  ,BLOCKING_USER "USER"
                  ,BLOCKING_PID PID
                  ,CASE WHEN BLOCKING THEN 'True' Else 'False' END BLOCKING
                  ,BLOCKED_USER "LOCK USER"
                  ,BLOCKED_PID "LOCK PID"
                  ,LOCK_MODE "MODE"
                  ,QUERYID
                  ,MAX(DURATION) DURATION
                  ,TO_CHAR(MIN(XACT_START), 'yyyy-MM-dd HH24:mm:ss') "TRANSACTION START"
                  ,ORDER_NO
              FROM TB_RPT_LIST T
              LEFT   JOIN LATERAL (
              SELECT
                   elem->>'DB_NAME'AS DB_NAME
                  ,(elem->>'BLOCKING_USER')::varchar AS BLOCKING_USER
                  ,(elem->>'BLOCKING_PID')::int8 AS BLOCKING_PID
                  ,(elem->>'BLOCKING')::BOOL AS BLOCKING
                  ,(elem->>'BLOCKED_USER')::varchar AS BLOCKED_USER
                  ,(elem->>'BLOCKED_PID')::int8 AS BLOCKED_PID
                  ,(elem->>'LOCK_MODE')::varchar AS LOCK_MODE
                  ,(elem->>'QUERYID')::varchar AS QUERYID
                  ,(elem->>'DURATION')::float8 AS DURATION
                  ,(elem->>'XACT_START')::timestamp AS XACT_START
                  ,(elem->>'ORDER_NO')::int8 AS ORDER_NO
              FROM   JSONB_ARRAY_ELEMENTS(T.LIST_DATA) A(ELEM)
            ) AA ON TRUE
            WHERE INSTANCE_ID in ({0})
               AND REG_DATE BETWEEN to_char('{1}'::TIMESTAMP, 'YYYYMMDD') AND to_char('{2}'::TIMESTAMP, 'YYYYMMDD')
               AND TREND_TYPE = 320
               AND COLLECT_DT BETWEEN '{1}'::TIMESTAMP AND '{2}'::TIMESTAMP
            GROUP BY COLLECT_DT, INSTANCE_ID, DB_NAME, BLOCKING_USER, BLOCKING_PID, BLOCKED_USER, BLOCKED_PID, QUERYID, BLOCKING, LOCK_MODE, ORDER_NO
            ORDER BY COLLECT_DT, INSTANCE_ID, ORDER_NO
            LIMIT 1000;
  ]]>
    </DATA>
  </ROW>

  <ROW ID="SELECTTRENDREPORTQUERY" PARAMS="2">
    <DESC>trend report config</DESC>
    <DATA>
      <![CDATA[
        SELECT LEFT(QUERYID, 10) QUERYID, QUERY
          FROM tb_pgss_query_info
         WHERE INSTANCE_ID in ({0})
           AND LEFT(QUERYID, 10) IN ({1})
       UNION ALL
        SELECT DISTINCT LEFT(QUERYID, 10) QUERYID, QUERY
          FROM TB_QUERY_INFO
         WHERE INSTANCE_ID in ({0})
           AND LEFT(QUERYID, 10) IN ({1})
      ]]>
    </DATA>
  </ROW>
  <ROW ID="INSERTREPORTINFO" PARAMS="6">
    <DESC>INSERTREPORTINFO</DESC>
    <DATA>
      <![CDATA[
      INSERT INTO TB_RPT_HISTORY 
      (
	      USER_ID,
	      REPORT_DT,
	      REPORT_TYPE,
	      INSTANCE_ID,
	      REPORT_ACTION,
	      REPORT_LOG,
	      REPORT_IP
      ) VALUES (
	      '{0}',
	       NOW(),
	       {1},
	       {2},
	       {3},
	      '{4}',
	      '{5}'
      );
      ]]>
    </DATA>
  </ROW>
  <ROW ID="SELECTREPORTINFO" PARAMS="4">
    <DESC>PT_05_03_001(SELECTREPORTINFO)</DESC>
    <DATA>
      <![CDATA[
         SELECT CASE WHEN {0}=0 THEN I.HOST_NAME ELSE I.CONN_NAME END AS HOST_NAME,
               A.USER_ID, U.USER_NAME, 
               A.REPORT_DT, CASE WHEN REPORT_TYPE = 0 THEN 'Snapshot' ELSE 'Trend' END REPORT_TYPE,
               A.REPORT_IP, I.HOST_NAME,
               CASE WHEN A.REPORT_ACTION = 0 THEN 'Report' 
               		WHEN A.REPORT_ACTION = 1 THEN 'Snapshot'
               		WHEN A.REPORT_ACTION = 2 THEN 'Gen Baseline'
               		WHEN A.REPORT_ACTION = 3 THEN 'Del Baseline'
               		WHEN A.REPORT_ACTION = 4 THEN 'Mod Baseline'
               END REPORT_ACTION,
               A.REPORT_LOG
          FROM TB_RPT_HISTORY A JOIN TB_MON_USER U ON U.USER_ID = A.USER_ID LEFT OUTER JOIN TB_INSTANCE_INFO I ON A.INSTANCE_ID = I.INSTANCE_ID
        WHERE A.INSTANCE_ID = {0}
          AND A.REPORT_DT BETWEEN '{1}' AND '{2}'
        {3} ORDER BY A.REPORT_DT DESC
      ]]>
    </DATA>
  </ROW>
  <ROW ID="CREATE_FN_LONGSQL_FILTERING_COND" PARAMS="0">
    <DESC>PT_10_00_001(CREATE_FN_LONGSQL_FILTERING_COND)</DESC>
    <DATA>
      <![CDATA[
 		 	  CREATE OR REPLACE FUNCTION GET_LONGSQL_FILTERING_COND()
				  RETURNS TEXT AS 
				  $$
			  DECLARE    
			      VAR_INSTANCE_ID INT;
  			      VAR_COND_LEFT VARCHAR;
  			      VAR_COND_RIGHT VARCHAR;
  			      VAR_COND VARCHAR;
			      TMP_CONDTYPE VARCHAR;
			      TMP_STR VARCHAR;
			      VAR_RETURN VARCHAR;
			  BEGIN    
				  VAR_INSTANCE_ID = -1;
				  VAR_RETURN = '';
				  FOR VAR_INSTANCE_ID IN
	        		  SELECT INSTANCE_ID INSTANCEID FROM TB_INSTANCE_INFO WHERE COLLECT_YN = 'Y' AND DELETE_YN='N'	order by instance_id        		
			      loop
					  VAR_COND_LEFT := '''ZZ'' ';
					  VAR_COND_RIGHT := '''ZZ'' ';
			    	  FOR tmp_condtype, tmp_str IN
					      SELECT JSONB_ARRAY_ELEMENTS(RESERVED_STR::JSONB)->>'coltype' CONDTYPE,
					             JSONB_ARRAY_ELEMENTS(RESERVED_STR::JSONB)->>'typestr' STR FROM TB_HCHK_THRD_LIST THTL WHERE INSTANCE_ID = VAR_INSTANCE_ID AND HCHK_NAME = 'LONGRUNSQL' AND RESERVED_STR <> '' ORDER BY CONDTYPE
					  loop
						  if tmp_condtype = '1' then
							  VAR_COND_LEFT := VAR_COND_LEFT || ' ||BAK.USER_NAME';
							  VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || tmp_str || '''';
					      elseif tmp_condtype = '2' then 
							  VAR_COND_LEFT := concat(VAR_COND_LEFT, '||BAK.DB_NAME');
							  VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || tmp_str || '''';
					      elseif tmp_condtype = '3' then
							  VAR_COND_LEFT := concat(VAR_COND_LEFT, '||BAK.CLIENT_ADDR');
							  VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || tmp_str || '''';
					      end if;
					  end loop;
					  if VAR_COND_RIGHT <> '''ZZ'' ' then
					      VAR_COND_LEFT := concat(VAR_COND_LEFT, '||TAC.INSTANCE_ID');
					      VAR_COND_RIGHT := VAR_COND_RIGHT || '||''' || VAR_INSTANCE_ID || '''';
						  VAR_COND := ' AND ' || VAR_COND_LEFT || '<>' || VAR_COND_RIGHT;
					  else
						  VAR_COND := ' ';
					  end if;
				      VAR_RETURN := VAR_RETURN || VAR_COND;
   					  RAISE NOTICE 'VAR_INSTANCE_ID: %', VAR_INSTANCE_ID;
   					  RAISE NOTICE 'VAR_COND: %', VAR_COND;
   				      RAISE NOTICE 'VAR_RETURN: %', VAR_RETURN;
			      END LOOP;
			      return VAR_RETURN;
 			  END $$
 			  LANGUAGE 'plpgsql';
      ]]>
    </DATA>
  </ROW>
</ROWS>
